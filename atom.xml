<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SOYANGA</title>
  
  <subtitle>Hello World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://soyanga.github.io/"/>
  <updated>2019-04-01T14:46:12.926Z</updated>
  <id>https://soyanga.github.io/</id>
  
  <author>
    <name>SOYANGA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>哈希算法(上)</title>
    <link href="https://soyanga.github.io/2019/04/01/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/04/01/哈希算法(上)/</id>
    <published>2019-04-01T14:45:02.000Z</published>
    <updated>2019-04-01T14:46:12.926Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="21-哈希算法-上-：如何防止数据库中的用户信息被脱库？"><a href="#21-哈希算法-上-：如何防止数据库中的用户信息被脱库？" class="headerlink" title="[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？"></a>[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？</h1><p>哈希算法：将任意长度的二进制串映射成固定长度的二进制串，这个映射的规则就是哈希算法，通过原始数据映射后得到的二进制值就是哈希值。</p><h2 id="优秀哈希算法的要求"><a href="#优秀哈希算法的要求" class="headerlink" title="优秀哈希算法的要求"></a>优秀哈希算法的要求</h2><ul><li>从哈希值不能反向推导出原始数据（哈希算法也叫<strong>单向哈希算法</strong>）</li><li>对输入数据非常敏感，哪怕原始数据只<strong>修改了一个Bit</strong>,最后<strong>得到的哈希也大不相同</strong>；</li><li>散列<strong>冲突的概率很小</strong>，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的<strong>执行效率要尽可能高效</strong>，针对较长的文本，也能快速计算出哈希值</li></ul><a id="more"></a><h2 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h2><p><strong>安全加密</strong>，<strong>唯一标识</strong>，<strong>数据校验</strong>，<strong>散列函数</strong>，负载均衡，数据分片，分布式存储。</p><h2 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h2><h3 id="常用于加密的哈希算法："><a href="#常用于加密的哈希算法：" class="headerlink" title="常用于加密的哈希算法："></a>常用于加密的哈希算法：</h3><p><strong>MD5</strong>:MD5 Message-Digest Algorithm MD5消息摘要算法</p><p><strong>SHA:</strong> Secure Hash Algorithm 安全散列算法</p><p><strong>DES:</strong> Data Encryption Standard 数据加密标准</p><p><strong>AES:</strong> Advanced Encryption Standard 高级加密标准</p><p>加密哈希算法来说 “单项哈希 ”，“散列冲突小”两点很重要</p><p>单项哈希是一个加密哈希算法来说必要的一点。<strong>散列冲突是无法避免的</strong>，因为基于组合数学中一个非常基础的理论<strong>鸽巢原理(也叫抽屉原理)</strong>。也就是10个鸽巢，11个鸽子，那肯定有一个鸽巢的鸽子数量多于1个，换句话说，肯定由2只鸽子在1个鸽巢中。</p><p>所以哈希算法无<strong>法做到零冲突</strong>，MD5的例子哈希值是固定的128为二进制尾，能表示的数据有限的，最多标识2^128^个数据，而我们要哈希的数据是无穷的，基于鸽巢原理，如果我们存储2^128^+1个数据求哈希值，必然会发生哈希冲突。<strong>所以哈希值越长的哈希算法，散列冲突的概率越低</strong>。</p><p>没有绝对的安全加密，<strong>越复杂，越难破解的加密算法，需要计算的时间也就越长。实际开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用那种加密算法。</strong></p><h2 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h2><p>对图片的唯一标识，可以给每个图片取一个唯一标识，或者说信息摘要。比如说可以从图片二进制代码串开头取100字节，从中间取100字节，从最后再取100字节。然后将这300字节拼到一起，通过哈希算法，的到一个哈希值，将其作为图片的唯一标识。过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p><p>还可以把图片的相应图片文件在图库中的路径信息，都存储在散列表中。<strong>提高检索效率</strong></p><p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示一个很大的数据。</p><h2 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h2><p>利用<strong>哈希算法对输入数据敏感的特点</strong>，可以对数据取哈希值，从而<strong>高效校验数据是否被篡改过。</strong>（校验文件完整性正确性）</p><p>利用哈希算法的特性改动有效特性，对下载种子文件拆分成若干文件取哈希值，当下载完成后的文件拼接成一个完成文件并分别校验之前划分文件的哈希值是否改变从而确定下载数据的完整性</p><h2 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h2><p>散列函数关注的重点是哈希算法更加关注散列后的值能<strong>不能被平均分布</strong>，以<strong>及散列函数的执行快慢</strong>。（所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>1.如何防止数据库中的用户信息被脱库？你会如何存储用户密码这么重要的数据吗？<br>①使用MD5进行加密（加密存储）<br>②字典攻击：如果用户信息被“脱库”，黑客虽然拿到的是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。（字典中存储用户常用的密码）<br>③针对字典攻击，我们可以引入一个盐（salt），跟用户密码组合在一起，增加密码的复杂度。</p><p>安全和攻击是一种博弈关系，不存在结对安全，所有安全措施，只是增加攻击成本而已。</p><h2 id="区块链中使用的哈希算法"><a href="#区块链中使用的哈希算法" class="headerlink" title="区块链中使用的哈希算法"></a>区块链中使用的哈希算法</h2><p>区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。</p><p>区块头保存着 自己区块体 和 上一个区块头 的哈希值。</p><p>因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。</p><p>区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。  </p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;21-哈希算法-上-：如何防止数据库中的用户信息被脱库？&quot;&gt;&lt;a href=&quot;#21-哈希算法-上-：如何防止数据库中的用户信息被脱库？&quot; class=&quot;headerlink&quot; title=&quot;[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？&quot;&gt;&lt;/a&gt;[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？&lt;/h1&gt;&lt;p&gt;哈希算法：将任意长度的二进制串映射成固定长度的二进制串，这个映射的规则就是哈希算法，通过原始数据映射后得到的二进制值就是哈希值。&lt;/p&gt;
&lt;h2 id=&quot;优秀哈希算法的要求&quot;&gt;&lt;a href=&quot;#优秀哈希算法的要求&quot; class=&quot;headerlink&quot; title=&quot;优秀哈希算法的要求&quot;&gt;&lt;/a&gt;优秀哈希算法的要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从哈希值不能反向推导出原始数据（哈希算法也叫&lt;strong&gt;单向哈希算法&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;对输入数据非常敏感，哪怕原始数据只&lt;strong&gt;修改了一个Bit&lt;/strong&gt;,最后&lt;strong&gt;得到的哈希也大不相同&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;散列&lt;strong&gt;冲突的概率很小&lt;/strong&gt;，对于不同的原始数据，哈希值相同的概率非常小；&lt;/li&gt;
&lt;li&gt;哈希算法的&lt;strong&gt;执行效率要尽可能高效&lt;/strong&gt;，针对较长的文本，也能快速计算出哈希值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="哈希算法" scheme="https://soyanga.github.io/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>散列表(下)</title>
    <link href="https://soyanga.github.io/2019/03/28/%E6%95%A3%E5%88%97%E8%A1%A8(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/03/28/散列表(下)/</id>
    <published>2019-03-28T15:59:03.000Z</published>
    <updated>2019-03-28T16:00:10.402Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="20-散列表-下-：散列表和链表将常会一起使用"><a href="#20-散列表-下-：散列表和链表将常会一起使用" class="headerlink" title="[20]散列表(下)：散列表和链表将常会一起使用"></a>[20]散列表(下)：散列表和链表将常会一起使用</h1><h2 id="散列表和链表结合实例"><a href="#散列表和链表结合实例" class="headerlink" title="散列表和链表结合实例"></a>散列表和链表结合实例</h2><h3 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h3><ul><li>往缓存中添加一个数据</li><li>从缓存中删除一个数据</li><li>从缓存中查找一个数据</li></ul><p>维护一个按访问时间从大到小的有序排列的链表结构。 LRU缓存</p><blockquote><ul><li>因为缓存大小有限，当缓存空间不够用，需要淘汰一个数据的时候，我们就直接将链表头部节点删除。</li><li>当要缓存某个数据时，现在链表中查找这个数据，如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。</li></ul></blockquote><p>三个操作都需要设计查找操作，如果使用单链表则查找操作的时间复杂度就是O(n),如果我们将散列表和链表这两种数据结构组合使用，可以将三个操作的时间复杂度都降到O(1)。</p><a id="more"></a><p>我们使用双向链表+散列表存储 实现一个高效，支持LRU缓存淘汰算法的缓存系统原型。</p><p>链表中的每个节点存储数据<strong>(data</strong>),前驱节点(<strong>prev</strong>)、后继节点(<strong>next</strong>),之外还新增了一个特殊的字段(<strong>hnext</strong>)</p><p><img src="/2019/03/28/散列表(下)/婕\数据结构与算法之美\picture\散列表实现LRU.jpg" alt="散列表实现LRU"></p><blockquote><p><strong>一个链表是双向链表（prev next）将缓存中的数据链来（将节点连在双向链表中）</strong> </p><p><strong>另一个链表是单向链表(hnext) ，为了将节点连在散列表的拉链中。</strong></p></blockquote><h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><p>利用散列查找数据的时间复杂度是O(1),但是查找完后数据移动到双向链表的尾部。</p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>找到数据所在结点，然后将节点删除。借助散列表，我们可以在O(1)时间复杂度里找到要删除的节点。因为我们的链表是双向，O(1)时间复杂度获取到前驱节点，在双向链表中删除一个节点我们只需要O(1)的时间复杂度。</p><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>首先，在散列表中查找要添加的数据是否已经存在，存在的化将次节点移动至双向链表的对尾，反之则再判断缓存队列是否已满，如果满了，则将双向链表头部的节点删除，然后再将数据反到链表的尾部，如果缓存没有慢，则直接将数据放到链表的尾部。</p><p>整个过程涉及的查找操作都是由散列表来完成。其他操作，比如删除头节点，链表尾部插入数据等，都可以在O(1)的时间复杂度内来完成。所以三个操作的时间复杂度都是O(1)。</p><h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><p>redis有序集合中实际上还有两个重要的属性，key（键值）和score (分值)。我们不仅通过Score来查找数据，还会用过key来查找数据。</p><p>比如，用户ID(key) 和用户的积分(score)，我们可以通过ID来查找，也可以同样积分区间来查找用户。</p><h4 id="细化Redis有序集合的操作"><a href="#细化Redis有序集合的操作" class="headerlink" title="细化Redis有序集合的操作"></a>细化Redis有序集合的操作</h4><ul><li>添加一个成员对象；</li><li>按照键值来删除一个成员对象；</li><li>按照键值来查找一个成员对象；</li><li>按照分值区间查找数据，比如查找积分在[100,365]之间的成员对象；</li><li>按照分值从小到大排序成员变量；</li></ul><p>我们可以利用两种数据结构来进行存储且满足有序集合的操作，我们按照分值将成员组织成跳表结构，那按照键值来删除、查询成员对象就会很慢。所以我们在用按照键值构建一个散列表，这样按照key的操作就得以实现O(1)。</p><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>LinkedHashMap是一个传统拉链法构建的容器</p><p>这里的Linked指的是一个双向链表，默认支持按照插入顺序遍历数据，还支持按照顺序来遍历数据</p><p><strong>Java原生的LRU缓存淘汰</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>散列表虽然支持高效的数据插入，删除，查找操作，但是散列表中数据都是通过散列函数打乱后无规律存储的，无法支持按照某种顺序快速的遍历数据。如果希望按照顺序遍历散列表中数据，我们需要将散列表中数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据插入，删除，所以每当我们希望按照顺序遍历散列表中数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表(或跳表)结合使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;20-散列表-下-：散列表和链表将常会一起使用&quot;&gt;&lt;a href=&quot;#20-散列表-下-：散列表和链表将常会一起使用&quot; class=&quot;headerlink&quot; title=&quot;[20]散列表(下)：散列表和链表将常会一起使用&quot;&gt;&lt;/a&gt;[20]散列表(下)：散列表和链表将常会一起使用&lt;/h1&gt;&lt;h2 id=&quot;散列表和链表结合实例&quot;&gt;&lt;a href=&quot;#散列表和链表结合实例&quot; class=&quot;headerlink&quot; title=&quot;散列表和链表结合实例&quot;&gt;&lt;/a&gt;散列表和链表结合实例&lt;/h2&gt;&lt;h3 id=&quot;LRU缓存淘汰算法&quot;&gt;&lt;a href=&quot;#LRU缓存淘汰算法&quot; class=&quot;headerlink&quot; title=&quot;LRU缓存淘汰算法&quot;&gt;&lt;/a&gt;LRU缓存淘汰算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;往缓存中添加一个数据&lt;/li&gt;
&lt;li&gt;从缓存中删除一个数据&lt;/li&gt;
&lt;li&gt;从缓存中查找一个数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;维护一个按访问时间从大到小的有序排列的链表结构。 LRU缓存&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;因为缓存大小有限，当缓存空间不够用，需要淘汰一个数据的时候，我们就直接将链表头部节点删除。&lt;/li&gt;
&lt;li&gt;当要缓存某个数据时，现在链表中查找这个数据，如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;三个操作都需要设计查找操作，如果使用单链表则查找操作的时间复杂度就是O(n),如果我们将散列表和链表这两种数据结构组合使用，可以将三个操作的时间复杂度都降到O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="散列表" scheme="https://soyanga.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>散列表(中)</title>
    <link href="https://soyanga.github.io/2019/03/19/%E6%95%A3%E5%88%97%E8%A1%A8(%E4%B8%AD)/"/>
    <id>https://soyanga.github.io/2019/03/19/散列表(中)/</id>
    <published>2019-03-19T15:55:31.000Z</published>
    <updated>2019-03-19T15:56:34.490Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="19-散列表-中-如何打造一个工业级水平的散列表"><a href="#19-散列表-中-如何打造一个工业级水平的散列表" class="headerlink" title="[19]散列表(中) 如何打造一个工业级水平的散列表"></a>[19]散列表(中) 如何打造一个工业级水平的散列表</h1><p>不能笼统地说散列表的查询效率是O(1),影响散列表查询效率的因素：</p><blockquote><ul><li>散列函数的设计</li><li>装载因子的选取</li><li>扩容策略的选取</li><li>散列冲突的处理</li></ul></blockquote><a id="more"></a><p>在极端情况下，一个并不能达到工业级水平的散列表，会被恶意的攻击者利用。通过一些精心构造的数据，使得所有数据经过散列函数，都能够散列到同一个槽中。如果我们使用的是基于链表的冲突解决方法，那这是，<strong>散列表的这个槽就会退化成一个链表，查询在这个槽对应的时间复杂度就会从O(1)退化为O(n)。</strong></p><p>这个O(n)中的n是恶意攻击者构造的数据的总数，假如其中有10万个数据，则退化后的散列表效率就下降了10万倍。更直接点说，假如我们查询100个数据花费0.1秒，但是退化后的散列表中，在这个槽中查找一个数据就需要1万秒。这样就有可能<strong>查询操作消耗大量的CPU资源或者线程资源</strong>，导致<strong>系统无法响应其他请求</strong>，从而<strong>达到拒绝服务攻击(Dos)的目的</strong>，攻击者也就是利用了<strong>散列表碰撞攻击的基本原理</strong>。</p><p>所以我们需要设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突情况下，散列表性能急剧下降，并且能够抵抗散列碰撞攻击。</p><h2 id="散列函数的设计"><a href="#散列函数的设计" class="headerlink" title="散列函数的设计"></a>散列函数的设计</h2><p>在实际应用，如果我们已知我们在散列表存储的数据，我们需要考虑的是存储的关键字的长度，特点，分布，散列表的大小来设计<strong>散列函数</strong>。</p><h3 id="数据分析法"><a href="#数据分析法" class="headerlink" title="数据分析法"></a>数据分析法</h3><p>1.比如存储手机号，根据手机号的特点，前几位重复的几率很大，后几位重复的几率较小，我们选取后4位作为散列值。</p><p>2.散列表中存储的是单词时，我们可以利用字母的ASCII值“进位”相加，然后再跟散列表的大小求余、取模、作为散列值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">"nice"</span>)=((<span class="string">"n"</span> - <span class="string">"a"</span>) * <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">"i"</span> - <span class="string">"a"</span>)*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">"c"</span> - <span class="string">"a"</span>)*<span class="number">26</span>+ (<span class="string">"e"</span>-<span class="string">"a"</span>)) <span class="comment">//78978</span></span><br></pre></td></tr></table></figure><p>实际上散列函数的设计还有，直接寻址发法，平方取中法，折叠法，随机数法等。</p><h2 id="装载因子的选取与动态扩容策略"><a href="#装载因子的选取与动态扩容策略" class="headerlink" title="装载因子的选取与动态扩容策略"></a>装载因子的选取与动态扩容策略</h2><p><em>装载因子是我们衡量散列表中存储元素个数，和发生散了冲突概率的一个数值。</em></p><p>装载因子越大：说明散列表中元素越多，空闲位置越少，散列表冲突概率就越大。不仅插入数据的过程要多次寻址，或者拉链增长，查找的过程也会因此变慢。</p><h3 id="对于静态数据"><a href="#对于静态数据" class="headerlink" title="对于静态数据"></a>对于静态数据</h3><p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点，分布等，设计出一个冲突很少的散列函数。</p><h3 id="对于动态数据"><a href="#对于动态数据" class="headerlink" title="对于动态数据"></a>对于动态数据</h3><p>数据集合是频繁变动的，我么事先无法预知要加入的数据个数。所以我们无法一次性申请一个足够大的散列表。随着数据慢慢的加入，装载因子就会变大。当装载因子大到一定程度后，散列冲突就会变很频繁，严重影响性能。</p><h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>我们可以使用动态扩容的策略，当装载因子达到某一个阈值后，我们可以进行动态扩容，重新申请了一个更大的散列表，将数据搬移到这个新的散列表中。</p><p>散列表的扩容，并不是像数组那样只是数据搬移。因为散列表的大小变了，数据存储位置也变了，所以我们需要通过散列函数重新计算每个数据存储位置。</p><p><img src="/2019/03/19/散列表(中)/婕\数据结构与算法之美\picture\rehash.png" alt="rehash"></p><p>对于支持动态扩容的散列表，插入操作时间复杂度需要进行摊还分析法。</p><table><thead><tr><th>最好情况（没有进行扩容）插入时间复杂度</th><th>最坏情况(进行扩容)插入时间复杂度</th><th>均摊时间复杂度</th></tr></thead><tbody><tr><td>O(1)</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><p>如果我们对空间消耗很敏感的化，我们可以增加动态缩容功能。如果我们更加在意执行效率的化，能够容忍多消耗一点内存空间，那就可以不用那么费劲来缩容。</p><p>装载因子阈值的设置要权衡时间，空间复杂度。根据内存空间，和执行效率的要求，来进行选择。如果对执行效率不高，且内存空间紧张的情况下，我们可以增加负载因子的值，设置可以大于1。(拉链法)</p><h3 id="如何避免低效的扩容"><a href="#如何避免低效的扩容" class="headerlink" title="如何避免低效的扩容"></a>如何避免低效的扩容</h3><p>其实对用用户来说，需要每次插入数据的体验感都需要很好，所以我们对于那压死哈西表的最后一个插入数据来说，用户此次插入前需要对哈希表进行扩容，所消耗的时间就会边长。</p><p><strong>所以直接的”一次性扩容”就不是很合适，我们可以利用摊还分析法的思想，将那最坏时间复杂度所消耗的时间均摊到每次插入中。</strong></p><p>所以将<strong>扩容操作穿插到插入操作中，分批完成</strong>。<em>当装载因子触达阈值后，我们只申请新的空间，但不进行rehash，将老数据的内容搬移到新的散列表中。</em></p><p>当有新数据要<strong>插入</strong>时，我们将新数据插入到新的散列表中，并且顺带懂老散列表中拿出一个数据放入到新的散列表中。每次插入一个数据到散列表中，我们就顺带稍一点数据进新的散列表。每次我们都重复上面的过程。经过多次插入操作后，老的散列表中的数据就一点一点的全部搬移到新的散列表中了。这样就没有一次性数据搬移，插入操作就变得很快。<strong>这个也是一个空间换时间的方式</strong>。</p><p><img src="/2019/03/19/散列表(中)/婕\数据结构与算法之美\picture\分批扩容策略.png" alt="分批扩容策略"></p><p>期间的<strong>查询</strong>我们为了兼容新，老散列表的数据，<strong>我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</strong></p><p>这样均摊的方法，讲一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这样插入一个数据的时间复杂度就是O(1)。</p><h2 id="散列冲突处理"><a href="#散列冲突处理" class="headerlink" title="散列冲突处理"></a>散列冲突处理</h2><p>在哈西表(上)中提到了的两种方法<strong>开放寻址法(ThreadLocalMap)</strong>，<strong>拉链法(LinkedHashMap)</strong>。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>数据都存储在数组中，我们可以有效的利用CPU缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。拉链法包含指针，序列化起来就没有那么容易。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>删除数据比较繁琐，需要添加标记。所有数据存储在数组中，随着负载因子的加大，发生冲突后，就会造成恶性循环，加大下一次发生冲突的概率。</p><p>所以使用开放寻址法的散列表，<strong>装载因子的上线不能太大</strong>。所以使用开放寻址法的散列表，<strong>装载因子的上线不能太大</strong>。这种方法比拉链法更加浪费内存空间。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p><strong>数据量比较小，装载因子比较小的时候，适合开放寻址法</strong>。这也是Java中的<strong>ThreadLocalMap</strong>使用开放寻址法解决散列冲突的原因。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>拉链法对内存的利用率比开放寻址法要高。因为链表节点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。<strong>(链表优于数组)</strong></p><p>链表法比开放寻址法，<strong>对于大装载因子容量更高</strong>，开放寻址法装载因子接近1时，就会有大量散列冲突，导致大量的探测，再散列等措施，性能会见降低很对。但是对于链表法来说，<strong>只要散列函数的值随机均匀，即便装载因子变成1</strong>，也就是链表长度长了一点，查找效率虽然有所下降，但是比顺序表查找还是快很多。</p><p><strong>拉链法的升级，将链表达到某一长度后变为更高效的红黑树，跳表等</strong>。这样即便出现散列冲突，极端情况下，所有数据都散列到了同一个桶里，那最终退化成的散列表的查询时间不过是<strong>O(logn)</strong>。这样也避免了DOS攻击。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p><strong>链表中存储指针(next 4字节)，所以对于比较小的对象的存储，比较消耗内存，还有可能会让内存消耗翻倍</strong>，而且，因为链表中的节点零散分布在内存中，不连续，<strong>所以对CPU缓存不友好</strong>，对于<strong>执行效率也有一定影响</strong>。</p><p>如果存储的是大对象，就可以忽略上面这一点。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>基于链表的散列冲突处理方法比<strong>较适合存储大对象、大数据量的散列表</strong>，而且，比起开放寻址法，它<strong>更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p><h2 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h2><p>Java  HashMap</p><h3 id="初始大小"><a href="#初始大小" class="headerlink" title="初始大小"></a>初始大小</h3><p>HashMap默认的初始化大小16，这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修默认初始大小，减少动态扩容的次数。这样会大大提高HashMap的性能。</p><h3 id="装载因子和动态扩容"><a href="#装载因子和动态扩容" class="headerlink" title="装载因子和动态扩容"></a>装载因子和动态扩容</h3><p>最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity(capacity表示散列表容量)时候，就会启动动态扩容，每次扩容都会扩容为原来的2倍大小。</p><h3 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h3><p>HashMap底层采用拉链法来解决冲突。即使负载因子和散列函数设计的再合理，也免不了会出现拉链过程的情况，一旦出现拉链过长，则会严重影响HashMap的性能。</p><p>在JDK1.8版本中，为了对hashMap做了进一步优化，引入了红黑树。当链表长度(默认超过8)时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高HashMap新跟那个。当红黑树节点个数小于6的时候，红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数的设计并不复杂，追求的是简单高效，分布均匀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>如何设计一个工业级别的Hash表，应对各种异常情况，防止在极端情况下，散列表的性能退化过于严重。</p><ul><li>如何设计散列函数</li><li>如何根据装载因子动态扩容</li><li>如何选择散列冲突解决方法。</li></ul><p>散列函数的设计：我们尽可能让经过散列函数后的值随机分布，这样会尽可能的减少散列冲突，即便冲突后，分配到每一槽的数据也比均匀。除此之外，<strong>散列函数的设计也不能太复杂，太复杂就会消耗太多时间，会影响散列表的性能。</strong></p><p>关于散列冲突解决方法的选择，根据合适的情况选择合适方法。大部分情况下链表发更为合适。而且，我们还可以将链表法中链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成O(n),低于散列碰撞攻击。但是对于小规模数据，装载因子不高的散列表，比较合适用开放寻址法。</p><p>对于动态散列表来说，散列函数，<strong>散列冲突解决方法，都无法解决散列冲突问题，只是缓解。随着数据的不断增加，散列表总会出现装载因子过高的情况</strong>。这时候，我们就需要启动动态扩容。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;19-散列表-中-如何打造一个工业级水平的散列表&quot;&gt;&lt;a href=&quot;#19-散列表-中-如何打造一个工业级水平的散列表&quot; class=&quot;headerlink&quot; title=&quot;[19]散列表(中) 如何打造一个工业级水平的散列表&quot;&gt;&lt;/a&gt;[19]散列表(中) 如何打造一个工业级水平的散列表&lt;/h1&gt;&lt;p&gt;不能笼统地说散列表的查询效率是O(1),影响散列表查询效率的因素：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;散列函数的设计&lt;/li&gt;
&lt;li&gt;装载因子的选取&lt;/li&gt;
&lt;li&gt;扩容策略的选取&lt;/li&gt;
&lt;li&gt;散列冲突的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="散列表" scheme="https://soyanga.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>散列表(上)</title>
    <link href="https://soyanga.github.io/2019/03/19/%E6%95%A3%E5%88%97%E8%A1%A8(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/03/19/散列表(上)/</id>
    <published>2019-03-19T15:51:40.000Z</published>
    <updated>2019-03-19T15:54:33.153Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="18-散列表-上"><a href="#18-散列表-上" class="headerlink" title="[18]散列表(上)"></a>[18]散列表(上)</h1><p>Word 单词检查功能-Hash Table</p><p>利用数组的下标随机访问，时间复杂度O(1)这个特性，就可以实现快速查找编号对应大的选手信息。</p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p><strong>散列表键(key)或者关键字</strong>来表示一组数据的关键信息。然后利用<strong>散列函数(Hash函数)</strong>来转化为数组下标。而散列函数计算得到的值就是<strong>散列值(Hash值，哈希值)</strong>。数组下标中存储的值称为<strong>value</strong>。</p><p><img src="/2019/03/19/散列表(上)/哈希表原理.png" alt="哈希表原理"></p><p>由于<strong>散列表用的是数组支持按照下标随机访问的时候</strong>，时间复杂符是<strong>O(1)</strong>的特性。我们通散列函数把元素的建制映射为下标，然后将数据存储在数组中对应的下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将建值转化为数组下标，从对应的数组下标的位置取数据。</p><a id="more"></a><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数的表现形式有多种，其中最为常用的取模（按照基本数组的长度)。</p><p>还有其他的散列函数</p><h2 id="如何构造散列函数"><a href="#如何构造散列函数" class="headerlink" title="如何构造散列函数"></a>如何构造散列函数</h2><ul><li>散列函数计算得到的散列值是一个非负数</li><li>如果key1 = key2,那hash(key1) == hash(key2);</li><li>如果key1 != key2，那hash(key1) !=hash(key2);</li></ul><p>其中第三点的很难做到，想要找到一个不同的key对应的散列值都不一样的散列函数，几乎时不可能的。</p><p>因为数组的存储空间有限，也会加大<strong>散列冲突</strong>的概率。</p><h2 id="如何解决散列冲突问题"><a href="#如何解决散列冲突问题" class="headerlink" title="如何解决散列冲突问题"></a>如何解决散列冲突问题</h2><p> 常用解决散列冲突的方法有两类，开放寻址法和链表法。</p><h3 id="开发寻址法"><a href="#开发寻址法" class="headerlink" title="开发寻址法"></a>开发寻址法</h3><p>开放寻址法的核心思想就i是，如果出现散列冲突，我们就重新探测一个空闲的位置，将其插入。探测的方法有多种，比如<strong>线性探测</strong>，<strong>二次探测</strong>，<strong>双重散列</strong>。</p><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>假如要存储的值经过hash算法计算后得到的下标已经被占用，就向后线性一个一个向后进行探测。</p><p>所谓探测，有三点要求</p><blockquote><p>哈希冲突的下标后也已经被占用则就继续向后探测，直到找到数组中没有被占用的下标将冲突的数据插入。</p></blockquote><blockquote><p>假如从发生哈希冲突的那个点开始，向后进行线性探测，探测到数组的末尾后就又从数组的头开始进行探测。</p><p>假如从在Hashtable中删除了某个元素，我们就需要将当前删除的元素做一个标记（falg）。</p></blockquote><p>只有满足探测的位置为空且探测位置没有flag标记，才进行数据的存储。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>在线性探测的基础上，只是改变了探测的规则，每次探测相隔的距离不同。比如说每次探测的跨度为2。</p><h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>当插入数据的时候使用hash1(),当发生散列冲突的时候就要使用hash2()，再次发生散列冲突的时候再次使用hash3()。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>开发地址法：<strong>有一个致命的缺点，就是他只能缓解少量散列冲突，当散列冲突发生多次时，后续对Hash表的插入发生散列冲突的概率就会大大提高</strong>，<strong>散列表的性能就会下降</strong>。进而为了保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定的比例的空闲槽位。我们引入了<strong>装载因子</strong>来表示空位的多少。</p><p>装载因子的计算公式是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子 = 填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能就会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>链表法是一种更加常用的散列冲突解决方法，相比开放寻址法，它更为有效，采用空间换时间的原理。</p><p><strong>数组+链表存储结构</strong></p><p>每当发生散列冲突时，就将发生冲突的数据存储在链表中。链表插入操作时间复杂度O(1),查找删除一个元素怒时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或者删除时间复杂度实际上跟链表长度K成正比，也就是O(k)。</p><p>对于散列表均匀的散列表来说，理论上讲，k = n/m,其中n表示表示散列中数据的个数，m表示散列表中的槽数。</p><h2 id="Word文档中单词检查拼写功能是如何实现的？"><a href="#Word文档中单词检查拼写功能是如何实现的？" class="headerlink" title="Word文档中单词检查拼写功能是如何实现的？"></a>Word文档中单词检查拼写功能是如何实现的？</h2><p>将常用单词(约20万)存放到散列表中，平均一个单词10字节的内存空间，那么20万英文单词约占2MB空间，将2MB的数据存储在内存中。</p><p>当我们输入英文单词时，我们就拿用户输入的单词去散列表中进行查找。如果查找到，说明拼写正确；如果没有查找到，则说明拼写可能有误，给予提示，借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;18-散列表-上&quot;&gt;&lt;a href=&quot;#18-散列表-上&quot; class=&quot;headerlink&quot; title=&quot;[18]散列表(上)&quot;&gt;&lt;/a&gt;[18]散列表(上)&lt;/h1&gt;&lt;p&gt;Word 单词检查功能-Hash Table&lt;/p&gt;
&lt;p&gt;利用数组的下标随机访问，时间复杂度O(1)这个特性，就可以实现快速查找编号对应大的选手信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;散列表键(key)或者关键字&lt;/strong&gt;来表示一组数据的关键信息。然后利用&lt;strong&gt;散列函数(Hash函数)&lt;/strong&gt;来转化为数组下标。而散列函数计算得到的值就是&lt;strong&gt;散列值(Hash值，哈希值)&lt;/strong&gt;。数组下标中存储的值称为&lt;strong&gt;value&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/19/散列表(上)/哈希表原理.png&quot; alt=&quot;哈希表原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;strong&gt;散列表用的是数组支持按照下标随机访问的时候&lt;/strong&gt;，时间复杂符是&lt;strong&gt;O(1)&lt;/strong&gt;的特性。我们通散列函数把元素的建制映射为下标，然后将数据存储在数组中对应的下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将建值转化为数组下标，从对应的数组下标的位置取数据。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="散列表" scheme="https://soyanga.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>跳表</title>
    <link href="https://soyanga.github.io/2019/03/12/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://soyanga.github.io/2019/03/12/跳表/</id>
    <published>2019-03-12T14:47:22.000Z</published>
    <updated>2019-03-12T14:48:59.338Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="跳表-beers-–动态数据结构"><a href="#跳表-beers-–动态数据结构" class="headerlink" title="跳表:beers:–动态数据结构"></a>跳表:beers:–动态数据结构</h1><p>二分查找算法中底层是依赖数组实现的（依赖数组的随机访问的特性）。又有众多弊端，比如只能操作已排好序的数据。且拥有数组这个数据结构的弊端。比如对数据频繁的增加或者删除操作时间复杂度高，每次数据增加删除还需要保持数据的有序性（即只支持静态数据集），存储数据必须依数组所以开辟内存时，必须是需要连续的内存空间。（对空间要求比较严格)。  数据量太小也不需要使用二分查找，基本没有什么性能上的区别，但是假如一个数据集中它存储的（300字符）字符串，比较操作比较费时间，则就可以使用二分查找。</p><p>二分查找的思想其实可以用在链表中，比如：跳表</p><p>跳表的核心思想：分区，建立多级索引，“二分查找”</p><p>跳表可以支持快速插入，删除，查找操作，写起来也不复杂，代码的可读性较高（跟功能差不多的红黑树相比），Redis中的有序集合(Sort Set)就是用跳表来实现的<strong>。为什么Redis中会选取跳表作为实现有序集合而不是红黑树</strong>？</p><a id="more"></a><h2 id="跳表的数据结构详解"><a href="#跳表的数据结构详解" class="headerlink" title="跳表的数据结构详解"></a>跳表的数据结构详解</h2><p>对于一个单链表来说，即便链表中存储的数据是有序的查找链表中的某一个值得元素，也需要O(n)的时间复杂度，如何提高查找效率，一想到查找，就想到数据库中的查找（建立索引）。对于一个有序链表我们可以建立索引（分成区间），缩短从链表头部向目标元素的遍历的节点个数，从而达到提高查找效率。</p><h3 id="索引建立（多级索引）"><a href="#索引建立（多级索引）" class="headerlink" title="索引建立（多级索引）"></a>索引建立（多级索引）</h3><p>在原始链表上建立索引或者称为(索引层)。其中索引层节点中存储的是索引值和指向索引值的对应下一级节点的指针(down指针)。</p><blockquote><p>单级索引是提高了不少查找的效率但是多级索引更能提升性能。</p></blockquote><p>这种链表+多级索引的数据结构，就是跳表。如下图：</p><p><img src="/2019/03/12/跳表/婕\数据结构与算法之美\picture\跳表图解.jpg" alt="跳表图解"></p><h2 id="跳表的查找删除的时间复杂度分析"><a href="#跳表的查找删除的时间复杂度分析" class="headerlink" title="跳表的查找删除的时间复杂度分析"></a>跳表的查找删除的时间复杂度分析</h2><h3 id="跳表查询时间复杂度分析"><a href="#跳表查询时间复杂度分析" class="headerlink" title="跳表查询时间复杂度分析"></a>跳表查询时间复杂度分析</h3><p>假如我们如上图定义的每隔一个节点就建立一个索引，那么假设原始数据有n个节点，则建立得到第一级节点大约就有n/2个节点，再往上建立索引则就有n/4、n/8、n/16…即第k层建立的索引是K-1层建立索引的1/2，那么第k级索引节点个数就是n/(2^k^)。</p><p><img src="/2019/03/12/跳表/婕\数据结构与算法之美\picture\多层跳表解析.jpg" alt="多层跳表解析"></p><p>假设我们的原始数据建立的索引有h层，最高层的索引有两个节点。则 <strong>n/(2^h^) = 2</strong> ,从而求得 <strong>h = log~2~(n-1)</strong></p><p>我们求得整个跳表得高度就是<strong>log2^(n-1)</strong>^,假设每层跳表我们遍历m个节点则从跳表中查询一个元素的时间复杂度就是<strong>O(m*logn)</strong>。</p><p>由于我们跳表是每隔一个节点就建立一个上层索引，最上层索引的节点的数量最大不超过3。从最上层节点确定区间后再往down指针下寻找更细的的区间划分在此层也只需按照上层一样最多遍历3个节点，依次类推。<strong>m的值就是一个常数3</strong>。</p><p>所以在跳表中查找人一个数据的<strong>时间复杂度就是O(logn)</strong>,这个查找的时间复杂度跟二分查找的时间复杂度相同，所以近似上我们是纵向的划分索引，然后横向利用二分查找，找符合区间的思想一层一层向下遍历，直到找到目标元素。</p><p><img src="/2019/03/12/跳表/婕\数据结构与算法之美\picture\跳表时间复杂度分析.jpg" alt="跳表时间复杂度分析"></p><h2 id="跳表的空间复杂度"><a href="#跳表的空间复杂度" class="headerlink" title="跳表的空间复杂度"></a>跳表的空间复杂度</h2><p>跳表的思想就是典型的用空间换时间的思想，几乎所有查找高效的数据结构都是用这样的思想。</p><p>假设原始链表大小为n，那第一级索引大约有n/2个节点，第二级索引大约有n/4个节点，依次类推，每上升一级就减少一半，直到剩下2个节点。所以跳表的索引节点总数为:n/2+n/4+n/8+…+8+4+2=n-2。是一个等比数列所以跳表的时间复杂度是O(n)。</p><h3 id="减少跳表的占用的内存空间"><a href="#减少跳表的占用的内存空间" class="headerlink" title="减少跳表的占用的内存空间"></a>减少跳表的占用的内存空间</h3><p>我们可以通过每隔多层节点建立索引，比如每隔2个结点或者每隔3个节点建立索引。那么就可以减少每层索引的节点数目。</p><p>当每隔2个节点就建立索引的化，我们建立索引的节点数=n/3+n/9+n/27+9+3+1=n/2。尽管空间复杂度还是O(n),但是比上面的每两个节点抽出一个节点的索引构建的方法，要减少一半的索引节点存储空间。</p><h3 id="实际开发中看待索引节点占用的空间"><a href="#实际开发中看待索引节点占用的空间" class="headerlink" title="实际开发中看待索引节点占用的空间"></a>实际开发中看待索引节点占用的空间</h3><p>实际开发中索引节点中存储的是要查找的对象属性和一个down指针，原始数据存储的则是大的对象，相比于原始数据的大小，索引所占用的额外的空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>因为数据的插入和删除都需要保证原始数据的有序，所以跳表的插入也需要用到插找的思想，找到适合插入的前一个节点后面，利用链表插入操作对原始数据进行插入。</p><p>删除跟插入类似，但是删除必须利用查找找到要删除节点的前驱节点，进行链表是删除操作。</p><h2 id="跳表的索引更新"><a href="#跳表的索引更新" class="headerlink" title="跳表的索引更新"></a>跳表的索引更新</h2><p>假如在原始数据的基础上跳表中的元素增加删除会导致某一个区间里面的元素众多，导致查找效率变低，甚至跟单链表查找效率类似。作为一个动态结构，我们需要某种手段来维护索引与原始链表大小的之间的平衡，如果某个区间内节点过多就需要多建立索引，某个区间内节点过少就要适当删减索引。</p><h3 id="跳表维护平衡性"><a href="#跳表维护平衡性" class="headerlink" title="跳表维护平衡性"></a>跳表维护平衡性</h3><p>通过一个随机数函数，来决这个节点插入到那几级索引中，随机函数生成了k就将这个节点添加到第一级到第k级这k级索引中。</p><h2 id="为什么Redis中的有序集合是通过跳表来实现的"><a href="#为什么Redis中的有序集合是通过跳表来实现的" class="headerlink" title="为什么Redis中的有序集合是通过跳表来实现的"></a>为什么Redis中的有序集合是通过跳表来实现的</h2><p>严格上来讲，起始还用到了散列表。</p><p>根据Redis开发手册，就会发现Redis中的有序结合支持的核心操作主要有下面几个:</p><ul><li>插入一个数据</li><li>删除一个数据</li><li>查找一个数据</li><li>按照区间查找数据(比如查找[0,100]之间的数据)</li><li>迭代输出有序序列</li></ul><ol><li>除了区间查找这个操作，跳表可一做到O(logn)的时间复杂度定位区间定位起点，然后在原始链表中顺序往后遍历就可以了，比红黑树来说高效，其余操作红黑树跟跳表都可以高效实现。</li><li>跳表代码相比红黑树来说易于实现，且代码可读性高，不易出错，跳表更加灵活，它可以通过该表索引构建策略，有效平衡执行效率和内存消耗。</li></ol><p>缺点：</p><p>跳表出现的时间比较晚，很多编程语言中Map类型都是红黑树来实现的。业务开发过程中，直接拿来使用就可以了，不需要费劲自己去实现一个红黑树，但是跳表并没有一个线程的实现，所以开发中，如果你想使用跳表，必须要自己实现。</p><h1 id="跳表的实现"><a href="#跳表的实现" class="headerlink" title="跳表的实现"></a>跳表的实现</h1>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;跳表-beers-–动态数据结构&quot;&gt;&lt;a href=&quot;#跳表-beers-–动态数据结构&quot; class=&quot;headerlink&quot; title=&quot;跳表:beers:–动态数据结构&quot;&gt;&lt;/a&gt;跳表:beers:–动态数据结构&lt;/h1&gt;&lt;p&gt;二分查找算法中底层是依赖数组实现的（依赖数组的随机访问的特性）。又有众多弊端，比如只能操作已排好序的数据。且拥有数组这个数据结构的弊端。比如对数据频繁的增加或者删除操作时间复杂度高，每次数据增加删除还需要保持数据的有序性（即只支持静态数据集），存储数据必须依数组所以开辟内存时，必须是需要连续的内存空间。（对空间要求比较严格)。  数据量太小也不需要使用二分查找，基本没有什么性能上的区别，但是假如一个数据集中它存储的（300字符）字符串，比较操作比较费时间，则就可以使用二分查找。&lt;/p&gt;
&lt;p&gt;二分查找的思想其实可以用在链表中，比如：跳表&lt;/p&gt;
&lt;p&gt;跳表的核心思想：分区，建立多级索引，“二分查找”&lt;/p&gt;
&lt;p&gt;跳表可以支持快速插入，删除，查找操作，写起来也不复杂，代码的可读性较高（跟功能差不多的红黑树相比），Redis中的有序集合(Sort Set)就是用跳表来实现的&lt;strong&gt;。为什么Redis中会选取跳表作为实现有序集合而不是红黑树&lt;/strong&gt;？&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="跳表" scheme="https://soyanga.github.io/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二分查找(下)</title>
    <link href="https://soyanga.github.io/2019/03/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/03/05/二分查找(下)/</id>
    <published>2019-03-05T14:04:49.000Z</published>
    <updated>2019-03-05T14:05:40.481Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="16-二分查找-下-：如何快速定位IP对应的省份地址"><a href="#16-二分查找-下-：如何快速定位IP对应的省份地址" class="headerlink" title="[16]二分查找(下)：如何快速定位IP对应的省份地址"></a>[16]二分查找(下)：如何快速定位IP对应的省份地址</h1><h2 id="4种常见的二分查找变形问题-four"><a href="#4种常见的二分查找变形问题-four" class="headerlink" title="4种常见的二分查找变形问题:four:"></a>4种常见的二分查找变形问题:four:</h2><blockquote><ul><li>查找第一个值等于给定值的元素</li><li>查找对后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值的元素</li></ul></blockquote><a id="more"></a><h3 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low &lt; n &amp;&amp; a[low]==value)&#123;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)&#123;</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt;value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid == <span class="number">0</span>)||(a[mid-<span class="number">1</span>]!=value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稍加解释："><a href="#稍加解释：" class="headerlink" title="稍加解释："></a>稍加解释：</h4><p>区间mid值判断只有三种情况</p><ul><li>mid值大于value值<ul><li>high = mid -1;</li></ul></li><li>mid值小于value值<ul><li>low = mid+1;</li></ul></li><li>mid值等于value值<ul><li>mid值==0    说明value对应的值已经是数组第一个元素前面没有相同的元素</li><li>a[mid-1]对应的不是value值  说明value对应的值已经是肯定是查找到的第一个元素</li><li>不符合以上两种的  说明当前下标对应的元素不是找到的第一个元素，前面还有相同的值<ul><li>high = mid - 1;</li></ul></li></ul></li></ul><h3 id="查找对后一个值等于给定值的元素"><a href="#查找对后一个值等于给定值的元素" class="headerlink" title="查找对后一个值等于给定值的元素"></a>查找对后一个值等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid==n-<span class="number">1</span>) || (a[mid+<span class="number">1</span>]!=value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟第一种思路差不多</p><h3 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt;= value)&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid == <span class="number">0</span>)|| (a[mid -<span class="number">1</span>] &lt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍加解释；</p><ul><li>如果a[mid]小于要查找的值value,那么查找的值肯定在[mid+1,high]之间，更新 low = mid+1;</li><li>如果a[mid]大于要查找的值value，那么我们先看一下这个a[mid]是不是我们要找的第一个值大于等于给定值得元素。如果a[mid]前面已经没有元素，或者前面一个元素小于要查找的值value,那么a[mid]就是我们要查找的元素。</li><li>如果a[mid - 1]也大于等于要查找的值value,那么说明要查找的元素在[low,mid-1]之间，更新high = mid-1;</li></ul><h3 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span> <span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; value)&#123;</span><br><span class="line">            high = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid == n-<span class="number">1</span>)|| (a[mid+<span class="number">1</span>] &gt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决思考题：查找12万条IP归属地中目标IP归属地</p><p>假设IP地址与归属地的对应关系不经常更新，我们可以预先处理12万条数据，让其按照IP从小到大排序。ip地址可以转化为12万条数据，让其按其实IP从小到大排序。</p><p>然后查找在有序数组中，最后一个小于等于某个给定值的元素。</p><p>找到最后一个其实Ip小于等于这个IP的IP区间，检查这个IP是否在这个IP区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。-1</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>二分查找的表中容易出错</p><p>处理<strong>好终止条件 ，区间上下界更新的方法，返回值的选择。</strong></p><p>LeetCode 33题</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;16-二分查找-下-：如何快速定位IP对应的省份地址&quot;&gt;&lt;a href=&quot;#16-二分查找-下-：如何快速定位IP对应的省份地址&quot; class=&quot;headerlink&quot; title=&quot;[16]二分查找(下)：如何快速定位IP对应的省份地址&quot;&gt;&lt;/a&gt;[16]二分查找(下)：如何快速定位IP对应的省份地址&lt;/h1&gt;&lt;h2 id=&quot;4种常见的二分查找变形问题-four&quot;&gt;&lt;a href=&quot;#4种常见的二分查找变形问题-four&quot; class=&quot;headerlink&quot; title=&quot;4种常见的二分查找变形问题:four:&quot;&gt;&lt;/a&gt;4种常见的二分查找变形问题:four:&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查找第一个值等于给定值的元素&lt;/li&gt;
&lt;li&gt;查找对后一个值等于给定值的元素&lt;/li&gt;
&lt;li&gt;查找第一个大于等于给定值的元素&lt;/li&gt;
&lt;li&gt;查找最后一个小于等于给定值的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="二分查找" scheme="https://soyanga.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>二分查找(上)</title>
    <link href="https://soyanga.github.io/2019/03/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/03/03/二分查找(上)/</id>
    <published>2019-03-03T15:18:53.000Z</published>
    <updated>2019-03-03T15:20:44.750Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="15-二分查找-上-：如何用最省内存的方式实现快速查找功能"><a href="#15-二分查找-上-：如何用最省内存的方式实现快速查找功能" class="headerlink" title="[15]二分查找(上)：如何用最省内存的方式实现快速查找功能"></a>[15]二分查找(上)：如何用最省内存的方式实现快速查找功能</h1><h2 id="二分查找-Binary-Search-open-book"><a href="#二分查找-Binary-Search-open-book" class="headerlink" title="二分查找(Binary Search) :open_book:"></a>二分查找(Binary Search) :open_book:</h2><p>Binary Search 算法，也称折半查找。二分查找的思想很简单-类似与小时候玩的猜数字游戏。</p><p>一个人先确定一个数组，另一个随便猜一个数字(中间数)。确定数字的那个人只需要说大了还是小了就行。每说一次就能让可能存在这个数的区间减小一半，知道区间减小到只有一个数字即猜对了这个数。(最坏情况)</p><a id="more"></a><p><img src="/2019/03/03/二分查找(上)/婕\数据结构与算法之美\picture\二分查找猜数字游戏.png" alt="二分查找猜数字游戏"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><strong>二分查找针对的是一个==有序的数据结合==，查找思想有点类似分治思想，每次都通过跟区间的==中间元素==对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0</strong></p><p>二分查找的时间复杂度：O(logn)</p><blockquote><p>被查找期间的大小变化</p><p>n ，n/2 , n/4 , n/8 , n/2^k…</p></blockquote><p>可以看出，这是一个等比数列。其中n/2^k=1时，k的值就是总共缩小的次数，而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就时O(k)。又因为n/2^k=1,我们可以求出k=log2n，所以时间复杂度就是O(logn)。</p><p>O(logn) 的时间复杂度比一定比O(1)时间复杂度的算法执行效率高。大O标记法表示时间复杂度得到时候，会忽略掉低阶，常数，系数。对于常量级的时间复杂度算法来说。O(1)可能表示的是一个非常大的常量值,比如O(1000),O(10000).所以常量级时间复杂度算法有时候可能还没有O(logn)的算法执行效率高。</p><h2 id="简单版本二分查找的递归与非递归实现"><a href="#简单版本二分查找的递归与非递归实现" class="headerlink" title="简单版本二分查找的递归与非递归实现"></a>简单版本二分查找的递归与非递归实现</h2><p>最简单的情况就是有序数组中不存在重复元素。</p><h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(a[mid] == vaule)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;value)&#123;</span><br><span class="line">            low= mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><h5 id="循环的条件"><a href="#循环的条件" class="headerlink" title="循环的条件"></a>循环的条件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">low&lt;=high</span><br></pre></td></tr></table></figure><h5 id="mid的取值"><a href="#mid的取值" class="headerlink" title="mid的取值"></a>mid的取值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果使用mid = (low+high)/2，可能会导致数据的溢出。改进方法有三种</span><br><span class="line">1.mid = low +(high-low)/2;</span><br><span class="line">2.mid = low+((high-low)&gt;&gt;1);</span><br><span class="line">3.mid = (low&amp;high)+((low^high)&gt;&gt;1);</span><br></pre></td></tr></table></figure><h5 id="low和high值的更新"><a href="#low和high值的更新" class="headerlink" title="low和high值的更新"></a>low和high值的更新</h5><p>low=mid+1,high=mid-1。注意这里的+1和-1.如果直接写成low=mid或者high=mid，就可能造成死循环，因为当low=3,high=3时但是a[3]不能与value,本应该就跳出循环，但是如果low和high的更新值错误导致死循环。</p><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> n,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> brearchInternally(a,<span class="number">0</span>,n-<span class="number">1</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">brearchInternally</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)&#123;</span><br><span class="line">        reutrn value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;vlaue)&#123;</span><br><span class="line">    <span class="keyword">return</span> brearchInternally(a,mid+<span class="number">1</span>,high,value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brearchInternally(a,low,mid-<span class="number">1</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找的应用场景的局限性"><a href="#二分查找的应用场景的局限性" class="headerlink" title="二分查找的应用场景的局限性"></a>二分查找的应用场景的局限性</h2><table><thead><tr><th>时间复杂度</th><th>使用特定数据结构存储数据</th><th>数据必须达到的特殊要求</th></tr></thead><tbody><tr><td>O(logn)</td><td>二分查找依赖舒顺序表(数组)，按下标随机访问数据时间复杂度O(1)</td><td>二分查找针对的有序数据，且不能频繁的删除，插入。一次排序，多次二分查找</td></tr></tbody></table><h3 id="特定的数据结构顺序表-数组"><a href="#特定的数据结构顺序表-数组" class="headerlink" title="特定的数据结构顺序表-数组"></a>特定的数据结构顺序表-数组</h3><p>二分查找需要按照下标随机访问。数组按照下标随机访问数据时间复杂度是O(1),而链表随机访问时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂度就会变得很高。</p><h3 id="针对的数据必须是有序的"><a href="#针对的数据必须是有序的" class="headerlink" title="针对的数据必须是有序的"></a>针对的数据必须是有序的</h3><p>要想使用二分查找时，数据必须是有序的。如果数据没有序，我们需要先排序。排序最低的时间复杂度是O(nlogn)。如果我们针对的是一个静态的数据，没有频繁的插入，删除，我们可以进行一次排序，多次二分查找。这样排序成本被均摊了，二分查找的边际成本就会比较低。</p><p>但是针对动态的数据，一直有数据的频繁的插入和删除操作，要想使用二分查找，要么每次插入，删除操作后保证数据仍有序，要么在每次二分查找前必须进行排序。这种动态数据集合，无论那种方法，维护有序的成本都很高。</p><p>二分查找只能应用在插入和删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找不再适用。我们将适用二叉树。</p><h3 id="数据量太小不适合二分查找"><a href="#数据量太小不适合二分查找" class="headerlink" title="数据量太小不适合二分查找"></a>数据量太小不适合二分查找</h3><p>如果要处理的是数据量很小的数据，没有必要适用二分插找，直接使用顺序遍历就可以了。只有数据量比较大时，二分查找的优势才会比较明显。</p><p>但是有一个特例：</p><p>比如数据之间的比较操作比较耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间对比就会非常耗时。我们需要尽可能的减少比较次数，而比较次数的减少会大大提高性能，此时使用二分查找效果更好。</p><h3 id="数据量太大也不适合二分查找"><a href="#数据量太大也不适合二分查找" class="headerlink" title="数据量太大也不适合二分查找"></a>数据量太大也不适合二分查找</h3><p>原因二分查找依赖的数据结构，数组为了支持随机访问的特性，要求内存空间连续，对没存的要求比较严格。我们有1GB大小的数据，如果希望用数组来存储，那就需要1GB的连续内存空间。</p><p>“连续”的意思就是，即便有2GB的内存空间剩余但是，如果剩余的2GB的内存空间时不连续的，没有一块连续的1GB内存空间，那样照样无法申请一个1GB大小的数组。因为基于数组数据结构的原因，所以太大的数据用数组存储就比较吃力了，所以就不能使用二分查找了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找区间缩小为一半，直到找到要查找的元素，或者区间被缩小为0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易错的地方：</p><ul><li>循环退出条件</li><li>mid取值（求了两个数的平均值）</li><li>low和high的更新</li></ul><p>二分查找虽然性能优秀，但是应用场景也比较有限。底层必须依赖数组，并且还要求数据时有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据的插入，删除操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;15-二分查找-上-：如何用最省内存的方式实现快速查找功能&quot;&gt;&lt;a href=&quot;#15-二分查找-上-：如何用最省内存的方式实现快速查找功能&quot; class=&quot;headerlink&quot; title=&quot;[15]二分查找(上)：如何用最省内存的方式实现快速查找功能&quot;&gt;&lt;/a&gt;[15]二分查找(上)：如何用最省内存的方式实现快速查找功能&lt;/h1&gt;&lt;h2 id=&quot;二分查找-Binary-Search-open-book&quot;&gt;&lt;a href=&quot;#二分查找-Binary-Search-open-book&quot; class=&quot;headerlink&quot; title=&quot;二分查找(Binary Search) :open_book:&quot;&gt;&lt;/a&gt;二分查找(Binary Search) :open_book:&lt;/h2&gt;&lt;p&gt;Binary Search 算法，也称折半查找。二分查找的思想很简单-类似与小时候玩的猜数字游戏。&lt;/p&gt;
&lt;p&gt;一个人先确定一个数组，另一个随便猜一个数字(中间数)。确定数字的那个人只需要说大了还是小了就行。每说一次就能让可能存在这个数的区间减小一半，知道区间减小到只有一个数字即猜对了这个数。(最坏情况)&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="二分查找" scheme="https://soyanga.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>排序(下)</title>
    <link href="https://soyanga.github.io/2019/03/02/%E6%8E%92%E5%BA%8F(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/03/02/排序(下)/</id>
    <published>2019-03-02T15:54:52.000Z</published>
    <updated>2019-03-17T08:39:56.073Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="13-排序-下-线性排序-strawberry"><a href="#13-排序-下-线性排序-strawberry" class="headerlink" title="[13]排序(下)-线性排序:strawberry:"></a>[13]排序(下)-线性排序:strawberry:</h1><table><thead><tr><th>非基于比较的 线性排序</th><th>时间复杂度</th><th>适用场合</th></tr></thead><tbody><tr><td>桶排序</td><td>O(n)</td><td><strong>数据量大，数据存储在磁盘上，内存有限（数据范围不大）</strong></td></tr><tr><td>计数排序</td><td>O(n)</td><td><strong>计数排序只能用在数据范围不大的场景中</strong></td></tr><tr><td>基数排序</td><td>O(n)</td><td><strong>数据可以划分高低位，且每一位之间后递进关系，每一位范围不能大，因为每一位的稳定排序依赖桶排或者计数排序</strong></td></tr></tbody></table><a id="more"></a><p>桶排序，计数排序，基数排序都是线程排序。之所以可以做到线程的时间复杂度，主要原因是，这三个算法是基于<strong>非比较</strong> 的排序算法，都不设计元素之间的比较操作。</p><p><strong>这几种排序对要排序的数据要求很苛刻，我们重点要学习的是这三种排序的适用场景。</strong> </p><h1 id="思考题-thinking"><a href="#思考题-thinking" class="headerlink" title="思考题:thinking:"></a>思考题:thinking:</h1><p>如何根据年龄给100万用户排序？O(n)</p><h1 id="桶排序-Bucket-Sort-package"><a href="#桶排序-Bucket-Sort-package" class="headerlink" title="桶排序(Bucket Sort):package:"></a>桶排序(Bucket Sort):package:</h1><h2 id="核心思想-collision"><a href="#核心思想-collision" class="headerlink" title="核心思想:collision:"></a><strong>核心思想:collision:</strong></h2><p>将要排序的数据分到几个有序桶中，每个桶里的数据再单独进行排序<strong>。桶内排完序后，再把</strong>每个桶里的数据按照顺序依次取出**，组成的序列就是有序的了。</p><ul><li>将要排序数据分到<strong>有序桶中</strong> </li><li><strong>每个桶中数据进行排序</strong></li><li>桶内排完序后，再把<strong>每个桶里的数据按照顺序依次取出</strong>。</li></ul><h3 id="桶排序为什么是O-n-时间复杂度"><a href="#桶排序为什么是O-n-时间复杂度" class="headerlink" title="桶排序为什么是O(n)时间复杂度"></a><strong>桶排序为什么是O(n)时间复杂度</strong></h3><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\桶排序示例.png" alt="桶排序示例"></p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h3><p>排序的数据有n个，我们把他们均匀的划分到m个桶内，每个桶就有k=n/m个元素。每个桶内部使用快排，时间复杂度O(K<em>logk)。m个桶排序的时间复杂度就是O(m\</em>klogk),因为k = n/m,所以整个桶排序的时间复杂度就是O(n*log(n/m))。<strong>当桶的个数接近与数据个数n时，log(n/m)就是一个非常小的常量，这时候桶排序的时间复杂度接近O(n)。</strong></p><p><strong>但是</strong>以上能实现O(n)时间复杂度的<strong>前提是</strong></p><p><strong>一是：</strong> </p><blockquote><ul><li><strong>能将数据很容易的划分成n个桶，</strong></li><li><strong>桶与桶之间有着天然的大小顺序。</strong></li></ul></blockquote><p><strong>这样每个桶内的数据都排完序后，桶与桶之间的数据就不需要再进行排序了。</strong></p><p><strong>二是：</strong> </p><blockquote><ul><li><strong>数据再各个桶之间的分布是比较平均的。</strong></li></ul></blockquote><p>如果数据经过桶的划分之后，有些桶里的数据非常多，有些桶里的数据非常的少，很不平均，那通内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)排序算法了。</p><h2 id="适应场景-sun-with-face"><a href="#适应场景-sun-with-face" class="headerlink" title="适应场景:sun_with_face:"></a>适应场景:sun_with_face:</h2><p><strong>桶排序比较适合用在外部排序中。</strong> <strong><em>所谓的外部排序就是数据存储啊在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</em></strong> </p><h2 id="借助桶排序来处理问题：10G订单数据按照订单金额进行排序"><a href="#借助桶排序来处理问题：10G订单数据按照订单金额进行排序" class="headerlink" title="借助桶排序来处理问题：10G订单数据按照订单金额进行排序"></a>借助桶排序来处理问题：10G订单数据按照订单金额进行排序</h2><p>我们只有几百MB，没办法一次性把10G数据都加载到内存中。这时我们可以利用桶排序的思想来处理这个问题。</p><ol><li><p>我们可以先扫描一遍晚间，看订单金额所处于在金额范围，将订单分到固定个数的桶中</p><blockquote><p>假设我们得到订单金额的范围是<strong>最小是1元到最多是10多万元</strong>，我们根据订单金额将订单分到<strong>100个桶中</strong>去，第一个通我们存储1元~1000之内的定单，第二个桶中存储1001~2000元之内的订单以此类推。</p></blockquote></li><li><p>每个桶对应一个文件（文件有序号），并且按照金额范围大小顺序编号命名(00,01,02…,99).</p><blockquote><p>在理想情况下，如果订单金额从1到10万元之间均匀分布，那么订单会被均匀划分到100个文件中，每个小文件中存储大约100MB的订单数据，我们就可以将100个小文件依次存放到内存中用快排来进行排序，等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个文件中的订单数据，并将其写入一个大文件中，那么这个文件中存储的就是按照金额从小到达的订单数据了</p></blockquote></li></ol><h3 id="问题：订单金额很有可能并不是均匀分布在1-10万元的内"><a href="#问题：订单金额很有可能并不是均匀分布在1-10万元的内" class="headerlink" title="问题：订单金额很有可能并不是均匀分布在1~10万元的内"></a>问题：订单金额很有可能并不是均匀分布在1~10万元的内</h3><p><strong>递归式划分大文件，直到所有文件都可以被读取到内存中进行快排。</strong></p><p>所以10G订单数据是无法均匀地被划分到100个文件中的。有可能某个金额区间的数据特别多，划分之后对用的文件就会很大，没法一次性读取到内存中。</p><p>此时我们需要针对比较大的文件，继续对其进行划分，比如，订单金额咋子1元到1000元之间的比较多，我们就将这个区间继续划分你为10个区间，1元到100元，101到200元…</p><p>假如谋个区间内订单还是太多了，无法一次性读入到内存中，我们就继续划分，直到所有文件都能读入到内存中进行快排。</p><h1 id="计数排序-Counting-Sort-desktop-computer"><a href="#计数排序-Counting-Sort-desktop-computer" class="headerlink" title="计数排序(Counting Sort):desktop_computer:"></a>计数排序(Counting Sort):desktop_computer:</h1><h2 id="适用场景-sunny"><a href="#适用场景-sunny" class="headerlink" title="适用场景:sunny:"></a>适用场景:sunny:</h2><p>计数排序是桶排的一种特殊情况。<strong><em>当要排序的n个数据，所处的范围并不大的时候</em>，比如最大值是k,此时我们就可以把数据划分成k个桶，每个桶内的数据值都是相同的，省略到了桶内排序的时间。</strong> </p><h2 id="高考考生50万排名问题："><a href="#高考考生50万排名问题：" class="headerlink" title="高考考生50万排名问题："></a>高考考生50万排名问题：</h2><p>高考总成绩是900分，最小是0分，这个数据的范围很小，所以我们可以分成901个桶，桶中存储的是对哟个分数的人数。桶内考生的分数相同所以的并不需要再进行排序。我们只需要依次扫描完每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是O(n)。</p><h2 id="如何实现计数排序？"><a href="#如何实现计数排序？" class="headerlink" title="如何实现计数排序？"></a>如何实现计数排序？</h2><p>我们要实现稳定的计数排序不能单从某个数据对应个数进行对数据的分组。因为那样不能保证相等数据排序前后的相对前后位置不变，所以我们需要两个辅助数组。</p><h3 id="辅助数组C-的创建"><a href="#辅助数组C-的创建" class="headerlink" title="辅助数组C[]的创建"></a>辅助数组C[]的创建</h3><p>一个辅助数组下标表示的是分数，数组内容是小于等于当前下标（分数）的数据个数。</p><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\计数排序辅助数组C.jpg" alt="计数排序辅助数组C"></p><ul><li>排序细节</li></ul><p>我们从后到前依次扫描数组A，为什么从后向前是因为保证计数排序的稳定性。比如我们从后扫描遇到3时，我们可以从数组C中取出下标为3的值7，也就时说，到目前为止，包括这个3在内，分数小于等于3的考生有7个，也就是说3时数组R（排好序的数组）的第7个元素（也就是数组R中下标为6的为止）。当3放入到数组R中后，小于等于3的元素就只剩下了6个，所以相应的C[3]中存储的数值要减1，变成6。</p><p>依次类推，当我们扫描到第2个分数为3的考生的时候，就会把它放入数组R中的第6个元素的位置（也就是排序数组下标为5的位置）。当我们扫描完整个数组A后，数组R内的数据就是按照分数从小到大的有序排列了。</p><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\计数排序细节.jpg" alt="计数排序细节"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序，a是数组，n是数组的大小。假设数组存储的都是非负整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSorot</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找数组中数据的范围</span></span><br><span class="line">    <span class="keyword">int</span> max = a[o];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; a[i])&#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.创建辅助数组C[]</span></span><br><span class="line">    <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];<span class="comment">//申请一个计数数组，下标大小[0,max]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; i++)&#123;</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算每个元素的个数，放入C中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        c[a[i]]++;     <span class="comment">//拆解 c[下标为分数] 分数=a[i]  c[下标]：分数为下标数的个数++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依次累加  得到辅助数组C[]中存储的是小于等于该数的数据个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++)&#123;</span><br><span class="line">        c[i] = c[i-<span class="number">1</span>]+c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.排序数组的创建，排序之后的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//计算排序的关键步骤！！！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n- <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;  <span class="comment">//该分数对应放在排序数组的下标位置</span></span><br><span class="line">        r[index] = a[i];</span><br><span class="line">        c[a[i]]--;<span class="comment">//小于等于该分数的数据个数-1；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果拷贝给a数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>； i &lt; n; i++)&#123;</span><br><span class="line">        a[i] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序详解"><a href="#计数排序详解" class="headerlink" title="计数排序详解"></a>计数排序详解</h2><p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不使用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong> </p><p>关于将数据转化为能使用计数排序的方法如下：</p><ol><li>如果是分数就将分数化为整数。*10的倍数</li><li>如果是负数就将分数化为整数。+整数</li></ol><h1 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h1><p>假设我们要对10万个手机号码进行排序，希望将这10万个手机号码从小到大进行排序？</p><h2 id="对10万个手机号码进行排序"><a href="#对10万个手机号码进行排序" class="headerlink" title="对10万个手机号码进行排序"></a>对10万个手机号码进行排序</h2><p>问题主要特点：</p><ul><li>手机号有11位，假如当作整数来处理范围太大了。我们不能使用桶排，或者计数排序。</li><li>假设我们要比较两个手机号码的a,b的大小，如果在前面几位中，a手机号码已将比b手机号大了，那么后面的几位就不用看了。</li></ul><p>借助稳定排序算法，借助[11]节中举的订单金额时间排序例子，先按照最后一位来排序手机号，然后，再按照倒数地二位重新排序，以此类推，最后按照第一位重新排序。经过11次排序之后，手机号码就有序了。</p><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\基数排序.jpg" alt="基数排序"></p><p>我们每次进行的排序必须是稳定的，这样才不会影响后续位数的排列。</p><p>根据每一位来进行排序，我们可以用到桶排或者计数排序，他们时间复杂度是O(n)。如果要排序的数据位数有k位，那么我们就需要K次桶排序或者计数排序，总时间复杂度就是O(k*n)。当K不大时，比如手机号码的例子，k最大就是11.所以基数排序的时间复杂度就近似与O(n)。</p><h2 id="特殊例子：对字典中20万单词进行排序"><a href="#特殊例子：对字典中20万单词进行排序" class="headerlink" title="特殊例子：对字典中20万单词进行排序"></a><strong>特殊例子</strong>：对字典中20万单词进行排序</h2><ul><li>我们可以把所有单词补齐到相同长度，位数不够的可以在后面补”0”，</li><li>因为根据ASCII值，所有字母大于”0”,所以补”0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</li></ul><h2 id="适用场景-cat2"><a href="#适用场景-cat2" class="headerlink" title="适用场景:cat2:"></a>适用场景:cat2:</h2><p>基数排序对排序数据又要求<strong>，</strong></p><ul><li><strong>需要分隔出独立的”位”来进行比较，而且位之间有递进的关系</strong>，</li><li><em>如果a数据的高位比b数据大，那剩下的低位就不用比较了</em>。</li><li>除此之外<em>，每一位的数据范围不能太大了</em>，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。</li></ul><h1 id="解答-key"><a href="#解答-key" class="headerlink" title="解答:key:"></a>解答:key:</h1><p>给根据年龄100万用户排序</p><p>类似给50万考生排序，先找到数据的范围,例如最小1岁最大120岁。我们可以遍历100万用户，根据年龄将其划分到这120个桶里，然后依次顺序遍历这个120个桶中的元素。这样就可以得到按照年龄排序100万用户的数据了。</p><h1 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h1><p>桶排序，计数排序，基数排序3种排序对要排序的数据都有比较严苛的要求，应用的不是非常广泛。但是如果数据符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到O(n)。</p><p><strong>桶排序和计数排序的排序思想非常相似的，都是针对范围不大的数据，将数据划分为不同的桶来实现排序。</strong></p><p>基数排序要求数据可以划分成<strong>高低位</strong>，<strong>位于位之间有递进关系</strong>。比较两个数，我们只需要比较高位，高位相同的再比较低位。且<strong>每一位得到数据范围不能太大</strong>，因为基数排序算法<strong>需要借助桶排序或者计数排序来完成每一位的排序工作。</strong></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>对大小写字母进行排序，要求大写在前，小写在后。大小写字母内部不要求有序。</strong></p><p>==双指针法（前后指针)==  </p><blockquote><p>前指针从前向后找找到大写字母，后指针从后向前找找到小写字母。然后进行交换，直到两个指针相遇就停止，完成排序。</p></blockquote><p><strong>进阶其中在添加数字，要求数字在中间。</strong></p><p>==分类，两次双指针（前后指针）==</p><blockquote><p>先将数据非为小写字母和非小写字母进行排序，然后再对非小写字母进行数字和大写字母的双指针算法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;13-排序-下-线性排序-strawberry&quot;&gt;&lt;a href=&quot;#13-排序-下-线性排序-strawberry&quot; class=&quot;headerlink&quot; title=&quot;[13]排序(下)-线性排序:strawberry:&quot;&gt;&lt;/a&gt;[13]排序(下)-线性排序:strawberry:&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;非基于比较的 线性排序&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;适用场合&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;桶排序&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数据量大，数据存储在磁盘上，内存有限（数据范围不大）&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计数排序&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;计数排序只能用在数据范围不大的场景中&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基数排序&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数据可以划分高低位，且每一位之间后递进关系，每一位范围不能大，因为每一位的稳定排序依赖桶排或者计数排序&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="排序" scheme="https://soyanga.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序(中)</title>
    <link href="https://soyanga.github.io/2019/03/02/%E6%8E%92%E5%BA%8F(%E4%B8%AD)/"/>
    <id>https://soyanga.github.io/2019/03/02/排序(中)/</id>
    <published>2019-03-02T15:54:52.000Z</published>
    <updated>2019-03-17T08:55:30.627Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="12-排序-中-数据结构与算法之美-arrow-down-small"><a href="#12-排序-中-数据结构与算法之美-arrow-down-small" class="headerlink" title="[12]排序(中) -数据结构与算法之美:arrow_down_small:"></a>[12]排序(中) -数据结构与算法之美:arrow_down_small:</h1><table><thead><tr><th style="text-align:left">排序算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">归并</td><td>O(nlogn)</td></tr><tr><td style="text-align:left">快排</td><td>O(nlogn)</td></tr></tbody></table><p><strong>快排，归并排序</strong>：大规模的数据排序，比冒泡，插入，选择更加常用。—分治思想</p><a id="more"></a><h1 id="带着问题-grey-question"><a href="#带着问题-grey-question" class="headerlink" title="带着问题:grey_question:"></a>带着问题:grey_question:</h1><p>如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？</p><h2 id="归并排序-Merge-Sort-dog2"><a href="#归并排序-Merge-Sort-dog2" class="headerlink" title="归并排序(Merge Sort):dog2:"></a>归并排序(Merge Sort):dog2:</h2><p>归并排序核心思想：</p><ul><li>先把数组从中间<strong>分成前后两部分</strong></li><li>然后对前后两部分，<strong>分别排序</strong> </li><li>再将排好的两个部分<strong>合并</strong>在一起。</li></ul><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\归并排序算法图.png" alt="归并排序算法图"></p><p>利用的是<strong>分治思想</strong> ，大问题分解为小的子问题来解决。小的解决了，大的问题也就解决了。</p><p>分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong></p><ul><li><p><strong>递归实现拆分目标数组</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">mergr_sort(p...r) = merge(merge_sort(p..q),merge_sort(q_1...r))</span><br><span class="line">按照目标数组的中间节点差分整个数组，进行分别排序</span><br><span class="line"></span><br><span class="line">终止条件</span><br><span class="line">p &gt;= r 不用再继续分解   即拆解成的目标数组只剩一个元素</span><br></pre></td></tr></table></figure></li><li><p><strong>合并拆分并完成排序的数组—类似合并两个有序数组</strong> (<em>利用哨兵简化代码)</em></p><ul><li>开辟一个和合并完成后数组一样大的数组 —临时数组</li><li>比较有序数组首元素的大小，谁小就放到临时数组中，依次比较放入，直到其中有一个数组已经没有元素可以比较</li><li>然后将有元素的数组直接放到到临时数组后面</li><li>最后将临是数组中的元素考回需要合并的数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin1, <span class="keyword">int</span> end1, <span class="keyword">int</span> begin2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">//临时数组的其实位置</span></span><br><span class="line">    <span class="keyword">int</span> begin = begin1;  <span class="comment">//记住数组起始位置</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end2 - begin1 + <span class="number">1</span>]; <span class="comment">//开辟和合并后数组大小一样大的数组</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//以下操作类似合并两个有序数组</span></span><br><span class="line">    <span class="comment">//谁小就将谁放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt; a[begin2]) &#123;</span><br><span class="line">            temp[start++] = a[begin1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[start++] = a[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数组直接拷贝回临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">        temp[start++] = a[begin1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">        temp[start++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp数组中的元素拷贝回合并后的数组中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        a[begin + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>归并排序的整体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin1, <span class="keyword">int</span> end1, <span class="keyword">int</span> begin2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">//临时数组的其实位置</span></span><br><span class="line">    <span class="keyword">int</span> begin = begin1;  <span class="comment">//记住数组起始位置</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end2 - begin1 + <span class="number">1</span>]; <span class="comment">//开辟和合并后数组大小一样大的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下操作类似合并两个有序数组</span></span><br><span class="line">    <span class="comment">//谁小就将谁放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt; a[begin2]) &#123;</span><br><span class="line">            temp[start++] = a[begin1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[start++] = a[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数组直接拷贝回临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">        temp[start++] = a[begin1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">        temp[start++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp数组中的元素拷贝回合并后的数组中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        a[begin + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序性能分析："><a href="#归并排序性能分析：" class="headerlink" title="归并排序性能分析："></a>归并排序性能分析：</h3><h4 id="归并排序是一个稳定排序"><a href="#归并排序是一个稳定排序" class="headerlink" title="归并排序是一个稳定排序"></a>归并排序是一个稳定排序</h4><p>归并排序是一个稳定排序，<strong>稳定与否关键是在看merge()函数</strong>，也就是有两个有序子数组合并成一个有序数组那部分 。合并过程中，<em>把差分后要合并的两个数组中值相等的元素，先将拆分前下标靠前的元素先放入合并用的temp数组内即可</em>。这样就保证了值相同的元素。在合并前后的先后顺序不变，所以，<strong>归并排序是一个稳定的排序算法</strong>。                    </p><h4 id="归并排序的时间复杂度"><a href="#归并排序的时间复杂度" class="headerlink" title="归并排序的时间复杂度"></a>归并排序的时间复杂度</h4><p>我们可以从分治思想中的到启发，求解大问题，解决子问题即可。则我们定义求解问题时间是T(a),求解问题b、c的时间分别是T(b)和T(c)，那么我们就可以得到如下的递推关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(a) = T(b)+T(c)+k</span><br></pre></td></tr></table></figure><p>其中K等于将两个子问题b,c的结果合并成问题a的解果所消耗的时间。</p><p><strong>不仅递归求解问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong> </p><p>现在我们来求解归并排序的时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个有序子数组的时间复杂度是O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</span></span><br><span class="line">T(<span class="number">1</span>) = c ;n=<span class="number">1</span>时，即数组只剩下一个元素，只需要常量级的执行时间，所以表示为c。</span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n;  n&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>分解计算过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n</span><br><span class="line"> = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>)+n/<span class="number">2</span>) +n        = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n</span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n   = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n</span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n  = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n</span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure><p>我们可以得出T(n) = 2^kT(n/2^k)+kn,当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并并排序的时间复杂度是 O(nlogn)。</p><p>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的。</p><table><thead><tr><th>时间复杂度</th><th>大O标记法</th></tr></thead><tbody><tr><td>最好时间复杂度</td><td>O(nlogn)</td></tr><tr><td>平均时间复杂度</td><td>O(nlogn)</td></tr><tr><td>最坏时间复杂度</td><td>O(nlogn)</td></tr></tbody></table><h4 id="归并排序的空间复杂度"><a href="#归并排序的空间复杂度" class="headerlink" title="归并排序的空间复杂度"></a>归并排序的空间复杂度</h4><p><strong>归并排序是一个非原地排序！</strong>这是因为归并排序的合并函数。在合并两个有序数组为一个有序数组时，需要借助额外的储存空间。<strong>O（n）</strong></p><p>递归代码的空间复杂不能像时间复杂度那样累加。尽管每次合并操作都需要申请额外的内存空间，但是在合并完成后，临时开辟的内存空间被释放掉了，<strong>在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，所以空间复杂度是O(n).</strong></p><h2 id="快速排序-QuickSort-arrow-heading-up"><a href="#快速排序-QuickSort-arrow-heading-up" class="headerlink" title="快速排序(QuickSort):arrow_heading_up:"></a>快速排序(QuickSort):arrow_heading_up:</h2><p>快排核心思想：</p><ul><li>先从区间数组中选择一个数据作为分区点</li><li>遍历区间数组中的元素，将小于分区点的元素放在分区点左边，大于分区点的元素放在分区点右边。经过这一个步骤后，数组就被发分为了3部分，左边 p 到 q-1 之间都是小于 pivot的 ，中间 pivot，后面q+1到r之间是大于 pivot 的（排序并分区）</li><li>根据分治，递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和小标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</li></ul><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\快排分区.png" alt="快排分区"></p><p>递归过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-<span class="number">1</span>) + quick_sort(q+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure><p>递归公式-&gt;递归代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排递归函数，begin,end为下标 div为分区节点，下一次分区就不包含此分区节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> div = partition(a, begin, end);</span><br><span class="line">    quickSortInternally(a, begin, div - <span class="number">1</span>);</span><br><span class="line">    quickSortInternally(a, div + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序中有一个merge()合并方法，我们这里有一个partition()分区函数。对数组进行顺序调整且对数组进行进一步分区处理,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[end];</span><br><span class="line">    <span class="keyword">int</span> i = begin;      <span class="comment">//i当作“已排好序节点”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pivot) &#123; <span class="comment">//比分区节点小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;   <span class="comment">//有序性区无元素，或者已经有序</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(a, i, j); <span class="comment">//将无序区的元素交换到有序区后面，有序区+1，无序区-1</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, i, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理有点类似选择排序。[p-r-1]我们通过下标 i把区间分为两个部分，[p-i]都小于pivot 我们将它取名为”已处理区间”。[i~r-1]都是”未处理区间“。我们每次都从未处理区间中取出一个元素A[j]，与pivot比较，如果小于pivot，则将加入到已处理区间的尾部，也就是A[i]位置，j++,i++。反之则只有j++。</p><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\快排分区排序原理图.png" alt="快排分区排序原理图"></p><p>因为分区过程涉及交换操作，交换过程中只对比大小，无法保证相同元素的先后顺序。所以快速🥧排序是一个不稳定算法。</p><h3 id="快排性能分析"><a href="#快排性能分析" class="headerlink" title="快排性能分析"></a>快排性能分析</h3><h4 id="快排稳定性"><a href="#快排稳定性" class="headerlink" title="快排稳定性"></a>快排稳定性</h4><p>快拍是一个不稳定算法</p><h4 id="快排的空间复杂度"><a href="#快排的空间复杂度" class="headerlink" title="快排的空间复杂度"></a>快排的空间复杂度</h4><p>快排是一个原地排序，在原数组内进行简单交换。</p><h4 id="快排时间复杂度"><a href="#快排时间复杂度" class="headerlink" title="快排时间复杂度"></a>快排时间复杂度</h4><p>快排也是使用递归实现的分治思想，对于递归代码的时间复杂度，我们之前总结的公式在这里依旧适用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(<span class="number">1</span>) = C；   n=<span class="number">1</span> 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n； n&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是归并排序是从中间开始划分区间，而快排划分区间的是利用选取一个值，假如选取的值是目标数组中最大元素，或者最小元素。则会导致每次划分的区间言严重不均等。假如每次划分区间都取到了这种极端值，则我们要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n/2个元素。这种情况下，快排的时间复杂度就从O(nlogn)退化成了O(n^2)。</p><p>利用递归树对快排的时间复杂度进行分析</p><p>在大部分情况下时间复杂度都是O(nlogn)，只有在极端情况下，才会退化到 O(n2)。</p><table><thead><tr><th>时间复杂度</th><th>对应的原始数组</th></tr></thead><tbody><tr><td>最好时间复杂度O(nlogn)</td><td>每次挑选的分区值都是大小最中间的那个值</td></tr><tr><td>平均时间复杂度O(nlogn)</td><td></td></tr><tr><td>最坏时间复杂度O(n^2)</td><td>每次挑选的分区值都是极端值-最大或最小值</td></tr></tbody></table><p>合理选择区间值可以避免出现最坏情况。</p><h1 id="解答开始问题-key"><a href="#解答开始问题-key" class="headerlink" title="解答开始问题:key:"></a>解答开始问题:key:</h1><p>快排的核心思想就是<strong>分治</strong>和<strong>分区</strong>.我们可以利用分区的思想；来解答开始的问题：O(n)时间复杂度内来求无序数组中的第K大元素。比如，4,2,5,12,3这样一组数据，第3大元素就是4。</p><p>我们区间选择完后就分为3部分。</p><p>如果p+1=k，那么A[p]就是要求解的元素，如果k&gt;p+1,说明第K大元素出现A[p+1…n-1]区间，我们再按照递归思路在A[p+1…n-1]这个区间内进行查找。同理，如果k&lt;p+1,那我们就在A[0…p-1]区间查找。</p><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\O(n" alt="O(n)求解第K大元素">求解第K大元素.png)</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>第一次分区查找，我们需要对大小为n的数组执行分区操作，需要遍历n个元素。第二次分区查找，我们只需要对n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数为，n/2,n/4,n/8,n/16……直到区间缩小为1。</p><p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于2n-1。所以，上述的解题思路的时间复杂度就是O(n)。</p><h1 id="思考：-thinking"><a href="#思考：-thinking" class="headerlink" title="思考：:thinking:"></a>思考：:thinking:</h1><p>现在你有 10 个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</p><h2 id="快排的优化"><a href="#快排的优化" class="headerlink" title="快排的优化"></a>快排的优化</h2><ul><li><p>分组不平衡–导致快排递归深度增加</p><ul><li><p>排序接近有序（基准值划分的两个子数组严重不均衡，此分层下来的结果近乎于n层，此时快排退化为复杂度为O(n^2）排序算法</p><blockquote><p>解决：随机数/三数取中法，让这种出现极端值情况降低</p></blockquote></li><li><p>当待排序集合包含大量的重复元素，由于与基准值相等的元素个数过多，导致数组长度不均衡，此时分层下来的结果几乎n层，快排退化为O(n^2)。  </p><blockquote><p>解决：二路快排    基准值-v    将待排序数组分为2部分  大于或或者小于</p><p>​    将大于和小于v的元素放在数组的两端,i索引不断向后扫描，当i的元素小于v时，i++;j索引不断向前扫描，当j的元素大于v时，j–;当i碰到一个&gt;=v的元素时以及当j碰到一个&lt;=v的元素时，交换i和j的元素，i++,j— 。  </p><p>即保证等于基准值的重复元素被均分到两边 一定程度上使得分组平均，递归深度降低</p></blockquote></li></ul></li></ul><p>  ​    二路快排图解</p><p>  <img src="/2019/03/02/排序(中)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552803918895.png" alt="1552803918895"></p><p>  ​    保证等于基准值的重复元素被均分到两边 一定程度上使得分组平均，递归深度降低</p><p>  <img src="/2019/03/02/排序(中)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552811349512.png" alt="1552811349512"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决：数据重复的快排---二路归并快排</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     数组a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  左下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 基准值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>) ((Math.random() * (right - left + <span class="number">1</span>)) + left);</span><br><span class="line">    swap(a, right, randomIndex);</span><br><span class="line">    <span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">int</span> v = a[right];</span><br><span class="line">    <span class="comment">//a[left,i-1]   &lt; v</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="comment">//a[j+1,right] &gt;v</span></span><br><span class="line">    <span class="keyword">int</span> j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//双指针前指针向后扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right &amp;&amp; a[i] &lt; v) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left &amp;&amp; a[j] &gt; v) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, i, right);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>二路快排优化- - - - -三路快排  &lt;  =  &gt;</strong></p></li><li><p><strong>三路快排图解</strong></p><p><img src="/2019/03/02/排序(中)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552804075550.png" alt="1552804075550"></p><p>将大量等于基准值的部分取出来，放到排序数组的中间，下一次进行排序时只需要排序不等于基准值的区域即可</p><p>大大减少排序次数，减少树的深度，又保持了数组的平衡。</p><p><strong>代码实现：</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//*********************快排优化之中级重复数据优化--三路快排</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortOP3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">&gt;  quickSortInternallyOP3(a, begin, end);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternallyOP3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">&gt;  <span class="keyword">if</span> (end - begin &lt; <span class="number">15</span>) &#123;   <span class="comment">//少量数据使用插排</span></span><br><span class="line">&gt;      insertSort(a, begin, end);</span><br><span class="line">&gt;      <span class="keyword">return</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  <span class="keyword">int</span>[] divs = partition3(a, begin, end);</span><br><span class="line">&gt;  <span class="keyword">int</span> div1 = divs[<span class="number">0</span>];</span><br><span class="line">&gt;  <span class="keyword">int</span> div2 = divs[<span class="number">1</span>];</span><br><span class="line">&gt;  quickSortInternallyOP3(a, begin, div1 - <span class="number">1</span>);</span><br><span class="line">&gt;  quickSortInternallyOP3(a, div2 + <span class="number">1</span>, end);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition3(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">&gt;  <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>) (Math.random() * (right - left + <span class="number">1</span>) + left);</span><br><span class="line">&gt;  swap(a, randomIndex, left);</span><br><span class="line">&gt;  <span class="keyword">int</span> v = a[left];</span><br><span class="line">&gt;  <span class="keyword">int</span>[] divs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">&gt;  <span class="comment">//a[left+1....lt] &lt; v</span></span><br><span class="line">&gt;  <span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">&gt;  <span class="keyword">int</span> lt = left;</span><br><span class="line">&gt;  <span class="comment">//a[gt...right]  &lt; v</span></span><br><span class="line">&gt;  <span class="keyword">int</span> gt = right + <span class="number">1</span>;   <span class="comment">// &lt; v的区间</span></span><br><span class="line">&gt;  <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">&gt;      <span class="keyword">if</span> (a[i] &lt; v) &#123;</span><br><span class="line">&gt;          swap(a, lt + <span class="number">1</span>, i);</span><br><span class="line">&gt;          lt++;</span><br><span class="line">&gt;          i++;</span><br><span class="line">&gt;      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; v) &#123;</span><br><span class="line">&gt;          swap(a, gt - <span class="number">1</span>, i);</span><br><span class="line">&gt;          gt--;</span><br><span class="line">&gt;      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;          i++;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  swap(a, left, lt);</span><br><span class="line">&gt;  divs[<span class="number">0</span>] = lt;</span><br><span class="line">&gt;  divs[<span class="number">1</span>] = gt;</span><br><span class="line">&gt;  <span class="keyword">return</span> divs;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>影响快排的性能的另一个原因是快排的递归深度，当元素递归区间内的元素数目不大时，利用快排排序则会增加递归深度，增加排序的时间复杂度，何不选用一种处理少量数据比较快速的排序算法–––-插排</p><blockquote><p>当递归区间比较小时，直接引入插排进行排序，减少递归深度</p></blockquote></li></ul><p>​    <strong>快排优化插排</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((end - begin + <span class="number">1</span>) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = a[i];  <span class="comment">//要插入适当位置的值</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>; <span class="comment">//有序区</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;12-排序-中-数据结构与算法之美-arrow-down-small&quot;&gt;&lt;a href=&quot;#12-排序-中-数据结构与算法之美-arrow-down-small&quot; class=&quot;headerlink&quot; title=&quot;[12]排序(中) -数据结构与算法之美:arrow_down_small:&quot;&gt;&lt;/a&gt;[12]排序(中) -数据结构与算法之美:arrow_down_small:&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;排序算法&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;归并&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;快排&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;快排，归并排序&lt;/strong&gt;：大规模的数据排序，比冒泡，插入，选择更加常用。—分治思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="排序" scheme="https://soyanga.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序(上)</title>
    <link href="https://soyanga.github.io/2019/02/27/%E6%8E%92%E5%BA%8F(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/02/27/排序(上)/</id>
    <published>2019-02-27T14:42:18.000Z</published>
    <updated>2019-02-27T14:44:54.124Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="排序章节学习总规划"><a href="#排序章节学习总规划" class="headerlink" title="排序章节学习总规划"></a>排序章节学习总规划</h1><table><thead><tr><th>章节</th><th>排序算法</th><th>时间复杂度</th><th>是否基于比较</th></tr></thead><tbody><tr><td>11</td><td>冒泡，插入，选择</td><td>O(n^2)</td><td>:heavy_check_mark:</td></tr><tr><td>12</td><td>快排，归并</td><td>O(nlogn)</td><td>:heavy_check_mark:</td></tr><tr><td>13</td><td>桶，计数，基数</td><td>O(n)</td><td>:heavy_multiplication_x:</td></tr></tbody></table><a id="more"></a><h1 id="带着问题​-grey-question"><a href="#带着问题​-grey-question" class="headerlink" title="带着问题​ :grey_question:"></a>带着问题​ :grey_question:</h1><p>插排和冒泡排序时间复杂度都是O(n^2)，在实际开发中，为什么更倾向于使用插入排序算法而不是冒泡排序算法？</p><h1 id="11-排序-上-数据结构算法之美-happy"><a href="#11-排序-上-数据结构算法之美-happy" class="headerlink" title="[11] 排序(上) -数据结构算法之美 :happy:"></a>[11] 排序(上) -数据结构算法之美 :happy:</h1><h2 id="分析排序算法的三个方面-thumbsup"><a href="#分析排序算法的三个方面-thumbsup" class="headerlink" title="分析排序算法的三个方面 :thumbsup:"></a>分析排序算法的三个方面 :thumbsup:</h2><h3 id="排序算法的执行效率-1-one"><a href="#排序算法的执行效率-1-one" class="headerlink" title="排序算法的执行效率-1:one:"></a>排序算法的执行效率-1:one:</h3><h4 id="1-最好情况，最坏情况，平均时间复杂度"><a href="#1-最好情况，最坏情况，平均时间复杂度" class="headerlink" title="1.最好情况，最坏情况，平均时间复杂度"></a>1.最好情况，最坏情况，平均时间复杂度</h4><p>我们分析排序算法的时间复杂度的同时也要分析==<strong>最好，最坏时间复杂度对应的要排序的原始数据</strong>==  是什么样的。<strong>（数据已经有序，数据接近有序，数据完全无序，数据逆序）</strong></p><h4 id="2-时间复杂度的系数，常数，低阶"><a href="#2-时间复杂度的系数，常数，低阶" class="headerlink" title="2.时间复杂度的系数，常数，低阶"></a>2.时间复杂度的系数，常数，低阶</h4><p>时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势往往会忽略系数，常数，低阶项。但是实际开发中可能排序数据规模上不一定会规模很大。所以对于同一阶次时间复杂度算法性能对比的时候，我们就要把系数，常数，低阶考虑进来。</p><h4 id="3-比较次数-和-交换-或移动-次数"><a href="#3-比较次数-和-交换-或移动-次数" class="headerlink" title="3.比较次数 和 交换(或移动)次数"></a>3.比较次数 和 交换(或移动)次数</h4><p>基于比较的排序算法，会涉及两种操作，一种是元素比较大小，另一种是元素交换或者移动。所以，我们分析排序算法执行效率的时候，应该把比较次数和交换（或者移动）次数也考虑进去。</p><h3 id="排序算法的内存消耗-2-two"><a href="#排序算法的内存消耗-2-two" class="headerlink" title="排序算法的内存消耗-2:two:"></a>排序算法的内存消耗-2:two:</h3><p>算法的内存消耗：可以通过空间复杂度来衡量。</p><p>针对排序算法的空间复杂度，我们还引入一个新概念，<strong>原地排序（Sorted in place）</strong>:特指空间复杂度是O(1)的排序算法。</p><p><strong>冒泡，插排，选择排序都是原地排序</strong>。</p><h3 id="排序算法的稳定性-3-three"><a href="#排序算法的稳定性-3-three" class="headerlink" title="排序算法的稳定性-3:three:"></a>排序算法的稳定性-3:three:</h3><p>==<strong>稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</strong>==</p><p><strong>例1： </strong> </p><p>一组数据 2，9，3，4，8，3按照升序排列，则排完是2，3，3，4，8，9。排序后两个3的先后次序不变。</p><p><strong>例2：</strong> </p><p>交易订单中”订单”排序。订单中有两个属性，一个下单时间，另一个是订单金额。如果说我们现在有10万条订单数据·。我们希望</p><ul><li>按照订单金额从小到大对订单数据进行排序</li><li>对于相同的订单，我们希望按照下单时间从早到晚有序</li></ul><p>对于这样一个排序需求我们应该如何去做呢？</p><p>先对整个<strong>订单数据按照下单时间进行升序排列(可以不是使用稳定排序)</strong>，然后再整体使用<strong>稳定排序算法，按订单金额重新排序</strong>即可。</p><p><strong>分析：</strong> 稳定排序算法可以保持金额相同的对象，在排序之后前后顺序不变。第一次排序之后，所有订单按照下单时间从早到晚就有序了。<strong>第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</strong> </p><h2 id="冒泡排序-Bubble-Sort-right-anger-bubble"><a href="#冒泡排序-Bubble-Sort-right-anger-bubble" class="headerlink" title="冒泡排序(Bubble Sort) :right_anger_bubble:"></a>冒泡排序(Bubble Sort) :right_anger_bubble:</h2><p>冒泡排序只会操作<em>相邻的两个数据</em>。每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系的要求。如果不满足就让他俩互换。<strong>一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作</strong> </p><p><strong>优化：</strong>当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后面的冒泡操作了。</p><p><strong>优化前：</strong> </p><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\冒泡排序算法图.jpg" alt="冒泡排序算法图"></p><p><strong>优化后：</strong> </p><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\冒泡排序算法图优化.jpg" alt="冒泡排序算法图优化"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123; <span class="comment">//如果只有元素，不需要排序</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">//提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; n-i-<span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//表示有数据交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//没有数据交换，提前退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h3><ul><li><p><strong>冒泡排序是原地排序算法</strong></p><p>冒泡排序冒泡过程<strong>只涉及相邻的数据交换操作</strong>，是原地排序算法，只需要常量级临时空间。空间复杂度是O(1)，是一个原地排序算法。</p></li><li><p><strong>冒泡排序是稳定排序算法</strong></p><p>交换时值改变了两个元素的前后顺序。为了保证冒泡排序算法的稳定性<em>，我们在比较时规定当有相邻元素大小相同时，我们不做交换</em>，<strong>相同大小的数据在排序前后不会改变顺序</strong>，所以冒泡排序是稳定的排序算法。</p></li><li><p>冒泡排序时间复杂度。最好，最坏，平均</p><p>| 时间复杂度             | 对应原始数据                     |<br>| ———————- | ——————————– |<br>| 最好时间复杂度：O(n)   | 1,2,3,4,5,6 从头到尾遍历一遍数组 |<br>| 最坏时间复杂度：O(n^2) | 6,5,4,3,2,1                      |<br>| 平均时间复杂度：O(n^2) | 数据的有序度的平均水平           |</p><p>平均时间复杂度运用概率论的方法难以计算，引入一个<strong>有序度</strong>的概念</p></li></ul><p>​    <strong>有序度：</strong> 是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表式就是</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 有序元素对：a[i] &lt;= a[j],如果i&lt;j</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​    <strong>满序度：</strong>完全有序的序列，的有序对数</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 满序度:排序完成后终态有序度为   n*(n-<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​    <strong>逆序度：数组中无序逆序关系得元素对的个数。</strong> </p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 逆序度对：a[i] &gt; a[j],如果i&lt;j</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​                                                    <strong>逆序度 = 满序度-有序度</strong> </p><p>​    拿之前的那个例子来说，数组初始状态是4，5，6，3，2，1。其中有序对有(4,5)(4,6)(5,6)</p><p>​    所以有序度是3。n=6,所以排序完成之后终态满有序度为n*(n-1)/2=15。</p><p>​    <img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\有序度规律.jpg" alt="有序度规律"></p><p>冒泡排序包含的<strong>两个原子操作，比较</strong>和<strong>交换</strong>。每冒泡（交换）一次，有序度就加1，不管算法怎么改进交换次数总是确定的。即为<strong>逆序度，也就是n*(n-1)/2-初始有序度。</strong>在这个例子中15-3 = 12则要进行12次交换操作。</p><p>对于包含n个数据的冒泡排序平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所所以要进行 n<em>(n-1)/2 次交换。最好情况下，初始状态的有序度是 n</em>(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，<strong>比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。</strong> </p><h2 id="插入排序-Insertion-Sort-diamond-shape-with-a-dot-inside"><a href="#插入排序-Insertion-Sort-diamond-shape-with-a-dot-inside" class="headerlink" title="插入排序(Insertion Sort):diamond_shape_with_a_dot_inside:"></a>插入排序(Insertion Sort):diamond_shape_with_a_dot_inside:</h2><p>将数组中的数据分为两个区间，已<strong>排序区间和未排序区间</strong>。<strong>初始已排序区间只有一个元素，就是数组的第一个元素。</strong>==插入算法的核心思想是<strong>取未排序区间中的元素。在已排序区间中找到合适的插入位置将其插入，并确保已排序区间数据一直有序</strong>。== 重复这个过程，<strong>直到未排序区间中元素为空，则排序就完成了。</strong> </p><p>插入排序也包含<strong>两种操作，元素的比较，元素的移动</strong>。当我们需要将一个数据a插入到已排序区间时，需要拿<strong>a与已排序区间的元素依次比较大小</strong>，<strong>找到合适的插入位置</strong>。找到合适的插入位置后，我们还需要将<strong>插入点之后的元素统一往后移动一位，腾出空间给元素插入</strong>。</p><p>对于不同的查找插入点方法（从头到尾，从尾到头）,元素的<strong>比较次数是有区别的</strong> 。但是对于一个给定的初始序列，<strong>移动操作的次数总是固定的，就等于逆序度</strong>。</p><blockquote><p>初始有序度为5，满序度为n*(n-1)/2=15,逆序度为10，插入排序一定数据总和也等于10 =3+3+4</p></blockquote><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\插排算法图.jpg" alt="插排排序图"></p><p><strong>代码入下：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = a[i]; <span class="comment">//记录要插入的元素</span></span><br><span class="line">        <span class="keyword">int</span> j = i-<span class="number">1</span>; <span class="comment">//已排序区</span></span><br><span class="line">        <span class="comment">//查找插入位置</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; value)&#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];<span class="comment">//数据移动</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = value; <span class="comment">//将要插入的位置插入合适的位置，有序区数量+1，无序区数量-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序算法分析"><a href="#插入排序算法分析" class="headerlink" title="插入排序算法分析"></a>插入排序算法分析</h3><ul><li><p><strong>插入排序是原地排序</strong></p><p>不需要额外的空间，空间复杂度O(1)</p></li><li><p><strong>插入排序是稳定排序</strong> </p><p>在插入排序中，对于值相同的元素，我们规定<strong>将后面的出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</strong></p></li><li><p><strong>插入排序的时间复杂度</strong></p><p>| 时间复杂度             | 对应原始数据                          |<br>| ———————- | ————————————- |<br>| 最好时间复杂度：O(n)   | 1,2,3,4,5,6 从头到尾遍历一遍数组      |<br>| 最坏时间复杂度：O(n^2) | 6,5,4,3,2,1                           |<br>| 平均时间复杂度：O(n^2) | 在数组中插入一个数据O(n)，循环执行n次 |</p></li></ul><p>数组中插入一个元素时间复杂度O(n):（1+2+3+4+…n)/n = O(n)</p><h2 id="选择排序-Selection-Sort-aquarius"><a href="#选择排序-Selection-Sort-aquarius" class="headerlink" title="选择排序(Selection Sort):aquarius:"></a>选择排序(Selection Sort):aquarius:</h2><p>选择排序与插排类似，也分为<strong>排序区和未排序区</strong>。但是选择排序每次会==<strong>从未排序区间中找到最小的元素，将其放到已经排好序的末尾。</strong>== </p><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\选择排序算法图.jpg" alt="选择排序算法图"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fot(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minindex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[minindex])&#123;</span><br><span class="line">                 minindex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[minindex];</span><br><span class="line">            a[minindex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序算法分析"><a href="#选择排序算法分析" class="headerlink" title="选择排序算法分析"></a>选择排序算法分析</h3><ul><li><p><strong>选择排序是原地排序</strong></p><p>不需要额外的空间，空间复杂度O(1)</p></li><li><p><strong>选择排序==不== 是一种稳定排序</strong></p><p>从图中可以看出，排序过程中将最小元素和最后一位交换位置，则会导致最后一位元素可能会移动到和它值相同的元素的前面，波坏了稳定性</p></li><li><p><strong>选择排序时间复杂度</strong></p><p>| 时间复杂度             | 对应原始数据                                   |<br>| ———————- | ———————————————- |<br>| 最好时间复杂度：O(n^2) | 无论原始数据如何，时间复杂度都是O(n^2)         |<br>| 最坏时间复杂度：O(n^2) | 原因是：查找无序区间的最小值总得遍历一遍无序区 |<br>| 平均时间复杂度：O(n^2) |                                                |</p></li></ul><p>逊色冒泡，插入排序。</p><h1 id="解答开始的问题-key"><a href="#解答开始的问题-key" class="headerlink" title="解答开始的问题:key:"></a>解答开始的问题:key:</h1><p>我们来看开篇的问题：插排和冒泡排序时间复杂度都是O(n^2)，在实际开发中，为什么更倾向于使用插入排序算法而不是冒泡排序算法？</p><p><strong>我们分析了冒泡排序和插入排序，不管如何优化，元素交换次数是一个都定值，即原始数据的无序度</strong></p><p>但是从代码实现上来看，==<strong>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序有要3个赋值操作，而插入排序只需要1个赋值操作。</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们把执行一个赋值语句的时间粗略记为单位时间（unit_time）,然后分别用冒泡排序和插入排序对同一个逆序度为k的数组进行排序，需要进行k次交换操作。冒泡排序，每次需要进行3条赋值语句，所以交换操作总耗时就是==3*k== 单位时间，而插入排序中数据移动操作只需要==k== 个单位时间。</strong></p><p>虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n^2),但是我们希望把性能优化到极致，所以我们首选插入排序。插入排序还可以进行进一步优化。比如==<strong>希尔排序</strong>== </p><h1 id="小结-package"><a href="#小结-package" class="headerlink" title="小结:package:"></a>小结:package:</h1><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\小结.jpg" alt="小结"></p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;排序章节学习总规划&quot;&gt;&lt;a href=&quot;#排序章节学习总规划&quot; class=&quot;headerlink&quot; title=&quot;排序章节学习总规划&quot;&gt;&lt;/a&gt;排序章节学习总规划&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;章节&lt;/th&gt;
&lt;th&gt;排序算法&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;是否基于比较&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;冒泡，插入，选择&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;:heavy_check_mark:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;快排，归并&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;:heavy_check_mark:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;桶，计数，基数&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;:heavy_multiplication_x:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="排序" scheme="https://soyanga.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度分析(下)</title>
    <link href="https://soyanga.github.io/2019/02/26/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8B/"/>
    <id>https://soyanga.github.io/2019/02/26/时间复杂度分析-下/</id>
    <published>2019-02-26T14:43:36.000Z</published>
    <updated>2019-02-27T14:44:20.771Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度</h1><p>应用场景主键增加：</p><h2 id="最好时间复杂度："><a href="#最好时间复杂度：" class="headerlink" title="最好时间复杂度："></a>最好时间复杂度：</h2><blockquote><p>在最理想的情况下，执行这段代码的时间复杂度。</p></blockquote><h2 id="最坏时间复杂度："><a href="#最坏时间复杂度：" class="headerlink" title="最坏时间复杂度："></a>最坏时间复杂度：</h2><blockquote><p>在最糟糕的情况下，执行这段代码的时间复杂度</p></blockquote><h2 id="平均时间复杂度："><a href="#平均时间复杂度：" class="headerlink" title="平均时间复杂度："></a>平均时间复杂度：</h2><blockquote><p>使用概率论知识计算每一个情况出现的概率这个值就是概率论中的加权平均值，也称作期望值，所以平均时间复杂度的全称应该是  <strong>加权平均时间复杂度</strong>或者 <strong>期望时间复杂度。</strong></p></blockquote><h2 id="均摊时间复杂度：平均时间复杂度的特殊情况"><a href="#均摊时间复杂度：平均时间复杂度的特殊情况" class="headerlink" title="均摊时间复杂度：平均时间复杂度的特殊情况"></a>均摊时间复杂度：平均时间复杂度的特殊情况</h2><p>均摊时间复杂度就是一种特殊的平均时间复杂度</p><a id="more"></a><blockquote><p>通过摊还分析：对一个数据结构进行一组连续操作中，大部分情况下时间复杂度有都很低，只有个别情况下时间复杂度比较高而且这个操作之间存在前后连贯的时序问题，<strong>这个时候，我们就可以将这组操作放在一块分析，看能否能将较高时间复杂度的那次操作的耗时，平摊到其他时间复杂度比较低的操作上。</strong>而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间时间复杂度就等于最好时间复杂度。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; </span><br><span class="line"><span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往数组中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (i &gt;= len) &#123; <span class="comment">// 数组空间不够了</span></span><br><span class="line">     <span class="comment">// 重新申请一个 2 倍大小的数组空间</span></span><br><span class="line">     <span class="keyword">int</span> new_array[] = <span class="keyword">new</span> <span class="keyword">int</span>[len*<span class="number">2</span>];</span><br><span class="line">     <span class="comment">// 把原来 array 数组中的数据依次 copy 到 new_array</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = <span class="built_in">array</span>[j];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// new_array 复制给 array，array 现在大小就是 2 倍 len 了</span></span><br><span class="line">     <span class="built_in">array</span> = new_array;</span><br><span class="line">     len = <span class="number">2</span> * len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 将 element 放到下标为 i 的位置，下标 i 加 1</span></span><br><span class="line">   <span class="built_in">array</span>[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析：</strong></p><blockquote><p>最好时间复杂度分析：O(1)：没有扩容存储数据的的时候</p><p>最坏时间复杂度分析：O(n)：扩容存储数据的时候</p><p>平均时间复杂度分析：归为一类分析其中一种即可</p></blockquote><blockquote><p>均摊时间复杂度分析：O(1)(为扩容)、 O(n)（扩容时） 均摊后O(1)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度&quot;&gt;&lt;a href=&quot;#复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度&quot;&gt;&lt;/a&gt;复杂度分析（下）：浅析、最坏、平均、均摊时间复杂度&lt;/h1&gt;&lt;p&gt;应用场景主键增加：&lt;/p&gt;
&lt;h2 id=&quot;最好时间复杂度：&quot;&gt;&lt;a href=&quot;#最好时间复杂度：&quot; class=&quot;headerlink&quot; title=&quot;最好时间复杂度：&quot;&gt;&lt;/a&gt;最好时间复杂度：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在最理想的情况下，执行这段代码的时间复杂度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最坏时间复杂度：&quot;&gt;&lt;a href=&quot;#最坏时间复杂度：&quot; class=&quot;headerlink&quot; title=&quot;最坏时间复杂度：&quot;&gt;&lt;/a&gt;最坏时间复杂度：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在最糟糕的情况下，执行这段代码的时间复杂度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;平均时间复杂度：&quot;&gt;&lt;a href=&quot;#平均时间复杂度：&quot; class=&quot;headerlink&quot; title=&quot;平均时间复杂度：&quot;&gt;&lt;/a&gt;平均时间复杂度：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用概率论知识计算每一个情况出现的概率这个值就是概率论中的加权平均值，也称作期望值，所以平均时间复杂度的全称应该是  &lt;strong&gt;加权平均时间复杂度&lt;/strong&gt;或者 &lt;strong&gt;期望时间复杂度。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;均摊时间复杂度：平均时间复杂度的特殊情况&quot;&gt;&lt;a href=&quot;#均摊时间复杂度：平均时间复杂度的特殊情况&quot; class=&quot;headerlink&quot; title=&quot;均摊时间复杂度：平均时间复杂度的特殊情况&quot;&gt;&lt;/a&gt;均摊时间复杂度：平均时间复杂度的特殊情况&lt;/h2&gt;&lt;p&gt;均摊时间复杂度就是一种特殊的平均时间复杂度&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="时间复杂度" scheme="https://soyanga.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度分析(上)</title>
    <link href="https://soyanga.github.io/2019/02/26/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-%E4%B8%8A/"/>
    <id>https://soyanga.github.io/2019/02/26/时间复杂度分析-上/</id>
    <published>2019-02-26T14:43:16.000Z</published>
    <updated>2019-02-27T14:44:16.306Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h1 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h1><h2 id="1-O-1-常量阶时间复杂度"><a href="#1-O-1-常量阶时间复杂度" class="headerlink" title="1.O(1):常量阶时间复杂度"></a><strong>1.O(1):常量阶时间复杂度</strong></h2><p>算法中存在循环语句，递归语句，时间复杂度不会随着n的增加而增加。</p><h2 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2.O(logn)、O(nlogn):"></a><strong>2.O(logn)、O(nlogn):</strong></h2><p>对数阶时间复杂度<br>$$<br>判断循环条件不满足时，将变量的变化的过程用函数表示，表示出来的公式是一个\logx_n判断变化了多少此即可。<br>$$</p><p>$$<br>即使\log_2 n,\log_3n,\log_4n——&gt;都是\log_n对数之间可以进行转换。为什么，可使用O(logn)表示呢，因为如下：<br>$$</p><p>$$<br>\log_3n= \log_32 <em> \log_2n =O(C</em>\log_2n) 其中C = \log_32是一个常量。基于我们前面的一个理论：在采用大O(\log_n)标记复<br>$$</p><p>$$<br>杂度的时候，可以忽略系数，即O(Cf(n)) = O(f(n))。所以，O(\log_2n)就等于O(\log_3n)。因此，在对数阶时间复杂度的表示放法里，我们忽略对数的“底”,统一表示为O(\log_n)。<br>$$</p><p>如果一段代码的时间复杂度是 O(logn)，我们循环执行 我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。</p><p><strong>时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长的关系。</strong></p><a id="more"></a><h1 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2.空间复杂度"></a>2.空间复杂度</h1><p>类比时间复杂度，空间复杂度主要取决于，空间存储变量的开辟的大小</p><p><img src="/2019/02/26/时间复杂度分析-上/常用时间复杂度.png" alt="常用时间复杂度"></p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;复杂度分析&quot;&gt;&lt;a href=&quot;#复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;复杂度分析&quot;&gt;&lt;/a&gt;复杂度分析&lt;/h1&gt;&lt;h1 id=&quot;常见时间复杂度&quot;&gt;&lt;a href=&quot;#常见时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;常见时间复杂度&quot;&gt;&lt;/a&gt;常见时间复杂度&lt;/h1&gt;&lt;h2 id=&quot;1-O-1-常量阶时间复杂度&quot;&gt;&lt;a href=&quot;#1-O-1-常量阶时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;1.O(1):常量阶时间复杂度&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.O(1):常量阶时间复杂度&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;算法中存在循环语句，递归语句，时间复杂度不会随着n的增加而增加。&lt;/p&gt;
&lt;h2 id=&quot;2-O-logn-、O-nlogn&quot;&gt;&lt;a href=&quot;#2-O-logn-、O-nlogn&quot; class=&quot;headerlink&quot; title=&quot;2.O(logn)、O(nlogn):&quot;&gt;&lt;/a&gt;&lt;strong&gt;2.O(logn)、O(nlogn):&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;对数阶时间复杂度&lt;br&gt;$$&lt;br&gt;判断循环条件不满足时，将变量的变化的过程用函数表示，表示出来的公式是一个\logx_n判断变化了多少此即可。&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;即使\log_2 n,\log_3n,\log_4n——&amp;gt;都是\log_n对数之间可以进行转换。为什么，可使用O(logn)表示呢，因为如下：&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;\log_3n= \log_32 &lt;em&gt; \log_2n =O(C&lt;/em&gt;\log_2n) 其中C = \log_32是一个常量。基于我们前面的一个理论：在采用大O(\log_n)标记复&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;杂度的时候，可以忽略系数，即O(Cf(n)) = O(f(n))。所以，O(\log_2n)就等于O(\log_3n)。因此，在对数阶时间复杂度的表示放法里，我们忽略对数的“底”,统一表示为O(\log_n)。&lt;br&gt;$$&lt;/p&gt;
&lt;p&gt;如果一段代码的时间复杂度是 O(logn)，我们循环执行 我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长的关系。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="时间复杂度" scheme="https://soyanga.github.io/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>再识java--集合框架</title>
    <link href="https://soyanga.github.io/2019/02/19/%E5%86%8D%E8%AF%86java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    <id>https://soyanga.github.io/2019/02/19/再识java-集合框架/</id>
    <published>2019-02-19T04:05:45.000Z</published>
    <updated>2019-02-19T05:29:30.472Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="集合产生原因"><a href="#集合产生原因" class="headerlink" title="集合产生原因"></a>集合产生原因</h1><ul><li><p>集合产生背景：</p><ul><li>JDK1.2-产生集合框架类集</li></ul></li><li><p>集合的作用</p><ul><li>保存数据</li><li>数组定长问题，集合本质上是一个动态数组</li></ul></li></ul><h2 id="Collection接口-保存单个元素的最大父接口"><a href="#Collection接口-保存单个元素的最大父接口" class="headerlink" title="Collection接口:保存单个元素的最大父接口"></a>Collection接口:保存单个元素的最大父接口</h2><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="function"><span class="keyword">public</span> bollean <span class="title">add</span><span class="params">()</span></span>; <span class="comment">//添加元素</span></span><br><span class="line"><span class="number">2</span>.<span class="function"><span class="keyword">public</span> bollean <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//删除集合中元素</span></span><br><span class="line"><span class="number">3</span>.<span class="function"><span class="keyword">public</span> bollean <span class="title">contains</span><span class="params">()</span></span>;<span class="comment">//查看集合中是否有这个元素</span></span><br><span class="line"><span class="number">4</span>.<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//清空集合元素</span></span><br><span class="line"><span class="number">6</span>.<span class="keyword">public</span> Object[] toArray();<span class="comment">//将集合转变为对象数组</span></span><br><span class="line"><span class="number">5</span>.<span class="keyword">public</span> Iterator&lt;?&gt;iterator();<span class="comment">//获得集合的迭代器</span></span><br></pre></td></tr></table></figure><h3 id="List：允许数据重复"><a href="#List：允许数据重复" class="headerlink" title="List：允许数据重复"></a>List：允许数据重复</h3><h4 id="独有的方法"><a href="#独有的方法" class="headerlink" title="独有的方法:"></a>独有的方法:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>：<span class="comment">//根据索引下标取得数据</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E set（<span class="keyword">int</span> index,E element)<span class="comment">//根据索引下标更新数据，返回修改之前的数据</span></span></span><br></pre></td></tr></table></figure><p><a href="http://naotu.baidu.com/file/7e2ce9e67efeed3fc5b3f442c30d27c3" target="_blank" rel="noopener">ArrayList,Vectory,LinkedList</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;集合产生原因&quot;&gt;&lt;a href=&quot;#集合产生原因&quot; class=&quot;headerlink&quot; title=&quot;集合产生原因&quot;&gt;&lt;/a&gt;集合产生原因&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;集合产生背景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK1.2
      
    
    </summary>
    
      <category term="JAVASE" scheme="https://soyanga.github.io/categories/JAVASE/"/>
    
      <category term="Java集合" scheme="https://soyanga.github.io/categories/JAVASE/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="JavaSE基础" scheme="https://soyanga.github.io/tags/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java学习笔记" scheme="https://soyanga.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="集合框架学习+源码分析" scheme="https://soyanga.github.io/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>再识java包装类</title>
    <link href="https://soyanga.github.io/2019/02/13/%E5%86%8D%E8%AF%86java%E5%8C%85%E8%A3%85%E7%B1%BB/"/>
    <id>https://soyanga.github.io/2019/02/13/再识java包装类/</id>
    <published>2019-02-13T12:14:04.000Z</published>
    <updated>2019-02-13T15:04:57.568Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>​     </p><h1 id="包装类（Java三个特殊类）"><a href="#包装类（Java三个特殊类）" class="headerlink" title="包装类（Java三个特殊类）"></a>包装类（Java三个特殊类）</h1><p>Object 类可以接收所有引用类型，但是不能接收基本数据类型。包装类就是给基本数据的处理来使用。</p><h2 id="包装类的基本使用"><a href="#包装类的基本使用" class="headerlink" title="包装类的基本使用"></a>包装类的基本使用</h2><p>包装类就将基本数据类型封装到类中</p><p>自定义一个包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntDemo</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntDemo</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​         这时IntDemo就像相当于int数据类型的包装类，利用IntValue就可以实现基本的数据类型变为对象的需求了（供Obejct使用）</p><a id="more"></a> <p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;        </span><br><span class="line"><span class="comment">// 子类对象向上转型        </span></span><br><span class="line">Object obj = <span class="keyword">new</span> IntDemo(<span class="number">55</span>) ;         </span><br><span class="line">IntDemo temp = (IntDemo) obj ; <span class="comment">// 向下转型        </span></span><br><span class="line">System.out.println(temp.intValue()); <span class="comment">// 取出里面的基本数据类型操作  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：将基本数据类型包装为一个包装类一个类对象的本质就是使用Object进行接收处理</p><p>但是Java中有8个数据类型，如果以上都需要进行认为编写，则会存在以下问题</p><blockquote><ol><li>开发中代码重复太多</li><li>进行数学计算的时候，必须利用明确的方法将包装的数据取出后才进行运算。</li></ol></blockquote><p>为了方便开发，Java引入包装类的使用，以下提供了两种类型</p><ul><li>对象型(Object的直接子类):Boolean,Character(char);</li><li>数值型(Number的直接子类):Byte,Short,Long,Integer(int),Float;</li></ul><h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>在包装类于基本数据类型处理中存有两个概念：</p><ul><li><strong>装箱：</strong>将基本数据类型变为包装类对象，利用每一个<strong>包装类提供的构造方法实现装箱处理</strong>。</li><li><strong>拆箱：</strong>将包装类中包装的基本数据类型取出。利用<strong>Number类中提供的6中方法</strong>。</li></ul><p><strong>eg:以int和Integer为例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer num = <span class="keyword">new</span> Integer(<span class="number">55</span>);<span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> data = num.intValue();<span class="comment">//拆箱</span></span><br><span class="line">System.out.println(data);</span><br></pre></td></tr></table></figure><p>以上操作采用的时手工的装箱和拆箱。<strong>在JDK1.5之后，提供了自动拆装箱的机制</strong>，最为重要的是，由于此类机制的存在，可以直接利用包装类的对象进行各种数学计算。</p><p><strong>eg:自动拆装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer x = <span class="number">55</span>;</span><br><span class="line"><span class="comment">//可以直接理应包装类对象操作(自动拆箱)</span></span><br><span class="line">System.out.println(++x*<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="引出问题："><a href="#引出问题：" class="headerlink" title="引出问题："></a>引出问题：</h3><p><strong>阿里编码规范—：</strong> 相同类型的包装类对象之间值的比较，全部使用equals方法比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">      Integer num1 = <span class="keyword">new</span> Integer(<span class="number">10</span>) ;         </span><br><span class="line">      Integer num2 = <span class="keyword">new</span> Integer(<span class="number">10</span>) ;</span><br><span class="line">Integer num3 = <span class="number">10</span>;</span><br><span class="line">Integer num4 = <span class="number">10</span>；</span><br><span class="line"><span class="keyword">int</span> num5 = <span class="number">10</span>;</span><br><span class="line">      System.out.println(num1 == num2);<span class="comment">//false  原因-128&lt;10&lt;127 //比较对象</span></span><br><span class="line">      System.out.println(num1 == <span class="keyword">new</span> Integer(<span class="number">10</span>)); <span class="comment">//false     //比较对象</span></span><br><span class="line">System.out.println(num3 == num4);<span class="comment">//true      //Integer最小缓存机制</span></span><br><span class="line">System.out.println(num1 == num3);<span class="comment">//false //其中一个是对象则就是对象比较</span></span><br><span class="line">System.out.println(num1 == num5);<span class="comment">//自动拆箱，Integer类型与int类型比较，Integer类型自动拆箱变为int类型</span></span><br><span class="line">System.out.println(num3 == num5);<span class="comment">//同上</span></span><br><span class="line">      System.out.println(num1.equals(<span class="keyword">new</span> Integer(<span class="number">10</span>)));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>说明：对于Integer var = ?在-128~128范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外所有的数据，都会在堆上产生，并不会复用已有对象。</p><p>【强力推荐】相同类型的包装类对象之间值的比较，全部使用equals方法比较</p><h2 id="阿里编码规范："><a href="#阿里编码规范：" class="headerlink" title="阿里编码规范："></a>阿里编码规范：</h2><p>关于基本数据类型与包装类型的使用标准如下：</p><ol><li>【强制】所有POJO类属性必须使用包装类数据类型。</li><li>【强制】RPC方法的返回值和参数必须使用包装类数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;​     &lt;/p&gt;
&lt;h1 id=&quot;包装类（Java三个特殊类）&quot;&gt;&lt;a href=&quot;#包装类（Java三个特殊类）&quot; class=&quot;headerlink&quot; title=&quot;包装类（Java三个特殊类）&quot;&gt;&lt;/a&gt;包装类（Java三个特殊类）&lt;/h1&gt;&lt;p&gt;Object 类可以接收所有引用类型，但是不能接收基本数据类型。包装类就是给基本数据的处理来使用。&lt;/p&gt;
&lt;h2 id=&quot;包装类的基本使用&quot;&gt;&lt;a href=&quot;#包装类的基本使用&quot; class=&quot;headerlink&quot; title=&quot;包装类的基本使用&quot;&gt;&lt;/a&gt;包装类的基本使用&lt;/h2&gt;&lt;p&gt;包装类就将基本数据类型封装到类中&lt;/p&gt;
&lt;p&gt;自定义一个包装类&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IntDemo&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;IntDemo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; num)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.num = num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;​         这时IntDemo就像相当于int数据类型的包装类，利用IntValue就可以实现基本的数据类型变为对象的需求了（供Obejct使用）&lt;/p&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://soyanga.github.io/categories/JAVASE/"/>
    
    
      <category term="JavaSE基础" scheme="https://soyanga.github.io/tags/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java学习笔记" scheme="https://soyanga.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="包装类-自动拆装箱" scheme="https://soyanga.github.io/tags/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1/"/>
    
  </entry>
  
  <entry>
    <title>数据结构复习专用</title>
    <link href="https://soyanga.github.io/2019/01/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E4%B8%93%E7%94%A8/"/>
    <id>https://soyanga.github.io/2019/01/31/数据结构复习专用/</id>
    <published>2019-01-31T15:33:16.000Z</published>
    <updated>2019-02-26T14:42:07.148Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>[TOC]</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><a id="more"></a><h3 id="求众数"><a href="#求众数" class="headerlink" title="求众数"></a>求众数</h3><p><strong>示例：</strong></p><p>给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>解题：</strong></p><p>利用一个计数器记录目标数据出现的次数，相同目标次数+1，不同则目标次数-1。一旦计数器变为0则改变目标数据为正在遍历的下一个数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;  <span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">int</span> maj = nums[<span class="number">0</span>];   <span class="comment">//目标数据</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(maj == nums[i])&#123; <span class="comment">//相同+1</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count--; <span class="comment">//计数器-1</span></span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)&#123; <span class="comment">//如果计数器变为0（出现次数小于当前遍历过数组长度）</span></span><br><span class="line">                    maj = nums[i+<span class="number">1</span>];<span class="comment">//改变目标数据</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解题2：</strong>排序,然后利用出现次数大于length/2。定位到数组下标即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="反转单链表-LeetCode206"><a href="#反转单链表-LeetCode206" class="headerlink" title="反转单链表 [LeetCode206]"></a>反转单链表 [LeetCode206]</h3><p><strong>示例：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode per = <span class="keyword">null</span>;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = per;</span><br><span class="line">            per = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> per;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图：</p><p>其实就只一直在将<code>cur.next=pre</code>，然后pre变为cur,cur变为next。</p><p><img src="/2019/01/31/数据结构复习专用/反转单链表图解.png" alt="反转单链表图解"></p><h3 id="环形链表（链表是否带环）-LeetCode141"><a href="#环形链表（链表是否带环）-LeetCode141" class="headerlink" title="环形链表（链表是否带环）[LeetCode141]"></a>环形链表（链表是否带环）[LeetCode141]</h3><p><strong>示例1：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" alt="img"></p><p><strong>解答：</strong></p><ol><li><p><strong>利用哈希表Set（无重复值）存储链表节点，头节点向后遍历，只要走到相同的节点，就带环</strong></p><p><strong>反之只要头节点向后遍历到null，则链表无环。</strong></p><p><strong>时间复杂度O(n) 空间复杂度O(n)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.add(head);</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>利用快慢指针，相差一步的快慢指针，</strong></p><p><strong>时间复杂度O(n) 空间复杂度O(n)</strong></p><p><strong>关于为什么是一个走两步，一个走一步的原因：既然是要相遇，如果快指针走三步，它每次会跳过两个节点，慢指针一次只能走一步，这就可能会错过。快指针每次走两步的话，只会跳过一个节点，无论如何后都会和慢指针相遇。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">while</span>(fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序链表-LeetCode21"><a href="#合并两个有序链表-LeetCode21" class="headerlink" title="合并两个有序链表[LeetCode21]"></a>合并两个有序链表[LeetCode21]</h3><p><strong>示例：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode newNode = <span class="keyword">new</span> ListNode(<span class="number">0</span>); <span class="comment">//带头结点的新链表</span></span><br><span class="line">        ListNode cur = newNode;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;<span class="comment">//谁小，新链表接谁</span></span><br><span class="line">            <span class="keyword">if</span>(l1.val&gt;l2.val)&#123;</span><br><span class="line">                 cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>)&#123;     <span class="comment">//一个链表完了直接接另一个有序列表</span></span><br><span class="line">            cur.next=l2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第N个节点-LeetCode19"><a href="#删除链表的倒数第N个节点-LeetCode19" class="headerlink" title="删除链表的倒数第N个节点[LeetCode19]"></a>删除链表的倒数第N个节点[LeetCode19]</h3><p><strong>示例：</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>解答：</strong> </p><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode newhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);<span class="comment">//带头节点</span></span><br><span class="line">        newhead.next = head;</span><br><span class="line">        ListNode fast = newhead;</span><br><span class="line">        ListNode slow = newhead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123; <span class="comment">//快指针先走n+1步</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;  <span class="comment">//同时走</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;  倒数第n个节点的前一个节点</span><br><span class="line">        <span class="keyword">return</span> newhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求链表的中间结点-LeetCode876"><a href="#求链表的中间结点-LeetCode876" class="headerlink" title="求链表的中间结点[LeetCode876]"></a>求链表的中间结点[LeetCode876]</h3><p><strong>示例：</strong></p><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。</span><br><span class="line">注意，我们返回了一个 ListNode 类型的对象 ans，这样：</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><p><strong>快慢指针法</strong></p><ul><li>时间复杂度：O(N)<em>O</em>(<em>N</em>)，其中 N<em>N</em> 是给定列表的结点数目</li><li>空间复杂度：O(1)<em>O</em>(1)，<code>slow</code> 和 <code>fast</code> 用去的空间</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast =fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="有效括号-LeetCode20"><a href="#有效括号-LeetCode20" class="headerlink" title="有效括号[LeetCode20]"></a>有效括号[LeetCode20]</h3><p><strong>示例：</strong> </p><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;{&#39;</code>，<code>&#39;}&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>注意空字符串可被认为是有效字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>解答：利用哈希表以Key-Value模型 存储要匹配的两个字符</strong> </p><p>例如： <code>map.put(&#39;)&#39;,&#39;(&#39;);</code>假如出现’)’则在此相邻的必定出现了’(‘与之相对，所以将出现的未匹配成功的字符（匹配字符的左括号）压入栈中，等待右括号出现，立马进行出栈确认，在栈为字符串中率先出现一个右括号则在栈中压入一个“#“。则获取匹配已经失败。</p><p>反之当字符串都经历了这个流程后栈为空时，此时字符串括号匹配。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Character,Character&gt; mappings; <span class="comment">//存储括号的对应值</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mappings = <span class="keyword">new</span> HashMap&lt;Character,Character&gt;();</span><br><span class="line">        <span class="keyword">this</span>.mappings.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappings.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line">        <span class="keyword">this</span>.mappings.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;(); <span class="comment">//括号匹配栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123; <span class="comment">//按照字符拆分字符串</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="comment">//如果字符串中的字符是一个右半括号</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.mappings.containsKey(c))&#123;</span><br><span class="line">                <span class="keyword">char</span> toElement = stack.empty()? <span class="string">'#'</span> :stack.pop();</span><br><span class="line">                <span class="comment">//按照key查找对应的value值即可</span></span><br><span class="line">                <span class="keyword">if</span>(toElement != <span class="keyword">this</span>.mappings.get(c))&#123; <span class="comment">//括号匹配则继续进行，不匹配则返回不匹配</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果字符串中是一个左半括号</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最小栈-LeetCode155"><a href="#最小栈-LeetCode155" class="headerlink" title="最小栈[LeetCode155]"></a>最小栈[LeetCode155]</h3><p><strong>示例：</strong></p><p>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) – 将元素 x 推入栈中。</li><li>pop() – 删除栈顶的元素。</li><li>top() – 获取栈顶元素。</li><li>getMin() – 检索栈中的最小元素。</li></ul><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>解答：双栈（主栈+最小栈）/（单栈模拟双栈）</strong></p><p><strong>双栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack &lt;Integer&gt;stack;</span><br><span class="line">    Stack &lt;Integer&gt;minStack;</span><br><span class="line">    <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.minStack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  <span class="comment">//无论如何双栈中压入元素个数相同</span></span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty()||x&lt;minStack.peek())</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">        minStack.push(minStack.peek());</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;  <span class="comment">//无论如何双栈中抛出元素个数相同</span></span><br><span class="line">        stack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>单栈模拟双栈：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Stack &lt;Integer&gt;stack;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">            stack.push(x);</span><br><span class="line">            stack.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = stack.peek();</span><br><span class="line">            stack.push(x);</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;x)&#123;</span><br><span class="line">                stack.push(temp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.get(stack.size()-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="用栈实现队列-LeetCode232"><a href="#用栈实现队列-LeetCode232" class="headerlink" title="用栈实现队列[LeetCode232]"></a>用栈实现队列[LeetCode232]</h3><p><strong>示例：</strong></p><p>使用栈实现队列的下列操作：</p><ul><li>push(x) – 将一个元素放入队列的尾部。</li><li>pop() – 从队列首部移除元素。</li><li>peek() – 返回队列首部的元素。</li><li>empty() – 返回队列是否为空。</li></ul><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = <span class="keyword">new</span> MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">1</span>);</span><br><span class="line">queue.push(<span class="number">2</span>);  </span><br><span class="line">queue.peek();  <span class="comment">// 返回 1</span></span><br><span class="line">queue.pop();   <span class="comment">// 返回 1</span></span><br><span class="line">queue.empty(); <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>你只能使用标准的栈操作 – 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><p><strong>解答：</strong> </p><p>利用两个栈，一个栈默认用来存放数据，另一个栈用来实现数据的反转，使用原本栈的操作，来模拟实现队列的出入，查看结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; s1;  <span class="comment">//来回倒数据数据实现出队列入队列的栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; sQueue; <span class="comment">//固定一个栈为存储数据的栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> Stack();</span><br><span class="line">        sQueue = <span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//入队列的时候就将数据倒好</span></span><br><span class="line">        <span class="keyword">while</span>(!sQueue.isEmpty())&#123;</span><br><span class="line">            s1.push(sQueue.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        sQueue.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">            sQueue.push(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sQueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sQueue.pop();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sQueue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sQueue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>另一种解法：异曲同工之妙</strong> </p><p><strong>第一种解法，在入队列的时候倒数据。这种解法，只有在出队列的时候或者查看队列头的时候倒数据。每次出队列就在出队列的栈中出，而入队列的时候只需要将数据入到入队列的栈中。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; inStack;</span><br><span class="line">    Stack&lt;Integer&gt; outStack;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inStack = <span class="keyword">new</span> Stack();</span><br><span class="line">        outStack = <span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inStack.isEmpty())&#123;</span><br><span class="line">                outStack.push(inStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> outStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inStack.isEmpty()&amp;&amp;outStack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="比较含退格的字符串-LeetCode844"><a href="#比较含退格的字符串-LeetCode844" class="headerlink" title="比较含退格的字符串[LeetCode844]"></a>比较含退格的字符串[LeetCode844]</h3><p>示例：</p><p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>&#39;#&#39;</code>。</li></ol><p><strong>解题：</strong></p><blockquote><ul><li><p>第一感觉是需要使用一个可以执行插入，删除的数据结构用于存储字符串。数组，链表，栈，队列，可变字符串</p></li><li><p>又因为‘#’这个操作是回退，即删除该字符前的一个字符，就类似于键盘上的Backspace按键。“后进先出”-栈</p></li><li><p>两个字符串-双栈</p></li><li>删除，写入就如同入栈出栈，最后比较栈中元素即可。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//双栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; s1 = <span class="keyword">new</span> Stack(); <span class="comment">//字符串1的栈</span></span><br><span class="line">        Stack&lt;Character&gt; s2 = <span class="keyword">new</span> Stack(); <span class="comment">//字符串2的栈</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i)!=<span class="string">'#'</span>)&#123;</span><br><span class="line">                s1.push(S.charAt(i));<span class="comment">//入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!s1.isEmpty())&#123;<span class="comment">//出栈</span></span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(T.charAt(i)!=<span class="string">'#'</span>)&#123;</span><br><span class="line">                s2.push(T.charAt(i));<span class="comment">//入栈</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!s2.isEmpty())&#123;<span class="comment">//出栈</span></span><br><span class="line">                s2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.equals(s2); <span class="comment">//比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本计算器-LeetCode224"><a href="#基本计算器-LeetCode224" class="headerlink" title="基本计算器[LeetCode224]"></a>基本计算器[LeetCode224]</h3><h3 id="逆波兰表达式-LeetCode150"><a href="#逆波兰表达式-LeetCode150" class="headerlink" title="逆波兰表达式[LeetCode150]"></a>逆波兰表达式[LeetCode150]</h3><p><strong>示例</strong></p><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p><p><strong>说明：</strong></p><ul><li>整数除法只保留整数部分。</li><li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span><br><span class="line">输出: 9</span><br><span class="line">解释: ((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span><br><span class="line">输出: 6</span><br><span class="line">解释: (4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]</span><br><span class="line">输出: 22</span><br><span class="line">解释: </span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure><p><strong>解题：</strong>    </p><p><strong>利用栈，逆波兰表达式将符号前的两个数字(栈顶元素，记录，出栈)按符号进行计算，计算后入栈等待下一个数字和下一个操作符。最后返回栈顶元素即可。</strong>                                                                                       </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; sNumber = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;tokens.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i].equals(<span class="string">"+"</span>)||tokens[i].equals(<span class="string">"-"</span>)||tokens[i].equals(<span class="string">"*"</span>)||tokens[i].equals(<span class="string">"/"</span>))</span><br><span class="line">            &#123; <span class="comment">//操作数处理</span></span><br><span class="line">                <span class="keyword">int</span> a= sNumber.pop();</span><br><span class="line">                <span class="keyword">int</span> b = sNumber.pop();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i].equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                    sNumber.push(b+a);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tokens[i].equals(<span class="string">"-"</span>))&#123;</span><br><span class="line">                    sNumber.push(b-a);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tokens[i].equals(<span class="string">"*"</span>))&#123;</span><br><span class="line">                    sNumber.push(b*a);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(tokens[i].equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">                    sNumber.push(b/a);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//数字处理</span></span><br><span class="line">                sNumber.push(Integer.parseInt(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sNumber.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="棒球比赛-LeetCode682"><a href="#棒球比赛-LeetCode682" class="headerlink" title="棒球比赛[LeetCode682]"></a>棒球比赛[LeetCode682]</h3><p><strong>示例：</strong></p><p>你现在是棒球比赛记录员。<br>给定一个字符串列表，每个字符串可以是以下四种类型之一：<br>1.<code>整数</code>（一轮的得分）：直接表示您在本轮中获得的积分数。</p><ol start="2"><li><code>&quot;+&quot;</code>（一轮的得分）：表示本轮获得的得分是前两轮<code>有效</code> 回合得分的总和。<br>\3. <code>&quot;D&quot;</code>（一轮的得分）：表示本轮获得的得分是前一轮<code>有效</code> 回合得分的两倍。<br>\4. <code>&quot;C&quot;</code>（一个操作，这不是一个回合的分数）：表示您获得的最后一个<code>有效</code> 回合的分数是无效的，应该被移除。</li></ol><p>每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。<br>你需要返回你在所有回合中得分的总和。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;2&quot;,&quot;C&quot;,&quot;D&quot;,&quot;+&quot;]</span><br><span class="line">输出: 30</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到2分。总和是：7。</span><br><span class="line">操作1：第2轮的数据无效。总和是：5。</span><br><span class="line">第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。</span><br><span class="line">第4轮：你可以得到5 + 10 = 15分。总数是：30。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;5&quot;,&quot;-2&quot;,&quot;4&quot;,&quot;C&quot;,&quot;D&quot;,&quot;9&quot;,&quot;+&quot;,&quot;+&quot;]</span><br><span class="line">输出: 27</span><br><span class="line">解释: </span><br><span class="line">第1轮：你可以得到5分。总和是：5。</span><br><span class="line">第2轮：你可以得到-2分。总数是：3。</span><br><span class="line">第3轮：你可以得到4分。总和是：7。</span><br><span class="line">操作1：第3轮的数据无效。总数是：3。</span><br><span class="line">第4轮：你可以得到-4分（第三轮的数据已被删除）。总和是：-1。</span><br><span class="line">第5轮：你可以得到9分。总数是：8。</span><br><span class="line">第6轮：你可以得到-4 + 9 = 5分。总数是13。</span><br><span class="line">第7轮：你可以得到9 + 5 = 14分。总数是27。</span><br></pre></td></tr></table></figure><p><strong>解题：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; Count = <span class="keyword">new</span> Stack();</span><br><span class="line">        Integer count = <span class="number">0</span>;</span><br><span class="line">        Integer number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s:ops)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"C"</span>))&#123;</span><br><span class="line">                Count.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"D"</span>))&#123;</span><br><span class="line">                Integer n = Count.peek()*<span class="number">2</span>;</span><br><span class="line">                Count.push(n);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">                Integer a = Count.pop();</span><br><span class="line">                Integer b = Count.pop();</span><br><span class="line">                Count.push(b);</span><br><span class="line">                Count.push(a);</span><br><span class="line">                Count.push(a+b);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Count.push(Integer.valueOf(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Count.isEmpty())&#123;</span><br><span class="line">            number+=Count.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下一个更大元素-I-LeetCode496"><a href="#下一个更大元素-I-LeetCode496" class="headerlink" title="下一个更大元素 I[LeetCode496]"></a>下一个更大元素 I[LeetCode496]</h3><p><strong>示例：</strong> </p><p>给定两个<strong>没有重复元素</strong>的数组 <code>nums1</code> 和 <code>nums2</code> ，其中<code>nums1</code> 是 <code>nums2</code> 的子集。找到 <code>nums1</code> 中每个元素在 <code>nums2</code> 中的下一个比其大的值。</p><p><code>nums1</code> 中数字 <strong>x</strong> 的下一个更大元素是指 <strong>x</strong> 在 <code>nums2</code> 中对应位置的右边的第一个比 <strong>x</strong> 大的元素。如果不存在，对应位置输出-1。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。</span><br><span class="line">    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。</span><br><span class="line">    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [2,4], nums2 = [1,2,3,4].</span><br><span class="line">输出: [3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于num1中的数字2，第二个数组中的下一个较大数字是3。</span><br><span class="line">    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li><code>nums1</code>和<code>nums2</code>中所有元素是唯一的。</li><li><code>nums1</code>和<code>nums2</code> 的数组大小都不超过1000。</li></ol><p><strong>解答：</strong> </p><p>通过<strong>Stack、HashMap</strong>解决</p><blockquote><ol><li><strong>先遍历大数组nums2，首先将第一个元素入栈；</strong></li><li><strong>继续遍历，当当前元素小于栈顶元素时，继续将它入栈；当当前元素大于栈顶元素时，栈顶元素出栈，此时应将该出栈的元素与当前元素形成key-value键值对，存入HashMap中；</strong></li><li><strong>当遍历完nums2后，得到nums2中元素所对应的下一个更大元素的hash表；</strong></li><li><strong>遍历nums1的元素在hashMap中去查找‘下一个更大元素’，当找不到时则为-1。</strong></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// Stack&lt;Integer&gt; stack = new Stack();//利用栈筛选出nums2中满足条件的一对元素。</span></span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hashMap = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for(int num:nums2)&#123;                           //利用栈，栈顶元素筛选出nums2中满足条件的一对元素。</span></span><br><span class="line">        <span class="comment">//     while(!stack.isEmpty()&amp;&amp;stack.peek()&lt;num)&#123;</span></span><br><span class="line">        <span class="comment">//         hashMap.put(stack.pop(),num);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     stack.push(num);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums2.length; i++)&#123;     <span class="comment">//利用数组直接筛选出母数组中符合条件（下标小的小于小标大的元素）的数据对</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =i; j&lt;nums2.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums2[i]&lt;nums2[j])&#123;</span><br><span class="line">                    hashMap.put(nums2[i],nums2[j]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;  <span class="comment">//按照子数组中数在Map中进行查找，查找出来就返回大数，反之返回-1</span></span><br><span class="line">            result[i] = hashMap.getOrDefault(nums1[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="https://soyanga.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>volatile-双重检验锁模式</title>
    <link href="https://soyanga.github.io/2019/01/31/volatile-%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://soyanga.github.io/2019/01/31/volatile-双重检验锁模式/</id>
    <published>2019-01-31T10:10:53.000Z</published>
    <updated>2019-01-31T15:37:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1-volatile型变量的特殊规则"><a href="#1-volatile型变量的特殊规则" class="headerlink" title="1.volatile型变量的特殊规则"></a>1.volatile型变量的特殊规则</h2><p>关键字volatile可以说是JVM提供的最轻量级的同步机制，JVM内存模型对volatile专门定义了一些特殊访问规则。</p><p>当一个变量被定义为volatile之后，它具备两种特性。可见性和有序性</p><h2 id="两层语义："><a href="#两层语义：" class="headerlink" title="两层语义："></a>两层语义：</h2><ul><li><strong>第一层语义：</strong>内存可见–可见性</li><li><strong>第二层语义：</strong>禁止指令重排–有序性</li></ul><a id="more"></a><p><strong>可见性：</strong>当一个线程修改了这个变量的值，新值能被其他线程可以立刻得到，而普通变量做不到这一点，普通变量的值在线程之间传递需要通过主内存来完成。</p><p>具体来说，volatile的作用是：<strong>在本CPU对变量的修改直写入主内存中，同时这个写操作使得其他CPU中对应的变量的缓存行无效</strong>，<strong>这样其他线程在读取这个变量时候必须从主内存中读取，所以读取得到的是最新的</strong>，这就是上面说的能被立即“看到”。</p><p>volatile修饰的变量仅仅只拥有这两个性质，<strong>并不拥有原子性，volatile变量的运算在并发下是不安全的，原因java里面的运算并非原子操作。</strong></p><h2 id="volatile修饰的变量如何确保原子性"><a href="#volatile修饰的变量如何确保原子性" class="headerlink" title="volatile修饰的变量如何确保原子性"></a>volatile修饰的变量如何确保原子性</h2><p>由于volatile只保证了可见习性和，有序性。子在不符合以下两条规则的运算场景中，我们仍然需要<strong>通过加锁(synchronized或lock)来保证原子性</strong></p><ol><li>运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ol><p><strong>并发场景下对于类似++操作如何保证原子性</strong></p><ul><li><strong>加锁，结合synchronized或者lock体系</strong></li><li><strong>使用原子类（java.util.current.atomic包下的所有类-内部使用CAS保证原子性）</strong></li></ul><p><strong>有序性：volatile可以禁止指令重排</strong> 。volatile在其汇编代码中有一个lock操作，这个操作相当一个<strong>内存屏障</strong>，<strong>指令重排不能越过内存屏障</strong>，具体来</p><ul><li><strong>说在执行volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面执行的语句时已知的，而内存屏障后面的语句一定还没有执行到</strong>；</li><li>在进行指令优化时，<strong>在volatile变量之前的语句不能能被重排其之后，相反的其后的语句也必能被重排到之前。</strong></li></ul><h1 id="2-双重检验锁模式（懒汉单例模式）"><a href="#2-双重检验锁模式（懒汉单例模式）" class="headerlink" title="2.双重检验锁模式（懒汉单例模式）"></a>2.双重检验锁模式（懒汉单例模式）</h1><p>双重检验锁模式(double checked locking pattern),是一种使用同步块加锁的方式。程序员称其为双重检查</p><p>锁，因为会有两次检查，一次是在同步块外，一次是在同步块内。</p><h2 id="为什么在同步块内还要再检验一次？"><a href="#为什么在同步块内还要再检验一次？" class="headerlink" title="为什么在同步块内还要再检验一次？"></a>为什么在同步块内还要再检验一次？</h2><p>因为可能会有多个线程一起进入到同步块外的if，如果在同步块内不进行二次检验就会生成多个实例。</p><h2 id="volatile在单例模式中起了什么作用？"><a href="#volatile在单例模式中起了什么作用？" class="headerlink" title="volatile在单例模式中起了什么作用？"></a>volatile在单例模式中起了什么作用？</h2><p>主要是因为懒汉模式，用时再new，但是instance = new Singleto()这句，并非是一个原子操作，事实上再JVM中这句话大概做了以下3件事</p><ol><li><p>给instance分配内存，</p></li><li><p>调用Singleton的构造函数来初始化成员变量</p></li><li><p>将instance对象指向分配的内存空间（执行完这步instance就为非null了）</p><p>但是在JVM的即时编译器中存在指令重排优化。也就事说上面第二步和第三步的顺序是不能保证的，</p><p>最终的执行顺序可能是1-2-3也可能是1-3-2</p><p>如果是后者(1-3-2)，则3执行完毕，2未执行之前，被线程二抢占了，这时instance已经是非null了(但是却没有初始化)，所以哦线程二直接返回instance，然后使用，就会报错。我们只需要将instance变量声明成volatile就可以了。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JVMReview;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: java-SE</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: SOYANGA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2019-01-31 19:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;   <span class="comment">//Single Checked</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  <span class="comment">//Double Checked</span></span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hahah"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        singleton.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h2 id=&quot;1-volatile型变量的特殊规则&quot;&gt;&lt;a href=&quot;#1-volatile型变量的特殊规则&quot; class=&quot;headerlink&quot; title=&quot;1.volatile型变量的特殊规则&quot;&gt;&lt;/a&gt;1.volatile型变量的特殊规则&lt;/h2&gt;&lt;p&gt;关键字volatile可以说是JVM提供的最轻量级的同步机制，JVM内存模型对volatile专门定义了一些特殊访问规则。&lt;/p&gt;
&lt;p&gt;当一个变量被定义为volatile之后，它具备两种特性。可见性和有序性&lt;/p&gt;
&lt;h2 id=&quot;两层语义：&quot;&gt;&lt;a href=&quot;#两层语义：&quot; class=&quot;headerlink&quot; title=&quot;两层语义：&quot;&gt;&lt;/a&gt;两层语义：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;第一层语义：&lt;/strong&gt;内存可见–可见性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二层语义：&lt;/strong&gt;禁止指令重排–有序性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://soyanga.github.io/categories/JAVASE/"/>
    
    
      <category term="JavaSE基础" scheme="https://soyanga.github.io/tags/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java学习笔记" scheme="https://soyanga.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="https://soyanga.github.io/tags/JVM/"/>
    
      <category term="重点" scheme="https://soyanga.github.io/tags/%E9%87%8D%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>再识Java-JVM</title>
    <link href="https://soyanga.github.io/2019/01/28/%E5%86%8D%E8%AF%86Java-JVM/"/>
    <id>https://soyanga.github.io/2019/01/28/再识Java-JVM/</id>
    <published>2019-01-28T05:14:59.000Z</published>
    <updated>2019-01-31T11:34:21.257Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="区域划分-gt-判断对象是否存活-gt-垃圾回收器-gt-对象分配回收策略"><a href="#区域划分-gt-判断对象是否存活-gt-垃圾回收器-gt-对象分配回收策略" class="headerlink" title="区域划分-&gt;判断对象是否存活-&gt;垃圾回收器-&gt;对象分配回收策略"></a>区域划分-&gt;判断对象是否存活-&gt;垃圾回收器-&gt;对象分配回收策略</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ol><li>JVM简介</li><li>Java内存区域与内存溢出异常 </li><li>垃圾回收器与内存分配策略 </li><li>常用JVM性能监控与故障处理工具 </li><li>Java内存模型</li></ol><h1 id="一、JVM简介"><a href="#一、JVM简介" class="headerlink" title="一、JVM简介"></a>一、JVM简介</h1><p>1）<strong>虚拟机简介：</strong></p><p>JVM(java Virtual Machine简称。意味java虚拟机){</p><p>虚拟机：指通过软件模拟的具有完整的硬件功能的、运行再一个完全隔离的环境中的完整计算机系统。</p><p>常见虚拟机：JVM，VMware,Vitual BOX</p><p>2）:JVM和其他两个虚拟机的区别：a.VMware与virtualBox【是通过软件模拟物理CPU的指令集物理系统中会有很多的寄存器</p><p>2）：<strong>JVM是通过软件模拟java字节码的指令集，JVM中只保留了PC寄存器，其他寄存器都进行了剪裁，JVM是一台被定制过的现实当中不存在的计算机</strong></p><a id="more"></a><h1 id="二、Java内存区域与内存溢出的异常"><a href="#二、Java内存区域与内存溢出的异常" class="headerlink" title="二、Java内存区域与内存溢出的异常"></a>二、Java内存区域与内存溢出的异常</h1><p>java内存区域的划分-<strong>共6块内存（bulingbuling）</strong></p><p><strong>线程私有区域：</strong>程序计数器，java虚拟机栈，本地方法栈</p><p><strong>线程共享区域：</strong>Java堆，Java方法区，运行时常量池</p><h2 id="2-1线程私有内存："><a href="#2-1线程私有内存：" class="headerlink" title="2.1线程私有内存："></a>2.1线程私有内存：</h2><p>每个线程都具有，且彼此之间相互隔离</p><h3 id="2-1-1程序计数器"><a href="#2-1-1程序计数器" class="headerlink" title="2.1.1程序计数器"></a>2.1.1程序计数器</h3><p>程序计数器是一个<strong>比较小的内存空间</strong>，<strong>当前线程所执行的字节码的行号指令器。</strong></p><blockquote><p>若当前线程执行的是java方法，计数器记录的是正在执行的JVM字节指令地址；</p><p>若当前线程执行的是native方法，计数器数值为空。</p></blockquote><p><em>程序计数器是唯一一块不会产生</em>OOM异常的区域。</p><h3 id="线程私有概念："><a href="#线程私有概念：" class="headerlink" title="线程私有概念："></a>线程私有概念：</h3><p>由于JVM的多线程是通过<strong>线程轮流切</strong>换并<strong>分配处理器执行时间</strong>的方式来实现的，因此在任何一个确定的时刻，一个多处理器（多核处理器则指的是一个内核）都会执<strong>行一个线程中的指</strong>令。因此为了<strong>切换线程</strong>后能<strong>恢复到正确的执行位置</strong>，每个线程都需要有<strong>独立的程序计数器</strong>，<strong>各条线程之间计数器互不影响</strong>，<strong>独立存储</strong>。我们就把类似这类区域成为”线程私有“内存。</p><h3 id="2-1-2Java虚拟机栈（线程私有）"><a href="#2-1-2Java虚拟机栈（线程私有）" class="headerlink" title="2.1.2Java虚拟机栈（线程私有）"></a>2.1.2Java虚拟机栈（线程私有）</h3><p>虚拟机栈描述的是<strong>java方法执行的内存模型</strong>：每个方法执行的同时都会创建一个<strong>栈帧</strong>用于<strong>存储局部变量表，操作数栈，动态链接，方法出口</strong>等。每个方法从调用直至执行完成的过程，就对用一个栈帧在虚拟机栈中入栈和出栈的过程。声明周期与线程相同。</p><p><strong>局部变量表：</strong>存放编译器可知的各种<strong>基本数据类型</strong>（8大数据类型），<strong>对象引用</strong>。局部变量表所需的内存空间在编译期完成分配，当进入一个方法使，这个方法需要在栈帧中分配多大局部变量空间完全是确定的，在执行期间不会改变局部变量表的大小。</p><p>此区域会产生两个异常：</p><ol><li><strong>SOFE:</strong>如果线程请求的栈深度大于虚拟机所允许的深度（<strong>-Xss设置栈容量</strong>），将会抛出StackOverFlowError异常。</li><li><strong>OOM:</strong>虚拟机在动态扩展时无法申请到足够的内存，会抛出OOM(OutOfMermoryError异常)</li></ol><h3 id="2-1-3本地方法栈（线程私有）"><a href="#2-1-3本地方法栈（线程私有）" class="headerlink" title="2.1.3本地方法栈（线程私有）"></a>2.1.3本地方法栈（线程私有）</h3><p>本地方法栈与虚拟机栈的作用完全一致，区别无非就是本地方法栈为虚拟机使用的Native方法服务，而虚拟机栈为JVM执行的Java方法服务。</p><p>在HotSpot虚拟机中，本地方法栈与虚拟机栈是同一块内存区域。</p><h2 id="2-2线程共享内存"><a href="#2-2线程共享内存" class="headerlink" title="2.2线程共享内存"></a>2.2线程共享内存</h2><h3 id="2-2-1Java堆（GC堆）-线程共享"><a href="#2-2-1Java堆（GC堆）-线程共享" class="headerlink" title="2.2.1Java堆（GC堆）-线程共享"></a>2.2.1Java堆（GC堆）-线程共享</h3><p>Java（堆 Java Heap)是JVM管理的<strong>最大内存区域</strong>。所有线程<strong>共享此内存</strong>，在JVM启动时创建，此内存中存放都是<strong>对象实例以及数组，</strong>1.7后新加了字符串</p><p><strong>Java堆是垃圾回收器管理的最主要内存区域。java堆可以处于物理上不连续的内存空间。</strong></p><p><strong>-Xmx</strong>:设置堆最大值</p><p><strong>-Xms:</strong>设置堆的最小值</p><p>如果在堆中没有足够的内存完成对象实例分配，并且堆无法再次扩展时抛出 <strong>OOM异常</strong>。(最频繁发生！)</p><p><strong>OOM:</strong>OutOfMerroryError虚拟机的动态扩展无法申请到足够的内存，会抛出OOM</p><p><strong>内存溢出：</strong>内存中的对象确实还应该存活，但由于堆内存不够用产生的异常。</p><p><strong>内存泄漏：</strong>无用对象无法被GC，扩展内存后还是会报错OOM异常</p><p>内存泄漏与内存溢出区别就在于扩展内存上，内存溢出可以扩展内存来解决，而内存泄漏则无法通过扩展内存的方式来解决。</p><h3 id="2-2-2方法区（静态）-线程共享"><a href="#2-2-2方法区（静态）-线程共享" class="headerlink" title="2.2.2方法区（静态）-线程共享"></a>2.2.2方法区（静态）-线程共享</h3><p>用于存储已被<strong>JVM加载的类信息，常量，静态变量，编译器编译后的代码等数据</strong>，JDK8以前，方法区也叫永久代，JDK8之后称为元空间（Mate Space）之前所说的<strong>静态常量区</strong></p><p><strong>永久代并不意味着数据进入方法区就永远存在</strong>，此区域的内存回收主<strong>要针对常量池的回收</strong>以及对<strong>类型的卸载。</strong></p><ul><li><p><strong>类定义的信息在方法区放着</strong></p><p>public static…(符号引用)也在方法区放着</p></li><li><p><strong>对象产生：符号引用-&gt;类-&gt;具体引用</strong></p><p>执行Test test = new Test();的过程</p><p>首先知道时那个类（<strong>存放在方法区中</strong>）</p><p>最后的具体引用-&gt;符号引用（<strong>从方法区中取出</strong>）</p></li></ul><p>  <strong>JVM规范：</strong>方法区无法满足内存分配需求时抛出OOM</p><h3 id="2-2-3运行时常量池（方法区的一部分）"><a href="#2-2-3运行时常量池（方法区的一部分）" class="headerlink" title="2.2.3运行时常量池（方法区的一部分）"></a>2.2.3运行时常量池（方法区的一部分）</h3><p>运行时常量池是方法区的一部分，存放字面量与符号引用。</p><p><strong>字面量：</strong>字符串（JDK1.7后移动到堆中），final常量，基本数据类型的值</p><p><strong>符号引用：</strong>类和结构的完全限定名，字段名称和描述符，方法名称个描述符。</p><p><strong>完全限定名：</strong>包.类名  权限修饰符</p><p><strong>字面量</strong>：10(基本数据类型的值)</p><h1 id="三、垃圾回收器与内存分配策略"><a href="#三、垃圾回收器与内存分配策略" class="headerlink" title="三、垃圾回收器与内存分配策略"></a>三、垃圾回收器与内存分配策略</h1><p><strong>线程私有的三个内存区域</strong>：程序计数器，虚拟机栈，本地方法栈这三个区域<strong>其生命周期与线程有关</strong>，随线程而生，随线程而灭。并<strong>且这三个区域的内存分配与回收具有确定性，因为当方法结束或者线程结束时，内存就自然跟着线程回收了</strong>。但是只有当主线程，及所有线程结束时，Java堆与方法区这两个区域才会被被完全回收，其声明周期跟随这个项目，或者主线程。</p><h2 id="3-1如何判断对象已”死“"><a href="#3-1如何判断对象已”死“" class="headerlink" title="3.1如何判断对象已”死“"></a>3.1如何判断对象已”死“</h2><p>Java堆中存放几乎所有对象实例，垃圾回收器在对堆进行垃圾回收前，首先要判断这些对象是否存活，那些已经”死去“，判断对象是否已“死”有如下几种算法</p><h3 id="3-1-1引用计数法"><a href="#3-1-1引用计数法" class="headerlink" title="3.1.1引用计数法"></a>3.1.1引用计数法</h3><p>引用计数法描述的算法为：</p><ul><li><h4 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h4><p>给对象增加一个引用计数器，每当有一个地方引用它的时候，计数器就+1，当引用失效的时，计数器就-1，任何时刻计数器为0的对象就是不再被使用的对象，即对象已“死”。</p><p>Python就采用了这个方法进行内存管理。</p></li><li><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p><strong>无法解决循环引用的问题</strong> ：</p><p>但是，在主流的JVM中并没有使用该方法来进行管理内存，<strong>主要原因是因为引用计数无法解决循环引用的问题</strong></p></li></ul><h3 id="3-1-2可达性分析算法-JVM采用"><a href="#3-1-2可达性分析算法-JVM采用" class="headerlink" title="3.1.2可达性分析算法-JVM采用"></a>3.1.2可达性分析算法-JVM采用</h3><p>JVM中采用“可达性分析算法”来判断对象是否存活（同样采用此方法的还有C#,Lisp-最早一门采用动态内存分配的语言）。</p><ul><li><h4 id="算法核心-1"><a href="#算法核心-1" class="headerlink" title="算法核心"></a>算法核心</h4></li></ul><p>通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到GC Roots 没有任何引用链连接时（从GC Roots到这个对象不可达）时,证明此对象是不可用的，以下图为例</p><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\GC Root可达性分析.png" alt="GC Root可达性分析"></p><p><strong>其中可达性分析在JVM中的使用时，判定以下对象可以作为一个根节点</strong>(GC Roots)</p><blockquote><ol><li>虚拟机栈（帧栈中的本地变量）<em>中引用对象（方法中的对象）</em> </li><li>方法区中类静态属性引用对象（<em>静态变量）-[局部变量（类的普通对象）除外]</em></li><li>方法区中常量引用对象（常量）</li><li>本地方法栈中JNI(Native)<em>引用的对象</em></li></ol></blockquote><p>JDK1.2以前，Java中引用的定义很传统，如果引用类型的数据中存储的数值代表的是另一块地址的起始地址，就称这块内存代表着一个引用，这种定义有些狭隘，一个对象在这种定义下只有被引用或者没有被引用这两种状态。</p><p>但是我们希望能描述这一类对象：当内存空间还足够时，能够保存在内存中；如果内存空间进行垃圾回收后还是非常紧张，则可以抛弃这一类对象。很多系统中的缓存对象都符合这个场景。</p><h4 id="引用扩充："><a href="#引用扩充：" class="headerlink" title="引用扩充："></a>引用扩充：</h4><p>在JDK1.2之后，java对引用的概念做了扩充。将引用分为</p><p>强引用（Strong Referrnce)</p><p>软引用（Soft Reference）</p><p>弱引用（Weak Reference）</p><p>虚引用（Phantom Reference)四种，这四种引用强度依次递减。</p><ul><li><p>强引用：</p><p>代码中普遍存在的，类似<strong>Object obj = new Object()</strong>;直接new出来的在JVM中只要强引用还存在，垃圾回收器就永远不会回收此类对象实例</p></li><li><p>软引用：</p><p>着力描述一些有用但是不必须的对象，对于仅被软引用指向的对象，<strong>在系统要发生内存溢出之前会将软引用对象进行垃圾回收，若内存够用，这些对象仍然被保留。</strong>在JDK1.2之后提供<strong>SoftReference类</strong>来实现软引用。</p></li><li><p>弱引用：弱引用也时用来描述非必须对象的。但是它的强度要比软引用更弱一点。<strong>被弱引用关联的对象只能生存到下一次垃圾回收发生之前</strong>。当垃圾回收器开始工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的对象。在JDK1.2之后提供了<strong>WeakReference类</strong>来实现弱引用</p></li><li><p>虚引用：虚引用也被称为幽灵引用或者幻影引用，他是<strong>最弱的一种引用关系</strong>，<strong>一个对象是否有虚引用的存在，完全不会对其生命周期时间构成影响</strong>。也无法通过虚引用来取得一个对象的实例，为了一个对象设置虚引用的<strong>唯一目的就是能在这个对象被回收器收到一个系统通知</strong>。在JDK1.2以后，提供了PhantomReference类来实现虚引用。（仅仅是一个通知 GC)</p></li></ul><h2 id="3-2对象自我拯救（已经过期了）"><a href="#3-2对象自我拯救（已经过期了）" class="headerlink" title="3.2对象自我拯救（已经过期了）"></a>3.2对象自我拯救（已经过期了）</h2><p>即便是可达性分析算法中不可达的对象，也并非“非死不可”，这时候他们暂处在“缓刑阶段”要宣告一个对象的真正死亡，至少需要经历两次标记的过程，如果对象在进行可达性分析之后发现没有与GC Roots相连接的引用链，那它将会被<strong>第一时间标记该对象</strong>，<strong>然后进行筛选</strong>，筛选的条件就是此对象是否有必要执行<strong>finalize()方法</strong>。当对象<strong>没有覆盖fianlize()方法</strong>或<strong>者finalize()方法已经被JVM调用过</strong>，虚拟机会将这两种情况视为“没有必要执行”，此时的对象才是真正“死”的对象。</p><p>如果对象被判定为有<strong>必要执行finalize()方法</strong>，那么这个对象会被放置在叫做<strong>F-Queue的队列当</strong>中，并在稍后由一个虚拟机自动建立的，低优先级的<strong>Finalizer线程</strong>去执行（这里所说的执行指的<strong>虚拟机会触发finalize()方法</strong>。<strong>finalize()方法时对象逃脱死亡的最后一次机会</strong>。稍后<strong>GC将对F-Queue中的对象</strong>进行<strong>第二次规模标记</strong>，如果<strong>对象finalize()中成功拯救自己</strong>(<em>只需要重新与引用链上的任何一个对象建立起关联关系即可)</em>，那在<strong>第二次标记时他将会被移除出“即将回收”的集合</strong>；如果对象这时候还是<strong>没有逃脱</strong>，<strong>那基本上它就是真的被回事收了</strong>。</p><p>总结宣告一个对象死亡要经历两次标记</p><ol><li><strong>第一次标记</strong> ：若对象在进行<strong>可达性分析</strong>之后发现到<strong>GC Roots不可达</strong>。此对象会进行一次<strong>finalize()</strong>。筛选的条件是此对象是否有必要执行finalize()方法，当对象没有被<strong>覆盖finalize()</strong>方法或者<strong>finalize()方法已经被JVM调用过</strong>（并不是人为的进行调用），那么<strong>JVM彻底宣告此对象死亡</strong>。</li><li>筛选成功（<strong>对象覆写了Object类的fianlize()方法，并且未被执行过</strong>），会将此对象<strong>放到F-Queue(唤醒队列)</strong> ，如果<strong>对象在finalize()中成功自救(此对象与GC Roots建立联系)</strong>，则对象在<strong>第二次标记时被移除回收集合，成功存活；</strong>若对象在finalize()中仍然与GC Roots不可达 ，宣告死亡。</li></ol><h2 id="3-3回收方法区"><a href="#3-3回收方法区" class="headerlink" title="3.3回收方法区"></a>3.3回收方法区</h2><p><strong>方法区（永久代）的垃圾回收</strong>主要回收的是两部分</p><ol><li>废弃的常量</li><li>无用的类</li></ol><h3 id="3-3-1回收废弃的常量"><a href="#3-3-1回收废弃的常量" class="headerlink" title="3.3.1回收废弃的常量"></a>3.3.1回收废弃的常量</h3><p>回收废弃的常量和回收Java堆中的对象十分类似。以常量池中字面量(直接量)的回收为例，假如一个字符串“abc”已经进入常量池，但是当前系统没<strong>有任何一个String对象引用常量池的”abc“常量</strong>，也没有再其他地方引用这个字面量。<strong>如果发生GC且有必要的化（方法区不够用才会执行）</strong>，这个”abc“常量会被系统清理出常量池。<strong>常量池中的其他类(接口)，方法，字段的符号引用也于此类似。</strong></p><h3 id="3-3-2判断一个类是否是无用类"><a href="#3-3-2判断一个类是否是无用类" class="headerlink" title="3.3.2判断一个类是否是无用类"></a>3.3.2判断一个类是否是无用类</h3><ol><li>该类的<strong>所有实例都已经被回收了</strong>    <em>(Java堆中不存在该类的任何实现)</em></li><li>加载该类的<strong>类加载器已经被回收</strong> </li><li>该类的<strong>class对象没有任何其他地方被引用，也无法通过反射访问该类的所有内容。</strong></li></ol><p>JVM可以对同时满足上述3个条件的无用类进行回收，也仅仅是可以而不是必然会回收，大量使用反射，动态代理等场景都需要对JVM具备类型卸载的功能来防止永久代溢出。</p><h1 id="四、垃圾回收算法"><a href="#四、垃圾回收算法" class="headerlink" title="四、垃圾回收算法"></a>四、垃圾回收算法</h1><h2 id="4-1标记-清除算法"><a href="#4-1标记-清除算法" class="headerlink" title="4.1标记-清除算法"></a>4.1标记-清除算法</h2><ul><li><p><strong>算法核心：</strong></p><p>整个算法分为标记-清除两个阶段</p><p><em>标记阶段</em>：标记出垃圾回收需要的回收对象</p><p><em>清除阶段</em>：一次性清除所有带标记的对象</p></li><li><p><strong>导致的问题</strong>：java不采用标记清除算法</p><ol><li><p>效率问题：</p><p>标记与清除两个阶段<strong>效率都不高</strong></p></li><li><p>空间问题：</p><p>标记清除算法<strong>会产生大量的不连续空间</strong>，导致的主要问题是，若程序中<strong>需要分配较大的连续对象时，由于空间碎片较多时因此无法找到连续的内存空间而不得已再次触发GC。</strong> </p></li></ol></li></ul><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\标记清除算法图解.png" alt=""></p><h2 id="4-2复制算法（新生代垃圾回收算法）"><a href="#4-2复制算法（新生代垃圾回收算法）" class="headerlink" title="4.2复制算法（新生代垃圾回收算法）"></a>4.2复制算法（新生代垃圾回收算法）</h2><p>复制算法是为了解决：标记-清除算法的效率问题。</p><ul><li><p><strong>核心思想：</strong></p><p>将内存<strong>按照容量划分成大小相等的两块</strong>，每次只<strong>使用其中一块内存</strong>，当使用的内存需要进行垃圾回收时，会将此区域的所有<strong>存活对象一次性复制到保留区域</strong>。然后<strong>将使用的内存块一次清理掉</strong>。</p><p>这样的做的好处是每次都对整个半区进行内存回收，内存分配时，就不需要考虑内存碎片等复杂情况，只需要移动堆定指针，按顺序分配即可，此算法实现简单，运行高效。算法的执行流程如下图：</p></li></ul><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\复制算法图解.png" alt="复制算法图解"></p><p>商用虚拟机（包括HotSpot都是采用这种收集算法来回收新生代）</p><ul><li><p><strong>导致问题：</strong> </p><p>复制算法最大的问题在于内存利用率太低，所有商用JVM都对复制算法进行了改进</p></li></ul><p><strong>JVM改进后的复制算法：</strong> </p><p>新生代中98%的对象“朝生夕死”（生命周期短），所以<strong>并不需要按照1：1来划分内存空间</strong>。将内存（<strong>新生代内存）划分为一块较大的Eden（伊甸区）空间</strong></p><p>和<strong>两块较小的Survivor(幸存区)（一块称为Fron区，另一个称为To区）空间</strong>。<strong>每次只是用Eden区和其他一块Suvivor</strong>。当回收时，将Eden和Survivor中<strong>还存活的对象一次性复制到另一块Survivor空间上</strong>，最<strong>后清理掉Eden和使用过的其中一个Survivor空间。</strong></p><p>当Survivor空间不够时，需要依赖其他<strong>内存（老年代）进行分配担保</strong>。</p><p>HotSpot默认Eden与一块Survivor的大小比例是<strong>8:1</strong>，也就是说<strong>Eden:From:To = 8:1:1</strong>。所以每次新生代<strong>可用内存空间为整个新生代容量的90%</strong>,而剩下的<strong>10%用来存放回收后存活的对象</strong>。</p><h4 id="HotSpot复制算法的流程："><a href="#HotSpot复制算法的流程：" class="headerlink" title="HotSpot复制算法的流程："></a>HotSpot复制算法的流程：</h4><ol><li><p>当Eden区满的时候，会触发一次Minor GC，将所有存活对象拷贝到Survivor的From区域，然后一次性清除Eden区；</p></li><li><p>当Eden区再次触发Minor GC,会扫描Eden区和From区，将两块空间的存活对象拷贝到To区，然后一次性清空Eden区和From区</p></li><li><p>当后续Eden区再次发生Minor GC时，会对Eden和To区进行垃圾回收，存活对象移动到From区，后续流程类似，只是将From区和To区作为保留区。</p></li><li><p>部分对象会在From区和To区来回复制，如此交换15次（JVM参数-XX:Max Teburing Threshold,默认为15），最终一直在移动的对象最终会存入老年代。（父债子偿）</p></li><li><p>Survivor区域若无法放下所有存活对象，需要依赖其他内存，如老年代内存进行分配担保。</p><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\复制算法在JVM的应用.png" alt="复制算法在JVM的应用"></p></li></ol><h2 id="4-3标记-整理算法（老年代垃圾回收算法）"><a href="#4-3标记-整理算法（老年代垃圾回收算法）" class="headerlink" title="4.3标记-整理算法（老年代垃圾回收算法）"></a>4.3标记-整理算法（老年代垃圾回收算法）</h2><p>复制收集算法在对<strong>象存活率较高时</strong>会进行比较多的复制操作，效率会变低。因此在老年代一般不能使用复制算法。</p><ul><li><strong>算法核心</strong></li></ul><p>针对老年代的特点，提出了一种称之为“标记-整理算法”。标记过程仍与“标记-清除”过程一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。流程图如下：</p><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\标记整理算法流程图.png" alt="标记整理算法流程图"></p><h2 id="4-4分代收集算法"><a href="#4-4分代收集算法" class="headerlink" title="4.4分代收集算法"></a>4.4分代收集算法</h2><p>当前JVM垃圾收集器都采用的是“分代收集算法”，这个算法并没有新思想，只是根据<strong>对象存活周期的不同</strong>将内存划分几块。</p><p><strong>一般是把Java堆分为新生代和老年代。</strong></p><ul><li><p>在新生代中，每次垃圾回收都会有大批对象死去，只有少量存活，因此我们采用复制算法；</p></li><li><p>而老年代中对象存活率高，没有额外空间对它进行分配担保，就必须采用“标记-清除”或者“标记-整理“算法。</p></li></ul><p>面试题：请问了解Minor GC和Full GC么，这两种GC有什么不一样。</p><blockquote><ol><li>Minor GC 又称为新生代GC：指的是发生在新生代的垃圾回收，因为Java对象大多都具有朝生夕死的特性，因此Minor GC采用复制算法非常频繁，一般回收速度也比较快。</li><li>Full GC又称为老年代GC或者Major GC:指的是发生在老年代的垃圾回收，出现了Major GC，经常会伴随至少一次Minor GC（并非绝对，在Parallel Scavenge收集器中就有直接Full GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ol></blockquote><p>直接进行Full GC 大对象直接扔到老年代中，假如老年代也满了，就直接进行老年代的垃圾回收</p><h2 id="4-5垃圾收集器（根据JDK版本不同具体实现不同）-JDK8"><a href="#4-5垃圾收集器（根据JDK版本不同具体实现不同）-JDK8" class="headerlink" title="4.5垃圾收集器（根据JDK版本不同具体实现不同）-JDK8"></a>4.5垃圾收集器（根据JDK版本不同具体实现不同）-JDK8</h2><h3 id="4-5-1JVM调优部分"><a href="#4-5-1JVM调优部分" class="headerlink" title="4.5.1JVM调优部分"></a>4.5.1JVM调优部分</h3><p>垃圾回收器也分为<strong>两代</strong></p><p><strong>新生代垃圾回收器：</strong>Serial(串行)，ParNew(并行)，Parallel(并行)，Scavenge(并行)</p><p><strong>老年代垃圾回收器：</strong>CMS，Serial Old,Parallel Old</p><p><strong>串行(Serial ,Serial Old):</strong>垃圾回收线程与用户线程在JVM中顺序执行（其中一个执行，都在等待）。</p><p><strong>并行(Paraller,Scavenge,Parallel old):</strong>多个垃圾回收线程一起执行，用户线程仍处于等待。</p><p><strong>并发(CMS):</strong>这才是真正意义上的垃圾回收线程与用户线程一起执行。CMS是第一款垃圾回收器</p><p><strong>全区域垃圾回收器</strong>：G1（并发）</p><p><strong>STW</strong>:当垃圾回收线程工作，用户线程处于等待状态</p><h2 id="五、对象分配策略"><a href="#五、对象分配策略" class="headerlink" title="五、对象分配策略"></a>五、对象分配策略</h2><h3 id="5-1对象有现在Eden分配"><a href="#5-1对象有现在Eden分配" class="headerlink" title="5.1对象有现在Eden分配"></a>5.1对象有现在Eden分配</h3><p>大多数情况下，对象在<strong>新生代Eden区分配</strong>。当Edem区<strong>没有足够的空间进行分配</strong>时，虚拟机将发生一次<strong>Minor GC</strong></p><p><strong>-Xss:栈大小</strong></p><p><strong>-Xms:堆最小内存</strong></p><p><strong>-Xmx:堆最大内存</strong></p><p><strong>-Xmm:新生代内存大小</strong></p><p>-<strong>XX:+survivorRatio=8:Eden区和Survivor区比例-默认是8</strong></p><h2 id="5-2大对象直接进入老年代"><a href="#5-2大对象直接进入老年代" class="headerlink" title="5.2大对象直接进入老年代"></a>5.2大对象直接进入老年代</h2><p>Java典型的大对象就是那种很长的字符串以及数组</p><p>设置大对象标准：</p><p><strong>-XX:PretenureSiveThreadhold = 字节大小（告诉JVM超过该字节大小的对象为对象，内存分配时直接进入老年代</strong></p><p><strong>这样做的目的是</strong>：在于避免Eden区以及Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）</p><h2 id="5-3长期存活对象进入老年代"><a href="#5-3长期存活对象进入老年代" class="headerlink" title="5.3长期存活对象进入老年代"></a>5.3长期存活对象进入老年代</h2><p>JVM给堆中的每个对象定义了一个堆中<strong>年龄（Age)计数器</strong></p><p><strong>若对象在Eden出生并且经历了一次Minor GC后仍存活且能被Survivor区容纳，将此对象的年龄置为1.此后对象在Survivor区内经历一次Minor GC，年龄就增加一岁，当其年龄增加到一定程度（默认为15），此对象晋升为老年代。</strong> </p><p>晋升为老年代的阈值，可以通过以下参数设置：</p><p><strong>-XX:Max Teburing Threshold</strong> </p><h2 id="5-4动态年龄对象判定"><a href="#5-4动态年龄对象判定" class="headerlink" title="5.4动态年龄对象判定"></a>5.4动态年龄对象判定</h2><p>为了更好的适应内存状态，JVM并不是永远要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代。如果在<strong>Survivor空间中相同年龄的对象大小的总和</strong>大于<strong>Survivor空间（一个Survivor空间）的一半</strong>，<strong>年龄大于或的等于该年龄的对象就可以直接进入老年代，</strong>无<strong>需等到MaxTenuringThreshold中要求的年龄。</strong></p><h2 id="5-5空间分配担保"><a href="#5-5空间分配担保" class="headerlink" title="5.5空间分配担保"></a>5.5空间分配担保</h2><p>在发生Minor GC之前，虚拟机会检查<strong>老年代最大可用的连续空间</strong>是否<strong>大于新生代所有对象的总空间。</strong> </p><ul><li><p><strong>如果大于：</strong>则此次Minor GC是安全的。</p></li><li><p><strong>如果小于：</strong>则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败</p><p>如果HandlePromotionFailure=true，那么会继续检查老年代最大可以可用连续内存是否大于此前晋升到老年代的对象的平均大小，如果大于，则尝试进行一次Minor GC，<strong>但是这次Minor GC依然是有风险的；</strong> 如果小于或者HandlePromotionFailure=false，则改为进行一次<strong>FUll GC</strong> </p></li></ul><p>上面提到了Minor GC依然会有风险，是因为新生代采用<strong>复制收集算法</strong>，假如大量对象共在Minor GC后任然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代中。<strong>老年代要进行空间分配担保，前提是老年代得有足够的空间来容纳这些对象</strong>，但一共有多少个对象在内存回收后活下来是不可预知的。<strong>因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考</strong>。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p><p>取平均值仍然是一种<strong>概率事件</strong>，如果某次Minor GC后存活的对象陡然增加，远高于平均值的话，必然导致担保失败，如果出现分配担保失败，<strong>就只能在失败后发起一次Full GC</strong>。虽然存在发生这种情况的概率，但是<strong>大部分时候都能够成功分配担保</strong>的，这样就<strong>避免了过于频繁的执行Full G</strong>C。</p><h1 id="六、常用JVM性能监控与故障处理工具"><a href="#六、常用JVM性能监控与故障处理工具" class="headerlink" title="六、常用JVM性能监控与故障处理工具"></a>六、常用JVM性能监控与故障处理工具</h1><h2 id="6-1JDK命令行工具"><a href="#6-1JDK命令行工具" class="headerlink" title="6.1JDK命令行工具"></a>6.1JDK命令行工具</h2><p>“javac” ，“java”   命令实际上都是JDK/bin目录下的命令行程序，除此之外，<strong>bin目录</strong>下还包含用于监控JVM和故障处理的工具</p><p>用于<strong>处理应用程序性问题，定位故障</strong>发挥了很大的作用。</p><table><thead><tr><th>命令名称</th><th>全称</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td>jps</td><td>JVM Process Status Tool</td><td style="text-align:left">显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td>jstat</td><td>JVM Statistics Monitoring Tool</td><td style="text-align:left">用于收集Hotspot虚拟机各方面的运行数据</td></tr><tr><td>jinfo</td><td>Conﬁguration Info for Java</td><td style="text-align:left">显示虚拟机配置信息</td></tr><tr><td>jmap</td><td>JVM Memory Map</td><td style="text-align:left">生成虚拟机的内存转储快照，生成heapdump文件</td></tr><tr><td>jhat</td><td>JVM Heap Dump Browser</td><td style="text-align:left">用于分析heapdump文件，他会建立一个HTTP/HTML服务器，让用户在浏览器上查看分析结果</td></tr><tr><td>jstack</td><td>JVM Stack Trace</td><td style="text-align:left">显示虚拟机的线程快照</td></tr></tbody></table><h3 id="6-1-1-jps：虚拟机进程工具"><a href="#6-1-1-jps：虚拟机进程工具" class="headerlink" title="6.1.1 jps：虚拟机进程工具 ~~"></a>6.1.1 jps：虚拟机进程工具 ~~</h3><p><strong>功能：</strong></p><blockquote><p>可列出正在运行的虚拟机进程，并显示虚拟机执行主类（main函数所在的类）名称以及这些进程的<strong>本地虚拟机唯一ID</strong>（Local Virtual Machine Identiﬁer,<strong>LVMID</strong>)。其他的JDK工具大多数需要输入jps查询到LVMD来确定要监控的虚拟机进程。</p></blockquote><p>jps命令格式：<code>jps[options] [hostid]</code></p><p>hostid 可用于查询开启RMI服务的远程虚拟机状态，hostid为RMI注册的主机名</p><p>options有：</p><table><thead><tr><th>options 参数</th><th>意义</th></tr></thead><tbody><tr><td>-q</td><td>只输出LVMD，忽略主类名称</td></tr><tr><td>-m</td><td>输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td>-l</td><td>输出主类全名，如果进程执行的是jar,输出jar路径</td></tr><tr><td>-v</td><td>输出虚拟机进程启动时JVM参数</td></tr></tbody></table><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\jps指令.png" alt="jps指令"></p><h3 id="6-1-2jstat：虚拟机统计信息监视器工具"><a href="#6-1-2jstat：虚拟机统计信息监视器工具" class="headerlink" title="6.1.2jstat：虚拟机统计信息监视器工具"></a>6.1.2jstat：虚拟机统计信息监视器工具</h3><p><strong>功能：</strong></p><blockquote><p>用于监控虚拟机各种运行状态信息的命令行工具，它可以显<strong>示本地或远程虚拟机中的类的装载，内存，垃圾回收，JIT编译等运行数据</strong>。在没有GUI图形界面，只提供纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首先工具。</p></blockquote><p>jstat命令格式为：<code>jstat [option vmid[interval count]]</code> </p><p>如果是本地虚拟机进程VMID与LVMID是一致的，如果是远程虚拟机进程，那么VMID格式因该为：</p><p><code>[protocol:][//]lvmid[@hostname[:port]/severname]</code></p><p>参数<strong>interval和count代表查询间隔（单位ms/s）和 次数</strong>，如果省略这两个参数，则默认只查询一次</p><p>选项option代表<strong>用户希望查询的虚拟机信息</strong>，主要分为三类：<strong>类装载，垃圾收集，运行期编译</strong>等状况，具体选项作用如下：</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-class</td><td>监视<strong>类装载，卸载次数，总空间以及装载类所消耗的时间</strong></td></tr><tr><td>-gc</td><td>监视<strong>java堆状况，包括Eden区，两个Survivor区，老年代，元空间等的容量，已用空间，GC时间合计等信息</strong></td></tr><tr><td>-gccapacity</td><td>监视内容与-gc基本相同，但是输出为主要关注<strong>java堆各个区域使用到的最大，最小空间</strong></td></tr><tr><td>-gcutil</td><td>监视内容与-gc基本相同，但是输出主要<strong>关注已使用空间占总空间的百分比</strong></td></tr><tr><td>-gccause</td><td>于gcutil功能一样，但是会额外输出<strong>导致上一次GC产生的原因</strong></td></tr><tr><td>-gcnew</td><td>监视<strong>新生代GC状况</strong></td></tr><tr><td>-gcnewcapacity</td><td>监视内容于-gcnew基本相同，输出主要<strong>关注新生代使用到的最大，最小空间</strong></td></tr></tbody></table><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\jstat指令.png" alt="jstat指令"></p><h3 id="6-1-3jinfo：Java配置信息工具"><a href="#6-1-3jinfo：Java配置信息工具" class="headerlink" title="6.1.3jinfo：Java配置信息工具"></a>6.1.3jinfo：Java配置信息工具</h3><p><strong>功能：</strong> </p><blockquote><p>jinfo用于<strong>查看和调整虚拟机的配置参数</strong></p></blockquote><p>jinfo的命令格式为：</p><p><code>jinfo[option] vmid</code></p><table><thead><tr><th>option</th><th>作用</th></tr></thead><tbody><tr><td>-flag</td><td>查询线程的参数</td></tr></tbody></table><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\jinfo指令.png" alt="jinfo指令"></p><p>我们可以用info -flags来查询线程的参数，其中的Non-default VM flags为虚拟机的设置参数，Command line为用户自行设置的参数</p><h2 id="6-1-4jmap：java内存映像工具"><a href="#6-1-4jmap：java内存映像工具" class="headerlink" title="6.1.4jmap：java内存映像工具"></a>6.1.4jmap：java内存映像工具</h2><p><strong>功能：</strong> </p><blockquote><p>生成堆转储快照(一般称为heapdump或<strong>dump文件</strong>)。如果不使用jmp命令，要想获取Java堆转储快照，还有一些比较暴力的手段：譬如在之前用过的。</p></blockquote><blockquote><p>XX+:HeapDumpOnOutOfMemoryError参数，可以让虚拟机在OOM异常出现之后自动生成dump文件。                          </p><p>jmap的作用并不仅仅为了获取dump文件，它还可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率，当前使用的是那种收集器。</p></blockquote><p>jmap的命令格式：</p><p><code>jmap[option] vmid</code></p><p>option的常用选项及作用见下表</p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-heap</td><td>显示jvm heap详细信息</td></tr><tr><td>-histo</td><td>显示jvm heap中对象统计信息，包括类，实例数量，合计容量,包括对象数组和所占空间大小</td></tr><tr><td>-dump</td><td>生成java堆转储快照。格式为：-dump:[live],format=b,file=filename，其中live子参数说明是否只dump存活的对象</td></tr></tbody></table><h3 id="6-1-5jhat：虚拟机转存储快照分析工具"><a href="#6-1-5jhat：虚拟机转存储快照分析工具" class="headerlink" title="6.1.5jhat：虚拟机转存储快照分析工具"></a>6.1.5jhat：虚拟机转存储快照分析工具</h3><p>与jmap命令搭配使用，用于分析jmap生成的堆转存储快照，jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览中查看。实际工作中使用jhat的几率并不大，因为分析dump文件的工作是一个<strong>耗时且消耗硬件资源的过程</strong>，一般不会在部署机器上分析；<strong>二是jhat分析功能相对来说比较简陋，我们可以使用Visual VM或者MAT等工具实现比jhat更强大更专业的分析功能。</strong></p><p>当屏幕上显示“Sever is ready”后，用户在浏览器中输入“<a href="http://localhost:7000”就可以看到分析结果" target="_blank" rel="noopener">http://localhost:7000”就可以看到分析结果</a></p><h3 id="6-1-6jstack：Java堆栈跟踪工具"><a href="#6-1-6jstack：Java堆栈跟踪工具" class="headerlink" title="6.1.6jstack：Java堆栈跟踪工具"></a>6.1.6jstack：Java堆栈跟踪工具</h3><p>功能：</p><blockquote><p>虚拟机当前时刻的<strong>线程快照</strong>。线程快照指的是当前虚拟机内的每一条<strong>线程正在执行的方法堆栈的集合</strong>，生成线程快照的作用是，可用于定<strong>位线程出现长时间停顿的原因</strong>，如<strong>线程间死锁</strong>，<strong>死循环</strong>，<strong>请求外部资源导致的长时间等待问题</strong>，当线程出现<strong>停顿</strong>时，就可以用jstack各个线程调用的堆栈情况。</p></blockquote><p><code>jstack[option] vmid</code> </p><p><strong>option:</strong> </p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-F</td><td>当正常输出的请求不被响应时，<strong>强制输出线程堆栈</strong></td></tr><tr><td>-l</td><td>除堆栈外，显示关于<strong>锁的附加信息</strong></td></tr><tr><td>-m</td><td>如果调用到本地方法的话，可以线程C/C++的堆栈</td></tr></tbody></table><h1 id="七-Java内存模型"><a href="#七-Java内存模型" class="headerlink" title="七.Java内存模型"></a>七.Java内存模型</h1><p>JVM定义了一致java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都达到一致的内存访问效果。</p><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在J<strong>VM中将变量存储到内存中和从内存中取出变量的底层细节。</strong>（<strong>此处的变量包括实例字段，静态字段和构成数组对象的元素</strong>）,不包括局部变量和方法参数，因为这两个线程私有，不会被线程共享。</p><h2 id="7-1主内存与工作内存"><a href="#7-1主内存与工作内存" class="headerlink" title="7.1主内存与工作内存"></a>7.1主内存与工作内存</h2><p>工作内存：每个线程独有</p><p>主内存：所有线程共享内存。（堆（大部分），方法区，运行时常量池）</p><p>Java内存模型规定了<strong>所有变量都存储在主内存中</strong>，<strong>每条线程还有的自己的工作内存</strong> ，线程<strong>工作内</strong> 存保存了线程使用到的<strong>变量的主内存副本拷贝</strong>。线程对<strong>变量的所有操作（读取，赋</strong>值等）都必须在<strong>工作内存中进行</strong>，而<strong>不能直接读写到主内存中的变量</strong>。不同线程也<strong>无法直接访问对方工作内存中的变量</strong>，线程间变量值的传递<strong>均需要通过主内存</strong>来完成。</p><p><img src="/2019/01/28/再识Java-JVM/hexo\source\_posts\再识Java-JVM\线程主内存工作内存.png" alt="线程，主内存，工作内存关系"></p><h2 id="7-2内存间的交互操作"><a href="#7-2内存间的交互操作" class="headerlink" title="7.2内存间的交互操作"></a>7.2内存间的交互操作</h2><p><strong>主内存与工作内存之间的具体交互协议</strong>，即一个变量如何从主内存中拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，java内存模型中定义了如下8中操作来完成。JVM实现时必须保证下面提及的<strong>每种操作是的原子的，不可再分隔的。</strong></p><ul><li><strong>lock(锁定)：</strong>作用于主内存的变量，它把一个变量标识为一个线程独占的状态   <strong>指令级别的锁</strong> </li><li><strong>unlock(解锁)：</strong>作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。     </li><li><strong>read(读取)  :</strong> 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。        </li><li><strong>load(载入) :</strong> 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><strong>use(使用) :</strong> 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎。 </li><li><strong>assign(赋值) :</strong> 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量。 </li><li><strong>store(存储) :</strong> 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便后续的write操作 使用。 </li><li><strong>write(写入) :</strong>  作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p>Java内存模型三大特性：</p><ol><li><p><strong>原子性：</strong>由java内存模型来直接保证原子性变量的操作，read,load use store assign 大致可以r认为。基本数据类型的访问式原子的。如若需要更大范围的原子性，需要synchorized关键字约束。（即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行）</p></li><li><p><strong>可见性：</strong>可见性指的式当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改。volatile,synchronized,final三个关键字可以实现可见性。</p></li><li><p><strong>有序性：</strong>如果在本线程内观察所有操作都是有序的，若在线程外观察另一个线程所有操作都是无序的。前半句是指“线程内表现为串行”，后半句是指“指令重拍”和“工作内存与主内存同步延迟现象”。</p><p>tips:<strong>这里的有序性指的是，逻辑上的有序</strong>，即保证执行结果最总不改变，操作先后次序改变不影响最终结果就称有序性。</p></li></ol><p>   JVM具备先天的有序性，即无须通过任何手段都能够保证有序性，称为JVM的happen-before原则，若两个操作的次序无法从happen-bvefore中推导出来，则无法保证其有序性，JVM可以随意对其进行重排序。</p><h3 id="happens-before-先行发生原则"><a href="#happens-before-先行发生原则" class="headerlink" title="happens-before(先行发生原则)"></a>happens-before(先行发生原则)</h3><ul><li><p><strong>程序次序规则：</strong>一个线程内，按照代码顺序，<strong>书写在前面的操作 </strong> 先发生子于 <strong>书写在后面</strong>的操作</p></li><li><p><strong>锁定规则：</strong>一个<strong>unlock操作先行</strong> 发生于 后面<strong>对同一个锁的lock操作</strong></p></li><li><p><strong>volatile变量规则：</strong>对一个变量的<strong>写擦操作</strong> 先发生于 <strong>后面对这个变量的读操作</strong></p></li><li><p><strong>传递规则：</strong>如果操作A 先生于 操作B,而操作B又 先发生于 操作c,则可以得出<strong>操作A</strong> 先发生于 <strong>操作C</strong></p></li><li><p><strong>线程启动规则：</strong>Thread对象的<strong>start()方法调用</strong> 先行发生于 <strong>被中断的代码检测到中断事件的发生</strong>。</p></li><li><p><strong>线程中断规则：</strong>对线程<strong>interrupt()方法调用</strong> 先发生于 <strong>被中断线程的代码检测到中断事件的发生。</strong></p></li><li><p><strong>线程终结规则</strong> ：<strong>线程中所有的操作都</strong>先发生于<strong>线程的终止检测</strong>，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值手段检测到线程已经终止执行。</p></li><li><p><strong>对象终结规则：</strong>一个<strong>对象的初始化完成</strong>先行发生于它的<strong>finalize()方法的开始</strong>。</p></li></ul><p>  也就是说，要向并发程序正确的执行，必须要保证原子性，可见性，以及有序性。只要一个没有被保证，就有可能导致程序运行不正常。</p><h2 id="7-3volatile型变量的特殊规则"><a href="#7-3volatile型变量的特殊规则" class="headerlink" title="7.3volatile型变量的特殊规则"></a>7.3volatile型变量的特殊规则</h2><p>关键字volatile可以说是JVM提供的最轻量级的同步机制，JVM内存模型对volatile专门定义了一些特殊访问规则。</p><p>当一个变量被定义为volatile之后，它具备两种特性。可见性和有序性</p><p>两层语义：</p><ul><li><strong>第一层语义：</strong>内存可见–可见性</li><li><strong>第二层语义：</strong>禁止指令重排–有序性</li></ul><p><strong>可见性：</strong>当一个线程修改了这个变量的值，新值能被其他线程可以立刻得到，而普通变量做不到这一点，普通变量的值在线程之间传递需要通过主内存来完成。</p><p>具体来说，volatile的作用是：<strong>在本CPU对变量的修改直写入主内存中，同时这个写操作使得其他CPU中对应的变量的缓存行无效</strong>，<strong>这样其他线程在读取这个变量时候必须从主内存中读取，所以读取得到的是最新的</strong>，这就是上面说的能被立即“看到”。</p><p>volatile修饰的变量仅仅只拥有这两个性质，<strong>并不拥有原子性，volatile变量的运算在并发下是不安全的，原因java里面的运算并非原子操作。</strong></p><p>由于volatile只保证了可见习性和，有序性。子在不符合以下两条规则的运算场景中，我们仍然需要<strong>通过加锁(synchronized或lock)来保证原子性</strong></p><ol><li>运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改变量的值</li><li>变量不需要与其他的状态变量共同参与不变约束</li></ol><p><strong>并发场景下对于类似++操作如何保证原子性</strong></p><ul><li><strong>加锁，结合synchronized或者lock体系</strong></li><li><strong>使用原子类（java.util.current.atomic包下的所有类-内部使用CAS保证原子性）</strong></li></ul><p><strong>有序性：volatile可以禁止指令重排</strong> 。volatile在其汇编代码中有一个lock操作，这个操作相当一个<strong>内存屏障</strong>，<strong>指令重排不能越过内存屏障</strong>，具体来</p><ul><li><strong>说在执行volatile变量时，内存屏障之前的语句一定被执行过了且结果对后面执行的语句时已知的，而内存屏障后面的语句一定还没有执行到</strong>；</li><li>在进行指令优化时，<strong>在volatile变量之前的语句不能能被重排其之后，相反的其后的语句也必能被重排到之前。</strong></li></ul><!--more-->]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;区域划分-gt-判断对象是否存活-gt-垃圾回收器-gt-对象分配回收策略&quot;&gt;&lt;a href=&quot;#区域划分-gt-判断对象是否存活-gt-垃圾回收器-gt-对象分配回收策略&quot; class=&quot;headerlink&quot; title=&quot;区域划分-&amp;gt;判断对象是否存活-&amp;gt;垃圾回收器-&amp;gt;对象分配回收策略&quot;&gt;&lt;/a&gt;区域划分-&amp;gt;判断对象是否存活-&amp;gt;垃圾回收器-&amp;gt;对象分配回收策略&lt;/h1&gt;&lt;h2 id=&quot;重点&quot;&gt;&lt;a href=&quot;#重点&quot; class=&quot;headerlink&quot; title=&quot;重点&quot;&gt;&lt;/a&gt;重点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;JVM简介&lt;/li&gt;
&lt;li&gt;Java内存区域与内存溢出异常 &lt;/li&gt;
&lt;li&gt;垃圾回收器与内存分配策略 &lt;/li&gt;
&lt;li&gt;常用JVM性能监控与故障处理工具 &lt;/li&gt;
&lt;li&gt;Java内存模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;一、JVM简介&quot;&gt;&lt;a href=&quot;#一、JVM简介&quot; class=&quot;headerlink&quot; title=&quot;一、JVM简介&quot;&gt;&lt;/a&gt;一、JVM简介&lt;/h1&gt;&lt;p&gt;1）&lt;strong&gt;虚拟机简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JVM(java Virtual Machine简称。意味java虚拟机){&lt;/p&gt;
&lt;p&gt;虚拟机：指通过软件模拟的具有完整的硬件功能的、运行再一个完全隔离的环境中的完整计算机系统。&lt;/p&gt;
&lt;p&gt;常见虚拟机：JVM，VMware,Vitual BOX&lt;/p&gt;
&lt;p&gt;2）:JVM和其他两个虚拟机的区别：a.VMware与virtualBox【是通过软件模拟物理CPU的指令集物理系统中会有很多的寄存器&lt;/p&gt;
&lt;p&gt;2）：&lt;strong&gt;JVM是通过软件模拟java字节码的指令集，JVM中只保留了PC寄存器，其他寄存器都进行了剪裁，JVM是一台被定制过的现实当中不存在的计算机&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://soyanga.github.io/categories/JAVASE/"/>
    
    
      <category term="JavaSE基础" scheme="https://soyanga.github.io/tags/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java学习笔记" scheme="https://soyanga.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="https://soyanga.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>再识Java-02面向对象</title>
    <link href="https://soyanga.github.io/2019/01/28/%E5%86%8D%E8%AF%86Java-02%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://soyanga.github.io/2019/01/28/再识Java-02面向对象/</id>
    <published>2019-01-28T04:57:28.000Z</published>
    <updated>2019-02-01T06:06:01.422Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向过程编程缺少了可重用性设计</p><p>面向对象三大特征：</p><blockquote><ol><li><p>封装性：所谓封装性，就是把客观事物封装成了抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对于不可信的进行信息隐藏。简而言之就是，<strong>内部操作对外部而言不可见（保护性）</strong></p></li><li><p>继承性：继承是指这样的一种能力：它可以<strong>使现有类的所有功能</strong>，<strong>并在无需重信编写原来类的情况下对这些功能进行扩展</strong></p></li><li><p>多态性（*）：所谓多态就是指一个类实例的<strong>相同方法再不同的情形下有不同的表现形式</strong>。多态的机制使具有不同内部结构的对象可以共享相同的外部接口</p><p>利用多态可以得到良好的设计-&gt;</p></li></ol></blockquote><p>面向对象的最大特征：可以进行生活的抽象</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向对象&quot;&gt;&lt;/a&gt;面向对象&lt;/h1&gt;&lt;p&gt;面向过程编程缺少了可重用性设计&lt;/p&gt;
&lt;p&gt;面向对象三大特征：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;封装性：所谓封装性，就是把客观事物封装成了抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对于不可信的进行信息隐藏。简而言之就是，&lt;strong&gt;内部操作对外部而言不可见（保护性）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;继承性：继承是指这样的一种能力：它可以&lt;strong&gt;使现有类的所有功能&lt;/strong&gt;，&lt;strong&gt;并在无需重信编写原来类的情况下对这些功能进行扩展&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多态性（*）：所谓多态就是指一个类实例的&lt;strong&gt;相同方法再不同的情形下有不同的表现形式&lt;/strong&gt;。多态的机制使具有不同内部结构的对象可以共享相同的外部接口&lt;/p&gt;
&lt;p&gt;利用多态可以得到良好的设计-&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;面向对象的最大特征：可以进行生活的抽象&lt;/p&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://soyanga.github.io/categories/JAVASE/"/>
    
    
      <category term="JavaSE基础" scheme="https://soyanga.github.io/tags/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java学习笔记" scheme="https://soyanga.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OOP" scheme="https://soyanga.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>再识java-01</title>
    <link href="https://soyanga.github.io/2019/01/27/%E5%86%8D%E8%AF%86java-01/"/>
    <id>https://soyanga.github.io/2019/01/27/再识java-01/</id>
    <published>2019-01-27T13:40:41.000Z</published>
    <updated>2019-01-30T15:50:32.794Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="java再识"><a href="#java再识" class="headerlink" title="java再识"></a>java再识</h1><p>初始一见倾心，再识亦如初始。</p><p>​                                                        -java再识有感~</p><p><img src="/2019/01/27/再识java-01/图片\感悟.png" alt="感悟"></p><a id="more"></a><h2 id="Java标识符"><a href="#Java标识符" class="headerlink" title="Java标识符"></a>Java标识符</h2><p>变量，常量，函数，语句块</p><ul><li>标识符由字母，数字，下划线，$所组成，其中不能以数字开头，不能用Java中的保留字（关键字）</li><li>标识符采用有意义的简单命名</li><li>“$”不要在代码里出现</li></ul><p>对于类名和变量名，java的标准命名规范为<strong>“驼峰命名法”</strong> :camel:</p><p>对于类名，类名是以大写字母开头的名词：如果类名由多个单词组成，则每个单词的首字母大写。且源文件的文件名必须和公共类的名称相同</p><p>对于变量，如果只含有一个单词，则全部小写；如果变量名由多个单词组成，则从第二个单词开始，每个单词的首字母大写</p><p><strong>阿里编码规范：</strong></p><blockquote><ol><li>代码中的命名均不能以下划线或美元符号开始，也不能以下划线和美元结束。</li><li>代码命名严谨使用拼音与英文混合的方式，更不允许直接使用中文。</li><li><strong>类</strong>名使用<strong>UpperCamelCase风格</strong>，<strong>方法名，参数名，成员变量</strong>，<strong>局部变量</strong>统一采用<strong>lowerCamelCase风格</strong>。</li><li><strong>常量</strong>命名<strong>全部大写</strong>，<strong>单词间用下划线隔开</strong>。</li></ol></blockquote><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>大数据类型转换小数据类型，必须强转，但有时会有丢失内容</p><blockquote><ol><li>范围小的数据可以自动转变为数据范围大的数据类型（数学计算时）</li><li>数据范围大的数据类型只有强制转换时才能转换类型下的数据类型</li></ol></blockquote><p>关于数据的默认值，默认值在主方法中无效</p><h2 id="方法的定义与使用"><a href="#方法的定义与使用" class="headerlink" title="方法的定义与使用"></a>方法的定义与使用</h2><h3 id="2-1方法重载（重要）"><a href="#2-1方法重载（重要）" class="headerlink" title="2.1方法重载（重要）            ~~"></a>2.1方法重载（重要）            ~~</h3><p>定义：方法名称相同，参数类型或个数不同</p><p>方法的签名：指的是方法名与参数，<strong>返回类型不是签名的一部分</strong></p><p><strong>（im） 不能由两个名字相同，参数类型也相同却返回不同类型值得方法</strong></p><p>范例：重载方法实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        System.out.println(add(<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line">        System.out.println(add(<span class="number">5</span>,<span class="number">5</span>,<span class="number">55</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>开发原则：在进行方法重载得时候。要求：方法的返回值一定相同</strong></p><h2 id="2-2方法覆写（重要）"><a href="#2-2方法覆写（重要）" class="headerlink" title="2.2方法覆写（重要）"></a>2.2方法覆写（重要）</h2><h2 id="3-数组"><a href="#3-数组" class="headerlink" title="3.数组"></a>3.数组</h2><p>数组时引用类型，由内存分配问题：</p><h2 id="3-1数组的动态开辟"><a href="#3-1数组的动态开辟" class="headerlink" title="3.1数组的动态开辟"></a>3.1数组的动态开辟</h2><blockquote><ul><li>数组的动态初始化（声明并开辟数组）</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组类型[] 数组名称 = <span class="keyword">new</span> 数据类型[长度]</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>当采用动态数组初始化开辟空间后，数组的每个元素都是该数据类型的默认值；</li><li>数组本身是一个有序的集合操作，所以对于数组的内容操作往往采用循环的模式完成。（数组是一个有限的集合，采用for循环）</li></ol><h2 id="3-2数组的静态开辟"><a href="#3-2数组的静态开辟" class="headerlink" title="3.2数组的静态开辟"></a>3.2数组的静态开辟</h2><p>如果希望数组在定义的同时可以设置内容，那么就采用静态初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型[]数组名称 = <span class="keyword">new</span> 数据类型[]&#123;值，值，值...&#125;</span><br></pre></td></tr></table></figure><h2 id="4-对象数组"><a href="#4-对象数组" class="headerlink" title="4.对象数组"></a>4.对象数组</h2><p>对象数组往往是以引用数据类型为住的定义，例如：类，接口</p><p><strong>4.1对象数组的动态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名称[]对象数组名称 = <span class="keyword">new</span> 类名称[长度]</span><br></pre></td></tr></table></figure><p>动态初始化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;    </span><br><span class="line"><span class="keyword">private</span> String name ;     </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age ;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;       </span><br><span class="line"><span class="keyword">this</span>.name = name ;         </span><br><span class="line"><span class="keyword">this</span>.age = age ;     </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">System.out.println(<span class="string">"姓名："</span>+<span class="keyword">this</span>.name+<span class="string">",年龄："</span>+<span class="keyword">this</span>.age) ;    </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Person person = <span class="keyword">new</span> Person[<span class="number">3</span>];<span class="comment">//动态对象数组初始化，每个元素都是其对应数据类型的默认值</span></span><br><span class="line">per[<span class="number">0</span>] = <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">1</span>);</span><br><span class="line">per[<span class="number">1</span>] = <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">2</span>)；</span><br><span class="line">Per[<span class="number">2</span>] = <span class="keyword">new</span> Person(<span class="string">"王五"</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x= <span class="number">0</span> ;x&lt;per.length;x++)&#123;</span><br><span class="line">    per[x].getInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.2对象数组的静态初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名"</span>+<span class="keyword">this</span>.name+<span class="string">"年龄："</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Test&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mian</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    Person[]per = <span class="keyword">new</span> Person[]&#123;</span><br><span class="line">       <span class="keyword">new</span> Person(<span class="string">"张三"</span>,<span class="number">1</span>),</span><br><span class="line">       <span class="keyword">new</span> Person(<span class="string">"李四"</span>,<span class="number">2</span>),</span><br><span class="line">       Person(<span class="string">"王五"</span>,<span class="number">3</span>)</span><br><span class="line">    &#125;;<span class="comment">//对象数组静态初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x= <span class="number">0</span> ;x&lt;per.length;x++)&#123;</span><br><span class="line">    per[x].getInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Java对数组的常用操作"><a href="#5-Java对数组的常用操作" class="headerlink" title="5.Java对数组的常用操作"></a>5.Java对数组的常用操作</h2><ul><li><p>数组排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.Arrays.sort(数组名称)</span><br></pre></td></tr></table></figure><p>只要是基本数据类型的数组，sort都可以进行排序处理（升序处理）</p><p><strong>内部使用的是双轴快速排序</strong></p></li><li><p>数组的部分拷贝：指的是将一个数组的部分内容替换掉另一个数组的部分内容（连续的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(源数组名称，源数组的开始点，目标数组名称，目标数组的开始点，拷贝长度)；  </span><br><span class="line">拷贝长度：单位是元素个数</span><br></pre></td></tr></table></figure></li><li><p>数组的拷贝：返回值是一个  新数组（新开辟的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.Arrays.copyOf(源数组的名称，新数组的长度)</span><br></pre></td></tr></table></figure><p><strong>Java类集框架（动态数组）就采用此方法来动态扩容</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;java再识&quot;&gt;&lt;a href=&quot;#java再识&quot; class=&quot;headerlink&quot; title=&quot;java再识&quot;&gt;&lt;/a&gt;java再识&lt;/h1&gt;&lt;p&gt;初始一见倾心，再识亦如初始。&lt;/p&gt;
&lt;p&gt;​                                                        -java再识有感~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/01/27/再识java-01/图片\感悟.png&quot; alt=&quot;感悟&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JAVASE" scheme="https://soyanga.github.io/categories/JAVASE/"/>
    
    
      <category term="JavaSE基础" scheme="https://soyanga.github.io/tags/JavaSE%E5%9F%BA%E7%A1%80/"/>
    
      <category term="Java学习笔记" scheme="https://soyanga.github.io/tags/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Maven初识</title>
    <link href="https://soyanga.github.io/2019/01/25/Maven%E5%88%9D%E8%AF%86/"/>
    <id>https://soyanga.github.io/2019/01/25/Maven初识/</id>
    <published>2019-01-24T16:09:18.000Z</published>
    <updated>2019-02-19T03:56:42.871Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Maven简介和安装"><a href="#Maven简介和安装" class="headerlink" title="Maven简介和安装"></a>Maven简介和安装</h1><p>了解Maven是什么，作什么、且安装</p><p><a href="http://maven.apache.org/是一个综合的项目管理和综合工具。基于项目对象模型（POM）的概念，Maven可以从一个中心资料片（pom.xml）管理和项目构建，报告和文件。" target="_blank" rel="noopener">http://maven.apache.org/是一个综合的项目管理和综合工具。基于项目对象模型（POM）的概念，Maven可以从一个中心资料片（pom.xml）管理和项目构建，报告和文件。</a></p><p>提供了开发人员构建一个完整的生命周期框架。开发团队可以<strong>自动</strong>完成项目的基础工具建设，<strong>Maven使用标准的目录结构</strong>和<strong>默认构建生命周期</strong>（编译规则）。</p><p>在多人开发团队环境时，Maven可以设置按标标准在非常短的时间里完成配置工作。由于大部分项目的设置都非常检查，并且可以重复使用，Maven让开发人员更加轻松，同时创建报表，检查，构建和测试自动化设置。</p><p>Maven提供了开发人员的方式来管理：</p><ul><li>Builds（创建）</li><li>Documentation（文档）API文档</li><li>Reporting（报告）</li><li>Dependencies (依赖)   </li><li>SCM（软件配置管理）</li><li>Releases (发布) 版本号 Maven的中央仓库</li><li>Distribution (分布)</li><li>mailing list (邮件列表)</li></ul><p>概括来说，Maven<strong>简化和标准化项目建设过程</strong>。<strong>处理编译，分配，文档</strong>，<strong>团队协作和其他任务的无缝衔接。</strong>Maven增加可重用性并负责建立相关的任务。</p><a id="more"></a><p>学习Maven得理由是非常多</p><ul><li>主流IDE(Eclipse,IDEA,Netbean)够内置了Maven</li><li>SpringFramework已经不再提供jar得下载，直接通过Maven进行依赖下载</li><li>在github,开源社区几乎所有流行得java项目都是通过Maven进行构建管理</li><li>主流软件公司也在使用Maven</li></ul><h1 id="2安装"><a href="#2安装" class="headerlink" title="2安装"></a>2安装</h1><p>完成</p><p>mvn package 打包</p><p>mvn clean 删除target临时文件</p><p>java打包:命令    java -jar</p><p>usage: mvn[options] [&lt;goal(s)] [&lt;phase(s)</p><table><thead><tr><th>Options:</th><th></th></tr></thead><tbody><tr><td>-D , –define <arg></arg></td><td>定义系统属性</td></tr><tr><td>-f,–file <arg></arg></td><td>强制指定pom.xml文件，默认为当前目录下的pom.xml</td></tr><tr><td>-h,–help</td><td>显示帮助信息</td></tr><tr><td>-P,–activate-profiles<arg></arg></td><td>逗号分隔活动的profiles列表</td></tr><tr><td>-q,–quiet</td><td>静默退出，只输出错误信息</td></tr><tr><td>-s,–setting <arg></arg></td><td>修改用户的setting.xml文件 读取顺序是 参数指定-&gt;用户目录/.m2/settings.xml-&gt;M3_HOME/conf/settings/xml</td></tr><tr><td>-v,–version</td><td>显示版本信息</td></tr><tr><td>-X,–debug</td><td>DEBUG模式输出处理日志</td></tr></tbody></table><h1 id="Maven实战"><a href="#Maven实战" class="headerlink" title="Maven实战"></a>Maven实战</h1><blockquote><ul><li>掌握Maven项目创建</li><li>掌握使用Maven构建java项目，Web项目</li></ul></blockquote><p>1.Maven创建java普通项目</p><p>mvn -B archetype:generate </p><p>-DarchetypeGroupID=org.apache.maven.archetypes</p><p>-DarchetypeArtifactID=maven-archetype-quicksrart （模名）</p><p>-DarchetypeVersion=1.1（模板版本号） （以上为一个快速的模板） -DgroupId=com.bittech.hello  (组织ID)</p><p>-artifactId=hello-app (项目名)   -version=1.0.0 （项目版本号）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -B archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.1 -DgroupId=com.bittech.hello -DartifactId=hello-app -Dversion=1.0.0</span><br></pre></td></tr></table></figure><p>版本号 ：主版本号.次版本号.小版本号</p><p>小版本号：修改BUG改动后的版本号。</p><p>次版本号：添加，修改功能。</p><p>次版本号：添加功能，修改功能</p><p>大版本号：产品发生很大的变化。</p><p>(项目名)artifactId.version(版本号).packaging(jar)</p><p>指令：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table><p>发布到中央仓库</p><p>​    申请中央仓库 search.maven.org</p><p>​    settings文件里配置仓库服务认证信息</p><p>​    pom。xml:设置发布仓库地址</p><p>​    申请发布到中央仓库。</p><p>​    申请通过后，进行构架发布</p><p>公司私服</p><p>​    申请公司私服账号</p><p>​    settings中配置仓库服务的认证信息</p><p>​    pom.xml 设置发布仓库地址</p><p>​    发布构建</p><ul><li>配置操作<ul><li>pom.xml中配置信息</li><li>settings.xml中配置信息</li></ul></li></ul><p>发布构件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure><h1 id="构建可执行jar"><a href="#构建可执行jar" class="headerlink" title="构建可执行jar"></a>构建可执行jar</h1><p>可执行的jar构建是指的通过java命令来执行运行jar构建，类似windows下的exe,Linux下的sh</p><p>在我们打包输出的hello-app-1.0.0 jar通过执行java -jar hello-app-1.0.0.jar输出信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;encoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">//构建可执行jar</span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span> //归档 java里面的</span><br><span class="line">                        </span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.soyanga.HelloApp3<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addExtensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addExtensions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="tag">&lt;<span class="name">Implementation-Title</span>&gt;</span></span><br><span class="line">                                $&#123;project.name&#125;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">Implementation-Title</span>&gt;</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="tag">&lt;<span class="name">Implementation-Version</span>&gt;</span></span><br><span class="line">                                $&#123;project.version&#125;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">Implementation-Version</span>&gt;</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="tag">&lt;<span class="name">Implementation-Vendor_Id</span>&gt;</span></span><br><span class="line">                                $&#123;project.groupId&#125;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">Implementation-Vendor_Id</span>&gt;</span></span><br><span class="line">                            </span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行打包命令，然后通过jave命令执行jar</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br><span class="line">java -jar target\hello-app<span class="number">-1.0</span><span class="number">.0</span>.jar</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>从上面的输出信息可以看出，我们打包输出的jar现在可以通过jave命令执行了。</p><p>2.Maven创 java Web项目</p><p>maven创建web项目和应用项目不同的是web项目的打包类型通常是war,以及web项目的目录中有webapp目录用来归档web页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -B archetype:generate -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-webapp -DarchetypeVersion=1.0 -DgroupId=com.bittech.hello -DartifactId=hello-app -Dversion=1.0.0</span><br></pre></td></tr></table></figure><p>2.2目录信息</p><h2 id="1-Maven管理目标"><a href="#1-Maven管理目标" class="headerlink" title="1.Maven管理目标"></a>1.Maven管理目标</h2><p>Maven的管理目标是工程，它是一个软件工程管理工具。对于maven来说，一个软件工程的唯一标识是由<strong>（标识项目写者）组标号（groupId）构件【项目】编号（artifadtId）,版本信息（version）</strong>共同决定的。每个工程都有一个<strong>打包类型</strong>(packaging)，可以是<strong>jar,war,ear或者pom</strong>.<strong>打包类型决定了工程最终产物的类型</strong>，其中<strong>pom类</strong>型用于构建<strong>多模块工程</strong>。工程之间由两种关系：<strong>继承和聚合</strong></p><h2 id="1-1工程依赖关系"><a href="#1-1工程依赖关系" class="headerlink" title="1.1工程依赖关系"></a>1.1工程依赖关系</h2><p>依赖关系的管理是maven最精髓的地方。一个工程可以依赖多个其他工程，通过过工程的唯一标识</p><p>（groupId+artifactId+version）可以明确指明依赖的库及版本，而且能够处理依关系的传递。maven可以指定依赖的作用范围（scope），包括以下几种：</p><table><thead><tr><th>scope</th><th>编译阶段</th><th>测试阶段</th><th>运行</th><th>备注</th></tr></thead><tbody><tr><td>compile</td><td>v</td><td>v</td><td>v</td><td>默认scope</td></tr><tr><td>test</td><td></td><td>v</td><td></td><td>只在测试期依赖，如junit包</td></tr><tr><td>provided</td><td>v</td><td>v</td><td></td><td>运行期由服务器提供，如servlet-api包</td></tr><tr><td>runtime</td><td></td><td>v</td><td>v</td><td>编译器件不需要直接引用</td></tr><tr><td>system</td><td>v</td><td>v</td><td></td><td>编译和测试时由本机环境提供</td></tr></tbody></table><p>maven的依赖关系管理解决了一下重要问腿：</p><ul><li>工程依赖的版本管理</li><li>工程依赖种同一个工程的多版本依赖的冲突问题 -优先高版本</li><li>提供了标准的依赖关系的定义 </li></ul><h2 id="1-2工程聚合与继承"><a href="#1-2工程聚合与继承" class="headerlink" title="1.2工程聚合与继承"></a>1.2工程聚合与继承</h2><p>聚合：pom类型的工程用于构建多模块的工程，这体现了project之间的一种聚合关系：将一系列小的模块聚合成整个产品。通过聚合后的工程可以同时管理每个模块的构建、清理、文档等工作。</p><p>继承：上文提到的pom类型的工程同样可以定义多模块的工程配置信息，其中作为模块的工程的父模块被多模块继承，此时多模块就是该pom类型的工程的子工程，子工程可以复用父工程的配置信息。</p><h1 id="2-Mave核心概念"><a href="#2-Mave核心概念" class="headerlink" title="2.Mave核心概念"></a>2.Mave核心概念</h1><h1 id="2-1Pom"><a href="#2-1Pom" class="headerlink" title="2.1Pom"></a>2.1Pom</h1><p>POM是指<code>porject object Model</code>。pom是一个xml，是maven工作的基础，在执行goal时，maven会去项目的根目录下读取pom.xml获得需要得<strong>配置信息.pom</strong>文件中包含了<strong>项目得信息</strong>和m<strong>aven build项目所需的配置信息</strong>，通常有<strong>项目信息（如版本，成员）</strong>，<strong>项目的依赖</strong>，<strong>插件和goal</strong>，<strong>bulid选项等</strong>等pom是<strong>可以继承</strong>的，通常对于一个大型项目或是多个module情况，<strong>子模块的pom需要指定父模块的pom</strong>。</p><blockquote><p>通过实际操作来讲述POM组成</p></blockquote><h2 id="2-2构件（artifact）"><a href="#2-2构件（artifact）" class="headerlink" title="2.2构件（artifact）"></a>2.2构件（artifact）</h2><p>构件就是一个项目将要产生的文件，可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都是由<strong>groupId:artifactId:version</strong>组成的标识符唯一识别。需要被使用（依赖）的artifact都放在仓库中。</p><p>artifact的标识也成为构件的坐标，<strong>groupId通常使用创建构件的组织名称或者域名的反转</strong>（比如 org.springframework）;<strong>artifactId是构件的名称</strong>，通常在一个组织创建的构件中是唯一的（比如：spring-4.0.9.RELEASE）</p><p>同一个构件的不同版本：</p><h2 id="2-3仓库"><a href="#2-3仓库" class="headerlink" title="2.3仓库"></a>2.3仓库</h2><p>仓库主要用于获取工程依赖的其他工程的生成物，也可以来部署（deploy）maven工程的生成物。生成物包括各种打包的生成物以及pom文件。如果有必要，一个工程可以部署多个仓库</p><p>仓库可以分为本地库(local)和远程仓库(remote)。本地库通常用于本机的~/.m2/repository文件夹（可以通过settings.xml中的localRepository进行修改），远程库最常见的是maven中央库，此外也会有一些私服库用于企业内部</p><p>常用的仓库列表：</p><ul><li>Maven在线检索：<a href="http://search.maven.org/" target="_blank" rel="noopener">http://search.maven.org/</a></li><li>中央仓库：<a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a></li><li>阿里：<a href="http://maven.aliyun.com/nexus/cotent/groups/public" target="_blank" rel="noopener">http://maven.aliyun.com/nexus/cotent/groups/public</a></li><li>开源中国：<a href="http://maven.oschina.net/content/groups/public" target="_blank" rel="noopener">http://maven.oschina.net/content/groups/public</a></li><li>Spring社区：<a href="http://maven.spingframework.org/relese" target="_blank" rel="noopener">http://maven.spingframework.org/relese</a></li></ul><h2 id="2-4构件生命周期（Bulid-Liftcycle）"><a href="#2-4构件生命周期（Bulid-Liftcycle）" class="headerlink" title="2.4构件生命周期（Bulid Liftcycle）"></a>2.4构件生命周期（Bulid Liftcycle）</h2><p>maven将工程的构键过程理解为<strong>不同的生命周期和阶段</strong>。在工程的构建过程中，<strong>存在着不同的生命周期，这些生命周期互相独立，之间也没有一定的顺序关系。在每个生命周期又划分为不同的阶段。阶段之间又明确的顺序关系，同一个生命周期内的阶段必须按顺序依次执行。</strong></p><p>maven内置了三个生命周期，并为每个生命周期内置了一些阶段。下面列举出maven内置的生命周期及主要的阶段</p><p>default</p><p>clean</p><p>site</p><h2 id="2-5目标（goal）和插件（plugin）"><a href="#2-5目标（goal）和插件（plugin）" class="headerlink" title="2.5目标（goal）和插件（plugin）"></a>2.5目标（goal）和插件（plugin）</h2><p>Maven中定义的工程中定义了工程周期和阶段是抽象概念，不涉及具体的功能。具体的功能由插件（Plugin）实现目标代表了特定的任务，一个插件可以实现多个目标(Goal)</p><p>为了解插件的功能和共工程阶段，实现高度的可配置性，maven规定插件只是实现目标功能，通过配置来决定在那个阶段执行(Execution)那些目标操作。甚至把一个Goal绑定到多个Phase，以实现复用。</p><p>maven内置可一些默认的插件，并根据不同的工程<strong>packing类型</strong>在各个<strong>phase中默认绑定一些goal</strong>。下表列出default生命周期中各个阶段默认绑定的goal，其中goal按照惯例使用pluguname:goalname的方式标记。</p><p><strong>maven的插件是一种packaging</strong>类型为<strong>maven-plugin的特殊类型工程</strong>，它和普通的<strong>maven工程在使用maven的方法和特性一样的</strong>，不同之处是它<strong>服务与maven工具</strong>，可以通过<strong>常见maven插件</strong>来完成<strong>定制化的工程构件</strong>，<strong>管理的功</strong>能。</p><h1 id="3-Maven常用操作"><a href="#3-Maven常用操作" class="headerlink" title="3.Maven常用操作"></a>3.Maven常用操作</h1><ul><li>mvn clean 清理构件目录 target目录清除</li><li>mvn compile 编译源代码</li><li>mvn test-compile编译测试代码</li><li>mvn test 运行单元测试</li><li>mvn package运行打包</li><li>mvn install 运行安装，生成构建存储都本地仓库</li><li>mvn clean package 清理然后打包</li><li>mvn clean package -Dmaven.test.skip=true清理然后打包，但是跳过测试阶段</li><li>mvn site生成项目站点   3.3 /3.7有bug  使用2.2 或者3.7.1 或者使用以下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第一种：site生成项目网站--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">locales</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="name">locales</span>&gt;</span>  <span class="comment">&lt;!--中文形式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--第二种：site生成项目网站--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- site3.3 3.7 使用以下方法site 原因这个插件更新后的的bug--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-javadoc-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-site-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">locales</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="name">locales</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Pom-xml配置详细"><a href="#Pom-xml配置详细" class="headerlink" title="Pom.xml配置详细"></a>Pom.xml配置详细</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--mven关键设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.soyanga.hello<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--项目描述--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-app<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.soyanga.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>based on maven project<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开发者信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>1<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>jack@gmail.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>master<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>tom<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>tom@gmail.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Develpoer<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置所有项目需要依赖的第三方Jar包--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--导入第三方lombok Jar包--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--简化类的get，set--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有maven生命周期中需要的插件在此配置，插件是一个特殊的maven构建 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--site生成项目网站--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-project-info-reports-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--在此添加插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--依赖的jar包添加到classpath--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--设置可执行jar的主类--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.soyanga.hello.App<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">addExtensions</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addExtensions</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--指定可执行jar依赖包归档的目录前缀--&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Implementation-Title</span>&gt;</span>$&#123;project.name&#125;<span class="tag">&lt;/<span class="name">Implementation-Title</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Implementation-Version</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">Implementation-Version</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Implementation-Vendor-Id</span>&gt;</span>$&#123;project.groupId&#125;<span class="tag">&lt;/<span class="name">Implementation-Vendor-Id</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><!--more-->]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Maven简介和安装&quot;&gt;&lt;a href=&quot;#Maven简介和安装&quot; class=&quot;headerlink&quot; title=&quot;Maven简介和安装&quot;&gt;&lt;/a&gt;Maven简介和安装&lt;/h1&gt;&lt;p&gt;了解Maven是什么，作什么、且安装&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://maven.apache.org/是一个综合的项目管理和综合工具。基于项目对象模型（POM）的概念，Maven可以从一个中心资料片（pom.xml）管理和项目构建，报告和文件。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://maven.apache.org/是一个综合的项目管理和综合工具。基于项目对象模型（POM）的概念，Maven可以从一个中心资料片（pom.xml）管理和项目构建，报告和文件。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;提供了开发人员构建一个完整的生命周期框架。开发团队可以&lt;strong&gt;自动&lt;/strong&gt;完成项目的基础工具建设，&lt;strong&gt;Maven使用标准的目录结构&lt;/strong&gt;和&lt;strong&gt;默认构建生命周期&lt;/strong&gt;（编译规则）。&lt;/p&gt;
&lt;p&gt;在多人开发团队环境时，Maven可以设置按标标准在非常短的时间里完成配置工作。由于大部分项目的设置都非常检查，并且可以重复使用，Maven让开发人员更加轻松，同时创建报表，检查，构建和测试自动化设置。&lt;/p&gt;
&lt;p&gt;Maven提供了开发人员的方式来管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Builds（创建）&lt;/li&gt;
&lt;li&gt;Documentation（文档）API文档&lt;/li&gt;
&lt;li&gt;Reporting（报告）&lt;/li&gt;
&lt;li&gt;Dependencies (依赖)   &lt;/li&gt;
&lt;li&gt;SCM（软件配置管理）&lt;/li&gt;
&lt;li&gt;Releases (发布) 版本号 Maven的中央仓库&lt;/li&gt;
&lt;li&gt;Distribution (分布)&lt;/li&gt;
&lt;li&gt;mailing list (邮件列表)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;概括来说，Maven&lt;strong&gt;简化和标准化项目建设过程&lt;/strong&gt;。&lt;strong&gt;处理编译，分配，文档&lt;/strong&gt;，&lt;strong&gt;团队协作和其他任务的无缝衔接。&lt;/strong&gt;Maven增加可重用性并负责建立相关的任务。&lt;/p&gt;
    
    </summary>
    
      <category term="Java EE" scheme="https://soyanga.github.io/categories/Java-EE/"/>
    
    
      <category term="Maven" scheme="https://soyanga.github.io/tags/Maven/"/>
    
      <category term="代码管理工具" scheme="https://soyanga.github.io/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SOYANGA</title>
  
  <subtitle>Hello World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://soyanga.github.io/"/>
  <updated>2019-06-24T06:35:31.001Z</updated>
  <id>https://soyanga.github.io/</id>
  
  <author>
    <name>SOYANGA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法-位运算简记</title>
    <link href="https://soyanga.github.io/2019/06/24/%E7%AE%97%E6%B3%95-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AE%80%E8%AE%B0/"/>
    <id>https://soyanga.github.io/2019/06/24/算法-位运算简记/</id>
    <published>2019-06-24T06:33:35.000Z</published>
    <updated>2019-06-24T06:35:31.001Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="位运算简记"><a href="#位运算简记" class="headerlink" title="位运算简记"></a>位运算简记</h1><h2 id="XOR-异或"><a href="#XOR-异或" class="headerlink" title="XOR-异或"></a>XOR-异或</h2><blockquote><p>异或：相同位0，不同为1.也可以用【不进位加法】来理解</p></blockquote><p>异或操作的一些特点：</p><ul><li>x ^  0 = x</li><li>x ^ 1s = ~x   // 1s  = ~0</li><li>x ^ (~x)= 1s</li><li>x ^ x = 0</li><li>a ^ b  = c   -&gt;  a ^ c = b,  b ^ c = a   //交换ab</li><li>a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c </li></ul><a id="more"></a><h2 id="实战常用的位运算操作"><a href="#实战常用的位运算操作" class="headerlink" title="实战常用的位运算操作"></a>实战常用的位运算操作</h2><ul><li>x &amp; 1 == 1 OR ==0 判断奇偶性  等价于 （ x%2 == 1）</li><li>x = x &amp; (x-1) =&gt; 清零最低为的1 一直到x = 0</li><li>x &amp; -x =&gt;得到最低位的1</li></ul><h2 id="更为复杂的位运算操作"><a href="#更为复杂的位运算操作" class="headerlink" title="更为复杂的位运算操作"></a>更为复杂的位运算操作</h2><table><thead><tr><th>操作</th><th>运算</th></tr></thead><tbody><tr><td>将x最右边的n位清零</td><td>x &amp; (~0 &lt;&lt; n)</td></tr><tr><td>获取x的第n位值（0或1)</td><td>(x &gt;&gt; n) &amp; 1</td></tr><tr><td>获取x的第n位的幂值</td><td>x &amp; (1 &lt;&lt; (n - 1))</td></tr><tr><td>仅将第n位置为1</td><td>x \</td><td>(1&lt;&lt;n)</td></tr><tr><td>仅将第n为置为0</td><td>x &amp; ( ~(1 &lt;&lt; n))</td></tr><tr><td>将x最高位至第n位(含)清零</td><td>x&amp;( (1&lt;&lt;n)-1)</td></tr><tr><td>将第n位至第0位(含)清零</td><td>x&amp;(~((1&lt;&lt;(n+1))-1))</td></tr></tbody></table><h2 id="位运算练习"><a href="#位运算练习" class="headerlink" title="位运算练习"></a>位运算练习</h2><ul><li><p><strong>颠倒二进制位</strong></p><p>颠倒给定的 32 位无符号整数的二进制位。</p></li></ul><p>  示例 1：</p><p>  输入: 00000010100101000001111010011100<br>  输出: 00111001011110000010100101000000<br>  解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，<br>        因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。<br>  示例 2：</p><p>  输入：11111111111111111111111111111101<br>  输出：10111111111111111111111111111111<br>  解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，<br>        因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。</p><p>  提示：</p><p>  请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。<br>  在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。</p><p>  来源：力扣（LeetCode）<br>  链接：<a href="https://leetcode-cn.com/problems/reverse-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-bits</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = n &gt;&gt; i;</span><br><span class="line">            <span class="comment">//1.取出要反转的每一位二进制</span></span><br><span class="line">            temp &amp;= <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//2.将该二进制位放到反转后的位置</span></span><br><span class="line">            temp  &lt;&lt;= (<span class="number">31</span>-i);</span><br><span class="line">            <span class="comment">//3.将该位添加到结果上</span></span><br><span class="line">            result |= temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">191. 位1的个数</a></h4></li><li><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。</p></li></ul><p>  示例 1：</p><p>  输入：00000000000000000000000000001011<br>  输出：3<br>  解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。<br>  示例 2：</p><p>  输入：00000000000000000000000010000000<br>  输出：1<br>  解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 ‘1’。<br>  示例 3：</p><p>  输入：11111111111111111111111111111101<br>  输出：31<br>  解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 ‘1’。</p><p>  来源：力扣（LeetCode）<br>  链接：<a href="https://leetcode-cn.com/problems/number-of-1-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-1-bits</a></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n &amp;=(n-<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">338. 比特位计数</a></h4><p>给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p><p>示例 1:</p><p>输入: 2<br>输出: [0,1,1]<br>示例 2:</p><p>输入: 5<br>输出: [0,1,1,2,1,2]</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/counting-bits" target="_blank" rel="noopener">https://leetcode-cn.com/problems/counting-bits</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span> result[] = <span class="keyword">new</span> <span class="keyword">int</span>[num+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++)&#123;</span><br><span class="line">            result[i] = result[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//result[i] = result[i&amp;(i-1)]+1;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>方法1：i &amp; (i - 1)去掉i最右边的一个1；因i &amp; (i - 1）&lt; i，故result[i &amp; (i - 1)]已计算，所以i中1的个数为</p><p>result[i &amp; (i - 1)] + 1</p><p>方法2：i &gt;&gt; 1去掉i的最低位；因(i &gt;&gt; 1) &lt; i，故result[i &gt;&gt; 1]已计算，因此i中1的个数为i &gt;&gt; 1中1的个数加最后一位1的个数，即为result[i &gt;&gt; 1] + (i &amp; 1)</p></blockquote><ul><li><h4 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></h4><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p>示例 1:</p><p>输入: 1<br>输出: true<br>解释: 20 = 1<br>示例 2:</p><p>输入: 16<br>输出: true<br>解释: 24 = 16<br>示例 3:</p><p>输入: 218<br>输出: false</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/power-of-two" target="_blank" rel="noopener">https://leetcode-cn.com/problems/power-of-two</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n&gt;<span class="number">0</span>)&amp;&amp;(n&amp;(n-<span class="number">1</span>))==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>1.<strong>一个数是2的n次方 ，该数的比特位中则一定是且仅有一个1</strong></p><p>则判断是否是2的幂则转变位判断x中1的个数</p><p>x!=0 x&amp;(x-1)  = &gt;count++  final count = 1;</p><p>2.mod</p><p>3.logx = int</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;位运算简记&quot;&gt;&lt;a href=&quot;#位运算简记&quot; class=&quot;headerlink&quot; title=&quot;位运算简记&quot;&gt;&lt;/a&gt;位运算简记&lt;/h1&gt;&lt;h2 id=&quot;XOR-异或&quot;&gt;&lt;a href=&quot;#XOR-异或&quot; class=&quot;headerlink&quot; title=&quot;XOR-异或&quot;&gt;&lt;/a&gt;XOR-异或&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;异或：相同位0，不同为1.也可以用【不进位加法】来理解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;异或操作的一些特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x ^  0 = x&lt;/li&gt;
&lt;li&gt;x ^ 1s = ~x   // 1s  = ~0&lt;/li&gt;
&lt;li&gt;x ^ (~x)= 1s&lt;/li&gt;
&lt;li&gt;x ^ x = 0&lt;/li&gt;
&lt;li&gt;a ^ b  = c   -&amp;gt;  a ^ c = b,  b ^ c = a   //交换ab&lt;/li&gt;
&lt;li&gt;a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="位运算简记" scheme="https://soyanga.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AE%80%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>递归复杂度求解</title>
    <link href="https://soyanga.github.io/2019/05/11/%E9%80%92%E5%BD%92%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E8%A7%A3/"/>
    <id>https://soyanga.github.io/2019/05/11/递归复杂度求解/</id>
    <published>2019-05-11T15:37:15.000Z</published>
    <updated>2019-05-11T15:42:18.218Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="26-递归的时间复杂度的求解"><a href="#26-递归的时间复杂度的求解" class="headerlink" title="[26]递归的时间复杂度的求解"></a>[26]递归的时间复杂度的求解</h1><p>递归时间复杂度的求解分为2种常规求法和递归树法</p><a id="more"></a><h2 id="常规求法"><a href="#常规求法" class="headerlink" title="常规求法"></a>常规求法</h2><h3 id="写递归代码的三部"><a href="#写递归代码的三部" class="headerlink" title="写递归代码的三部"></a>写递归代码的三部</h3><ol><li>找出递推公式</li><li>知道递推的出口</li><li>将以上两步翻译成代码</li></ol><p>常规求法就是按照递推公式去求解—-比较麻烦，考验数学的时候到了！！:sweat:</p><h2 id="递归树求法"><a href="#递归树求法" class="headerlink" title="递归树求法"></a>递归树求法</h2><p>根据写出的递推公式，以及递归的出口，画出递归树，分析每个节点的时间复杂度<em>当前行的节点个数\</em>行数</p><p>如下图：</p><p><img src="/2019/05/11/递归复杂度求解/qq数据\321830735\FileRecv\MobileFile\1552895962676.jpg" alt="1552895962676"></p><p>递归的时候时间复杂度为O(n*m) n为每行消耗的时间复杂度，m为数的高度。</p><p>即O($nlog_n$)   每行消耗的时间复杂度为O(n),树的高度为$nog_n$ 。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;26-递归的时间复杂度的求解&quot;&gt;&lt;a href=&quot;#26-递归的时间复杂度的求解&quot; class=&quot;headerlink&quot; title=&quot;[26]递归的时间复杂度的求解&quot;&gt;&lt;/a&gt;[26]递归的时间复杂度的求解&lt;/h1&gt;&lt;p&gt;递归时间复杂度的求解分为2种常规求法和递归树法&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="递归事件复杂度求解" scheme="https://soyanga.github.io/tags/%E9%80%92%E5%BD%92%E4%BA%8B%E4%BB%B6%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B1%82%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://soyanga.github.io/2019/05/11/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://soyanga.github.io/2019/05/11/红黑树/</id>
    <published>2019-05-11T15:33:32.000Z</published>
    <updated>2019-05-11T15:35:14.146Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="25-红黑树-上-：为什么工程中都使用到了红黑树这种二叉树结构"><a href="#25-红黑树-上-：为什么工程中都使用到了红黑树这种二叉树结构" class="headerlink" title="[25]红黑树(上)：为什么工程中都使用到了红黑树这种二叉树结构"></a>[25]红黑树(上)：为什么工程中都使用到了红黑树这种二叉树结构</h1><p>二叉树的插入，删除，查找操作，各个操作的事件复杂度跟树的高度成正比，理想情况下时间复杂度是O($log_n$) 。</p><p>不过二叉树查找树在频繁的动态更新过程中，可<strong>能会出现树的高度远大于$log_2n$ 情况，从而导致操作效率下降。极端情况下，二叉树会退化成为链表，时间复杂度会退化到O(n)。</strong>平衡二叉树的出现解决了这个问题。</p><p>平衡二叉树严格定义上讲：<strong>二叉树中任意一个节点的左右节点的树高度相差不能大于1</strong>.从这个定义上来看，完全二叉树，满二叉树都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。<br><a id="more"></a></p><p><img src="/2019/05/11/红黑树/qq数据\321830735\FileRecv\MobileFile\1552563697223.jpg" alt="1552563697223"></p><p>AVL数是严格按照上述所讲的定义的，即任何一个节点的左右子树的高度差不超过1，是一种高度平衡的二叉查找树。红黑树并没有严格按照上述定义</p><p>平衡二叉查找树种的”平衡”的意思就是让整棵看起来比较”对称”，比较”平衡”，不要出现左子树很高、右子树很矮就行。<strong>这个就能让整棵树的高度相对来说比较低一些，相应的插入、删除、查找等操作的效率高一些。</strong></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>如何定义一棵”红黑树”？</p><p>平衡二叉树其实很多，比如，SplayTree(伸展树)、Tree(树堆)等，</p><p><strong>红黑树的英文是”Red-Black-Tree”,简称R-B Tree。</strong>，红黑树中节点，一类被标记为黑色，一类被标记为红色，除此之外，一棵红黑树好需要满足如下要求：</p><ol><li>根节点是黑色的</li><li>每个叶子节点都是黑色的空节点（NULL),也就是说，叶子节点不存储数据； —为了简化代码实现</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点被黑色节点隔开的。</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。</li></ol><p>如下图，红黑树。</p><p><img src="/2019/05/11/红黑树/qq数据\321830735\FileRecv\MobileFile\1552566548676.jpg" alt="1552566548676"></p><h2 id="红黑树的性能分析"><a href="#红黑树的性能分析" class="headerlink" title="红黑树的性能分析"></a>红黑树的性能分析</h2><p>为什么说红黑树“近似平衡”的？</p><p>平衡的意思就等价为性能不退化。“近似平衡”就等价为性能不会退化的太严重。红黑树的高度是否稳定地趋近$log_2n$就好了。</p><p>二叉树的性能由二叉树的高度来决定，我们分析以下红黑树的高度。</p><p>首先，我们来看，如果我们将红色节点从红黑树中去掉，那单纯包含黑色节点的红黑树的高度是多少呢？如下图：</p><p><img src="/2019/05/11/红黑树/qq数据\321830735\FileRecv\MobileFile\1552566521418.jpg" alt="1552566521418"></p><p>红色节点之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点得到父节点）作为父节点。所以，之前的二叉树就变成了四叉树。</p><p>构成的四叉树是一颗完全二叉树，所以包含黑色节点的四叉树的高度，比包含向同节点个数的完全二叉树高度还要小。</p><p>即<strong>“黑色”四叉树的高度要低于完全二叉树，所以去掉红色节点的”黑树”的高度也不会超过$log_2n$。</strong></p><h2 id="我们把红色节点加回去的红黑树的树的高度是多少呢？"><a href="#我们把红色节点加回去的红黑树的树的高度是多少呢？" class="headerlink" title="我们把红色节点加回去的红黑树的树的高度是多少呢？"></a>我们把红色节点加回去的红黑树的树的高度是多少呢？</h2><p>由二叉树的<strong>第三条特性任何相邻节点不能是红色，则红色要被黑色隔开</strong>。<strong>红黑树中包含最多黑色节点的路径不会超过$log_2n$,所以加入红色节点之后，最长路径不会超过$2log_2n$，也就是说红黑树的高度近似为$2log_2n$。</strong></p><p><strong>所以红黑树的高度只是比高度平衡的AVL树的高度($log_2n$ )仅仅大了一倍，在性能上，下降的并不多。</strong>这样推导出来的节点不够精确，实际上红黑树的性能更好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Treap,Splay Tree，绝大情况下，他们的操作效率都很高，但是他们无法避免极端情况下的时间复杂度退化的情况，虽然出现概率不大，但是对于单次操作而言非常敏感的场景来说，他们并不适用。</p><p>AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是AVL树为维持这种高度平衡的树，就要付出更大的代价，每次插入之后，删除倒要调整，就比较复杂跟耗时。所以对于频繁的插入删除操作而言，使用AVL树的代价就比较高了。</p><p><strong>所以红黑树的插入删除，查找各种操作比较稳定，对于工程应用跟偏向使用这个能应对各种异常情况，为了支持工业级别的应用，我们更倾向于使用这种性能跟稳定为平衡二叉树。</strong></p><p>红黑树的实现对于初学者来说比较复杂，我们可以使用跳表代替。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;25-红黑树-上-：为什么工程中都使用到了红黑树这种二叉树结构&quot;&gt;&lt;a href=&quot;#25-红黑树-上-：为什么工程中都使用到了红黑树这种二叉树结构&quot; class=&quot;headerlink&quot; title=&quot;[25]红黑树(上)：为什么工程中都使用到了红黑树这种二叉树结构&quot;&gt;&lt;/a&gt;[25]红黑树(上)：为什么工程中都使用到了红黑树这种二叉树结构&lt;/h1&gt;&lt;p&gt;二叉树的插入，删除，查找操作，各个操作的事件复杂度跟树的高度成正比，理想情况下时间复杂度是O($log_n$) 。&lt;/p&gt;
&lt;p&gt;不过二叉树查找树在频繁的动态更新过程中，可&lt;strong&gt;能会出现树的高度远大于$log_2n$ 情况，从而导致操作效率下降。极端情况下，二叉树会退化成为链表，时间复杂度会退化到O(n)。&lt;/strong&gt;平衡二叉树的出现解决了这个问题。&lt;/p&gt;
&lt;p&gt;平衡二叉树严格定义上讲：&lt;strong&gt;二叉树中任意一个节点的左右节点的树高度相差不能大于1&lt;/strong&gt;.从这个定义上来看，完全二叉树，满二叉树都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="红黑树" scheme="https://soyanga.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>二叉树基础(下)</title>
    <link href="https://soyanga.github.io/2019/05/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/05/03/二叉树基础(下)/</id>
    <published>2019-05-02T16:03:34.000Z</published>
    <updated>2019-05-02T16:04:26.810Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="24-二叉树基础-下-有了如此高效的散列表，为什么还需要二叉树？"><a href="#24-二叉树基础-下-有了如此高效的散列表，为什么还需要二叉树？" class="headerlink" title="[24]二叉树基础(下):有了如此高效的散列表，为什么还需要二叉树？"></a>[24]二叉树基础(下):有了如此高效的散列表，为什么还需要二叉树？</h1><p>二叉树查找树特点：支持动态数据集合的快速插入和删除，查找操作。</p><h2 id="二叉查找树-Binary-Search-Tree"><a href="#二叉查找树-Binary-Search-Tree" class="headerlink" title="二叉查找树(Binary Search Tree)"></a>二叉查找树(Binary Search Tree)</h2><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。为了快速查找而生的树。这些都依赖二叉树的特殊结构。二叉查找树的要求，<strong>在树中的任意一个节点，其左子树的每个节点的值，都小于这个节点的值，而右子树节点的值都大于这个节点的值。</strong></p><p><img src="/2019/05/03/二叉树基础(下)/婕\数据结构与算法之美\picture\二叉搜索树图.jpg" alt="二叉搜索树图"></p><a id="more"></a><h3 id="内置节点代码"><a href="#内置节点代码" class="headerlink" title="内置节点代码"></a>内置节点代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> Node left;</span><br><span class="line">    <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftData = left.data;</span><br><span class="line">        <span class="keyword">int</span> rightData = right.data;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                <span class="string">"data="</span> + data +</span><br><span class="line">                <span class="string">", left="</span> + leftData +</span><br><span class="line">                <span class="string">", right="</span> + rightData +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h2><p>首先我们先取根节点，如果要查找的数据等于我们要查找的数据那么我们就先返回。  —类似于求取二叉树的高度</p><p>如果要查找的数据小于我们要查找的数据，我们就在左子树查找。</p><p>如果要查找的数据大于我们要查找的数据，我们就在右子树查找</p><p><img src="/2019/05/03/二叉树基础(下)/婕\数据结构与算法之美\picture\二叉树查找操作.jpg" alt="二叉树查找操作"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree;  <span class="comment">//跟节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data &gt; p.data)&#123;</span><br><span class="line">            p = p.left;   <span class="comment">//查找树小遍历左子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data &lt; p.data)&#123;</span><br><span class="line">            p = p.right;  <span class="comment">//查找树大遍历右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的查找树插入操作"><a href="#二叉树的查找树插入操作" class="headerlink" title="二叉树的查找树插入操作"></a>二叉树的查找树插入操作</h2><p>根查找差不多，跟查找类似，但是加了一个条件就是要插入的节点是叶子节点</p><p><img src="/2019/05/03/二叉树基础(下)/婕\数据结构与算法之美\picture\二叉搜索树的插入.jpg" alt="二叉搜索树的插入"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">if</span>(tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Node p  = tree;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(data &gt; p.data) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (data &lt; p.data) &#123;  <span class="comment">//data &lt; p.data</span></span><br><span class="line">            <span class="keyword">if</span>(p.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树查找树删除操作"><a href="#二叉树查找树删除操作" class="headerlink" title="二叉树查找树删除操作"></a>二叉树查找树删除操作</h2><p>删除操作分为3种情况。</p><p>第一种情况是，如果要删除的节点没有子节点，我们只需要直接将父节点中，将要删除节点指针为null。比如图中的删除节点55。</p><p>第二种情况是，如果要删除的节点只有一个子节点（只有左子节或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的字节点就可以了。比如图中的删除节点13。</p><p>第三种情况是，如果要删除的节点有两个子节点，这就比较复杂了。我们需要找到这个节点的右子树中的最小的节点，把它替换到删除的节点上，然后再删除这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点了。我们可以将最小节点互换，然后删除叶子节点。比如图中的删除节点18。</p><p><img src="/2019/05/03/二叉树基础(下)/婕\数据结构与算法之美\picture\二叉树删除图.jpg" alt="二叉树删除图"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node p = tree; <span class="comment">//p指向要删除的节点，初始化指向根节点</span></span><br><span class="line">    Node pp = <span class="keyword">null</span>; <span class="comment">//pp记录的是p的父节点</span></span><br><span class="line">    <span class="comment">//查找要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p.data) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;       <span class="comment">//没有找到 要删除的节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要删除的节点有两个子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">//查找右子树中最小节点</span></span><br><span class="line">        Node minp = p.right;</span><br><span class="line">        Node minpp = p;  <span class="comment">//minpp表示minp的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (minp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minpp = minp;</span><br><span class="line">            minp = minp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到要删除节点的右子树的最小值，即右子树的最端左孩子</span></span><br><span class="line">        p.data = minp.data; <span class="comment">//将要删除的节点的值更因为最左端的值</span></span><br><span class="line">        p = minp; <span class="comment">//将要删除的节点变为最左端节点</span></span><br><span class="line">        pp = minpp; <span class="comment">//更新要删除的节点的父节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将删除操作(叶子节点) 或者要删除的节点只有一个子节点</span></span><br><span class="line">    Node child; <span class="comment">//p 的子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        child = p.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        tree = child;   <span class="comment">//要删除的节点没有父节点，则要删除的是根节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p) &#123;</span><br><span class="line">        pp.left = child;   <span class="comment">//要删除的节点只有左子树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pp.right = child; <span class="comment">//要删除的节点只有右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a>二叉查找树的其他操作</h2><h3 id="寻找最大，最小节点"><a href="#寻找最大，最小节点" class="headerlink" title="寻找最大，最小节点"></a>寻找最大，最小节点</h3><p>最小节点：在最左端</p><p>最大节点：在最右端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">findMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树时间复杂度分析"><a href="#二叉树时间复杂度分析" class="headerlink" title="二叉树时间复杂度分析"></a>二叉树时间复杂度分析</h2><p>二叉查找，插入，删除，查找操作的时间复杂度。</p><p>实际上，二叉查找树的各种操作根构造树的形态，图一第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了O(n)。</p><p><img src="/2019/05/03/二叉树基础(下)/婕\数据结构与算法之美\picture\二叉树搜索树的弊端.jpg" alt="二叉树搜索树的弊端"></p><p>我们刚其实分析了一种最糟糕的情况，我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树)。这个时候，插入，删除，查找的<strong>时间复杂度都跟树的高度成正比</strong>，也就是O(height)。</p><p>满二叉树的高度等于$log_2(n+1)$ 完全二叉树的高度在[$log_2(n+1)$,$log_2n+1$]近似为完全二叉树的高度小于等于$log_2n$ 。</p><p>显然极度不平衡的二叉查找树，他的查找性能肯定不能满足我们的需求，我们需要构建一种不管怎么删除，插入数据的时候都能保持任意节点左右子树都比较平衡的二叉查找树，这就是我们下一节课要详细讲的，一种特殊的二叉查找树，平衡二叉查找树。平衡二叉查找树的高度接近$log_n$,所以插入删除，查找操作的时间复杂度也比较稳定，是O($log_n$)。</p><h2 id="散列表和二叉树辨析"><a href="#散列表和二叉树辨析" class="headerlink" title="散列表和二叉树辨析"></a>散列表和二叉树辨析</h2><p>散列表的插入，删除，查找操作的时间复杂度可以做到常量级的O(1)非常高效相比于二叉树而言，二叉树显得很没有优势。</p><p>第一，散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序，而对二叉搜索树而言，中序遍历的结果就是，O(n)的时间复杂度内，输出有序数据序列。</p><p>第二，散列表扩容耗时很多，而且当遇到散列冲突的时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，平衡二叉查找树非常稳定，时间复杂度在$Olog_n$。</p><p>第三笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但是当哈希从冲突严中的时候，常量级时间复杂度不一定比$Olog_n$小，所以时间查找速度可能不一定比$Olog_n$块，加上哈希函数耗时，也不一定就比平衡二叉查找树的效率高。</p><p>第四，散列表给设计复杂，平衡二叉树只需要考虑平衡性的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;24-二叉树基础-下-有了如此高效的散列表，为什么还需要二叉树？&quot;&gt;&lt;a href=&quot;#24-二叉树基础-下-有了如此高效的散列表，为什么还需要二叉树？&quot; class=&quot;headerlink&quot; title=&quot;[24]二叉树基础(下):有了如此高效的散列表，为什么还需要二叉树？&quot;&gt;&lt;/a&gt;[24]二叉树基础(下):有了如此高效的散列表，为什么还需要二叉树？&lt;/h1&gt;&lt;p&gt;二叉树查找树特点：支持动态数据集合的快速插入和删除，查找操作。&lt;/p&gt;
&lt;h2 id=&quot;二叉查找树-Binary-Search-Tree&quot;&gt;&lt;a href=&quot;#二叉查找树-Binary-Search-Tree&quot; class=&quot;headerlink&quot; title=&quot;二叉查找树(Binary Search Tree)&quot;&gt;&lt;/a&gt;二叉查找树(Binary Search Tree)&lt;/h2&gt;&lt;p&gt;二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。为了快速查找而生的树。这些都依赖二叉树的特殊结构。二叉查找树的要求，&lt;strong&gt;在树中的任意一个节点，其左子树的每个节点的值，都小于这个节点的值，而右子树节点的值都大于这个节点的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/05/03/二叉树基础(下)/婕\数据结构与算法之美\picture\二叉搜索树图.jpg&quot; alt=&quot;二叉搜索树图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="二叉树" scheme="https://soyanga.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis-动态SQL映射</title>
    <link href="https://soyanga.github.io/2019/04/21/Mybatis-%E5%8A%A8%E6%80%81SQL%E6%98%A0%E5%B0%84/"/>
    <id>https://soyanga.github.io/2019/04/21/Mybatis-动态SQL映射/</id>
    <published>2019-04-21T12:13:20.000Z</published>
    <updated>2019-04-21T12:17:37.971Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Mybatis动态SQL映射"><a href="#Mybatis动态SQL映射" class="headerlink" title="Mybatis动态SQL映射"></a>Mybatis动态SQL映射</h1><blockquote><p>重点：</p><ul><li>理解Mybatis的动态SQL映射原理</li><li>掌握Mybatis的动态SQL映射编写</li></ul></blockquote><a id="more"></a><h2 id="1-动态SQL简介"><a href="#1-动态SQL简介" class="headerlink" title="1.动态SQL简介"></a>1.动态SQL简介</h2><p>MyBatis的强大特性之一就是他的动态SQL。JDBC中根据不同条件拼接SQL语句繁琐。利用动态SQL就可以摆脱这种痛苦。</p><p>通常动态SQL不可能是独立的一部分，MyBatis当然使用一种强大的动态SQL语言来改进这种情形，这种语言可以被用在任意SQL映射语句中。</p><p>动态SQL元素和使用JSTL(JSP标准标签库)或其他类似基于XML的文本处理器相似。在MyBatis之前版本中，需要了解很多元素，现在MyBatis3大大提升了元素，用不到原先一半元素就可以了。MyBatis采用功能强大的基于<strong>OGNL</strong>（Object Graphic Navigation Language 对象图导航语言） 的表达式来消除其他元素。</p><p>动态SQL映射使用标记：</p><ul><li>if</li><li>choose(when,otherwise)</li><li>trim(where,set)</li><li>foreach</li></ul><h2 id="2-动态SQl标记"><a href="#2-动态SQl标记" class="headerlink" title="2.动态SQl标记"></a>2.动态SQl标记</h2><h3 id="2-1if"><a href="#2-1if" class="headerlink" title="2.1if"></a>2.1if</h3><p>动态SQL通常要做的事情是有条件地包含where子句地一部分。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottEmpWhithdeptnoAndJob"</span> <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">    from emp</span><br><span class="line">    where deptno=20</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"job!=null and jon != '' "</span> &gt;</span></span><br><span class="line">         and job like #&#123;job&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多重if判断  and</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottEmpWhithdeptnoAndLikeJobAndLikeEname"</span> <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">     select</span><br><span class="line">     <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">     from emp</span><br><span class="line">     where deptno=20</span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"job!=null and job!= '' "</span>&gt;</span></span><br><span class="line">         and job like #&#123;job&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null"</span>&gt;</span></span><br><span class="line">         and ename like #&#123;ename&#125;</span><br><span class="line">     <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2where"><a href="#2-2where" class="headerlink" title="2.2where"></a>2.2where</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottEmpWhithdeptnoAndLikeJobAndLikeEname2"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">      select</span><br><span class="line">      <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">      from emp</span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"deptno!=null"</span>&gt;</span></span><br><span class="line">                deptno = #&#123;deptno&#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"job!=null and job!= '' "</span>&gt;</span></span><br><span class="line">            and job like #&#123;job&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">         <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null"</span>&gt;</span></span><br><span class="line">             and ename like #&#123;ename&#125;</span><br><span class="line">         <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3choose-when-otherwise"><a href="#2-3choose-when-otherwise" class="headerlink" title="2.3choose,when,otherwise"></a>2.3choose,when,otherwise</h3><p>有些时候，我们不想用条件语句，而只是想从中择出一点。针对这种情况，MyBatis提供了choose元素，它有点像Java中的switch语句</p><p>还是如上的例子，但是这次变为提供了“job”就按“job”查找，提供了”ename”就按“ename”查找，若两者都没有，就按业务情况返回所有deptno = 20的且ename是</p><p><code>JACK</code>的职务表信息。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--choose when otherwise 相当于SwitchCase case default--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottEmpWhithDeptnoAndLikeJobOrEname"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">    from emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        deptno=20</span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"job!=null"</span>&gt;</span></span><br><span class="line">                and job = #&#123;job&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"ename!=null"</span>&gt;</span></span><br><span class="line">                and ename = #&#123;ename&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3trim-where-set"><a href="#2-3trim-where-set" class="headerlink" title="2.3trim,where,set"></a>2.3trim,where,set</h3><p>前面几个例子已经合宜的解决了经典的动态SQL问题，现在考虑回到if示例，这次我们将<code>deptno= 20</code>也设置为动态的条件或者去掉看看会发生什么。</p><p>会在解析SQL语句时出现SQL语句异常，所以我们此时需要<code>where</code>来解决此问题，它会将where中包括的语句适当的增加删除某些多余的SQL命令，使得达到开发者预期的情况，比如去掉多余的 and，当没有符合条件时，where语句不执行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottEmpWhithdeptnoAndLikeJobAndLikeEname2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">    from emp</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"deptno!=null"</span>&gt;</span></span><br><span class="line">            deptno = #&#123;deptno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"job!=null and job!= '' "</span>&gt;</span></span><br><span class="line">            and job like #&#123;job&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null"</span>&gt;</span></span><br><span class="line">            and ename like #&#123;ename&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>where元素直到只有在一个以上if条件有值时才会添加where子句，而且，若最后内容是“AND”或者“OR”开头的，where元素也知道如何将他们去除。</p><p>如果where元素不正常处理，我们还可以通过trim元素来定制我们想要的功能。比如，和where元素等价的自定义trim元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"AND |OR"</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。其功能就是在所有prefixOverrides 属性指定的内容将被移除，并且插入prefix属性中指定的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottEmpWhithdeptnoAndLikeJobAndLikeEname2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">    from emp</span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;where&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;if test="deptno!=null"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--deptno = #&#123;deptno&#125;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/if&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;if test="job!=null and job!= '' "&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--and job like #&#123;job&#125;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/if&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;if test="ename!=null"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--and ename like #&#123;ename&#125;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/if&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/where&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--将where后的语句中所偶有以and 或者 or结尾或开头的标签都去掉--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and | or"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"deptno!=null"</span>&gt;</span></span><br><span class="line">            deptno = #&#123;deptno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"job!=null and job!= '' "</span>&gt;</span></span><br><span class="line">            and job like #&#123;job&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null"</span>&gt;</span></span><br><span class="line">            and ename like #&#123;ename&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>类似用于动态更新的解决方案叫做set，set元素可以被用于动态包含需要<strong>更新</strong>的列，而且舍去其他的。比如：舍去以，结尾的，并且当set元素不为空的元素中个数大于1时，在开头添加set </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateScottEmpByObjectWithSet"</span> <span class="attr">parameterType</span>=<span class="string">"com.soyanga.mybatis.entity.ScottEmp"</span>&gt;</span></span><br><span class="line">        update emp</span><br><span class="line">        <span class="comment">&lt;!--&lt;trim prefix="set" suffixOverrides=","&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;if test="hiredate!=null"&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--hiredate = #&#123;hiredate&#125;,--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;/if&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;if test="ename!=null"&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--ename = #&#123;ename&#125;,--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;/if&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/trim&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"hiredate!=null"</span>&gt;</span></span><br><span class="line">                hiredate = #&#123;hiredate&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null"</span>&gt;</span></span><br><span class="line">                ename = #&#123;ename&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where empno = #&#123;empno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"set"</span> <span class="attr">suffixOverrides</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4foreach"><a href="#2-4foreach" class="headerlink" title="2.4foreach"></a>2.4foreach</h3><p>动态SQL的另外一个常用的必要操作是需要对一个集合进行遍历，通常子构建 IN 条件语句的时候。比如：</p><p>参数类型为：list</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--映射接口--&gt;</span></span><br><span class="line">List<span class="tag">&lt;<span class="name">ScottEmp</span>&gt;</span> queryScottempByList(List deptnos);</span><br><span class="line"><span class="comment">&lt;!--命令配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottempByList"</span> <span class="attr">parameterType</span>=<span class="string">"list"</span> <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">        from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            deptno in</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                #&#123;item&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试代码--&gt;</span></span><br><span class="line">    @Test</span><br><span class="line">    public void test_queryScottempByList() &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        ScottEmpMapper scottEmpMapper = sqlSession.getMapper(ScottEmpMapper.class);</span><br><span class="line">        List<span class="tag">&lt;<span class="name">Integer</span>&gt;</span> deptnolist = new ArrayList<span class="tag">&lt;<span class="name">Integer</span>&gt;</span>();</span><br><span class="line">        deptnolist.add(10);</span><br><span class="line">//        deptnolist.add(20);</span><br><span class="line">//        deptnolist.add(30);</span><br><span class="line">        List<span class="tag">&lt;<span class="name">ScottEmp</span>&gt;</span> scottEmpList = scottEmpMapper.queryScottempByList(deptnolist);</span><br><span class="line">        logger.info("queryScottEmpWhithDeptnoAndLikeJobOrEname  Result &#123;&#125;", scottEmpList);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参数类型为 ：array</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--映射接口--&gt;</span></span><br><span class="line">List<span class="tag">&lt;<span class="name">ScottEmp</span>&gt;</span> queryScottempByArray(Integer[] deptnos);</span><br><span class="line"><span class="comment">&lt;!--命令配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottempByArray"</span> <span class="attr">parameterType</span>=<span class="string">"integer[]"</span> <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        select</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">        from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            deptno in</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"array"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                #&#123;item&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--测试代码--&gt;</span></span><br><span class="line">    @Test</span><br><span class="line">    public void test_queryScottempByArray() &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        ScottEmpMapper scottEmpMapper = sqlSession.getMapper(ScottEmpMapper.class);</span><br><span class="line">        List<span class="tag">&lt;<span class="name">ScottEmp</span>&gt;</span> scottEmpList = scottEmpMapper.queryScottempByArray(new Integer[]&#123;10&#125;);</span><br><span class="line">        logger.info("queryScottEmpWhithDeptnoAndLikeJobOrEname  Result &#123;&#125;", scottEmpList);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参数类型为Map</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--映射接口--&gt;</span></span><br><span class="line">    List<span class="tag">&lt;<span class="name">ScottEmp</span>&gt;</span> queryScottempByMap(Map deptnoMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--命令配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryScottempByMap"</span> <span class="attr">resultMap</span>=<span class="string">"scottEmpMap"</span>&gt;</span></span><br><span class="line">        select</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"emp_column"</span>/&gt;</span></span><br><span class="line">        from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"ename!=null"</span>&gt;</span></span><br><span class="line">                ename like #&#123;ename&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"deptnos!=null"</span>&gt;</span></span><br><span class="line">                and deptno in</span><br><span class="line">                <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"deptnos"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    #&#123;item&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--测试代码--&gt;</span></span><br><span class="line">    //TDD 测试驱动开发</span><br><span class="line">    @Test</span><br><span class="line">    public void test_queryScottempByMap() &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(true);</span><br><span class="line">        ScottEmpMapper scottEmpMapper = sqlSession.getMapper(ScottEmpMapper.class);</span><br><span class="line">        Map map = new HashMap();</span><br><span class="line">        map.put("ename", "%J%");</span><br><span class="line">        map.put("deptnos", new Integer[]&#123;10,20,30&#125;);</span><br><span class="line">        List<span class="tag">&lt;<span class="name">ScottEmp</span>&gt;</span> scottEmpList = scottEmpMapper.queryScottempByMap(map);</span><br><span class="line">        logger.info("queryScottEmpWhithDeptnoAndLikeJobOrEname  Result &#123;&#125;", scottEmpList);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>foreach元素的功能非常强大，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开辟匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此他不会偶然地附加多余地分隔符。</p><blockquote><p>注意：你可以将任何可迭代对象（如列表，集合等)和任何的字典或者数组对象传递给foreach作为集合参数。当使用可迭代对象或者数组时，index是当前迭代的次数。item的值便是本次迭代获取的元素。当使用字典（或者Map.Entry对象的集合时），index是键，item是值。</p><p>collection 迭代输出 List时为list ,迭代输出数组时为array,迭代输出当使用字典（或者Map.Entry),为其中的存储的集合名称</p><p>open 拼接SQL左边   item    close 拼接SQL右边  separator=“,” ：分隔符为”，“</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"deptnos"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                    #&#123;item&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3.扩展"></a>3.扩展</h2><h3 id="3-1分页插件"><a href="#3-1分页插件" class="headerlink" title="3.1分页插件"></a>3.1分页插件</h3><p>在进行数据库应用程序开发的时候，经常会使用到各种各样的分页，这里又开源社区提供了一个分页插件([PageHelper][<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md]),能够制成任何复杂的表单，多表查询。" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md]),能够制成任何复杂的表单，多表查询。</a></p><p>[使用方法][<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md]" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md]</a> ：中文的插件</p><ul><li><p>添加分页插件依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Mybatis分页插件--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.4&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置拦截器插件</p><p>在MyBatis的配置文件中添加拦截器插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置PageHelper分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageInterceptor"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"helperDialect"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，RowBounds方式的调用</span></span><br><span class="line">List&lt;Country&gt; list = sqlSession.selectList(<span class="string">"x.y.selectIf"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> RowBounds(<span class="number">0</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种，Mapper接口方式的调用，推荐这种使用方式。</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectIf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种，Mapper接口方式的调用，推荐这种使用方式。</span></span><br><span class="line">PageHelper.offsetPage(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectIf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四种，参数方法调用</span></span><br><span class="line"><span class="comment">//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CountryMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Country&gt; <span class="title">selectByPageNumSize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @Param(<span class="string">"user"</span>)</span> User user,</span></span><br><span class="line"><span class="function">            @<span class="title">Param</span><span class="params">(<span class="string">"pageNum"</span>)</span> <span class="keyword">int</span> pageNum, </span></span><br><span class="line"><span class="function">            @<span class="title">Param</span><span class="params">(<span class="string">"pageSize"</span>)</span> <span class="keyword">int</span> pageSize)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//配置supportMethodsArguments=true</span></span><br><span class="line"><span class="comment">//在代码中直接调用：</span></span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第五种，参数对象</span></span><br><span class="line"><span class="comment">//如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页</span></span><br><span class="line"><span class="comment">//有如下 User 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">//其他fields</span></span><br><span class="line">    <span class="comment">//下面两个参数名和 params 配置的名字一致</span></span><br><span class="line">    <span class="keyword">private</span> Integer pageNum;</span><br><span class="line">    <span class="keyword">private</span> Integer pageSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CountryMapper</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;Country&gt; <span class="title">selectByPageNumSize</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当 user 中的 pageNum!= null &amp;&amp; pageSize!= null 时，会自动分页</span></span><br><span class="line">List&lt;Country&gt; list = countryMapper.selectByPageNumSize(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第六种，ISelect 接口方式</span></span><br><span class="line"><span class="comment">//jdk6,7用法，创建接口</span></span><br><span class="line">Page&lt;Country&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>).doSelectPage(<span class="keyword">new</span> ISelect() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countryMapper.selectGroupBy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//jdk8 lambda用法</span></span><br><span class="line">Page&lt;Country&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>).doSelectPage(()-&gt; countryMapper.selectGroupBy());</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以直接返回PageInfo，注意doSelectPageInfo方法和doSelectPage</span></span><br><span class="line">pageInfo = PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>).doSelectPageInfo(<span class="keyword">new</span> ISelect() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countryMapper.selectGroupBy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//对应的lambda用法</span></span><br><span class="line">pageInfo = PageHelper.startPage(<span class="number">1</span>, <span class="number">10</span>).doSelectPageInfo(() -&gt; countryMapper.selectGroupBy());</span><br><span class="line"></span><br><span class="line"><span class="comment">//count查询，返回一个查询语句的count数</span></span><br><span class="line"><span class="keyword">long</span> total = PageHelper.count(<span class="keyword">new</span> ISelect() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        countryMapper.selectLike(country);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//lambda</span></span><br><span class="line">total = PageHelper.count(()-&gt;countryMapper.selectLike(country));</span><br></pre></td></tr></table></figure></li></ul><p>XML中的一些特殊字符的转译符</p><p><img src="/2019/04/21/Mybatis-动态SQL映射/Users\32183\AppData\Roaming\Typora\typora-user-images\1554724202872.png" alt="1554724202872"></p><p>练习：</p><blockquote><p><img src="/2019/04/21/Mybatis-动态SQL映射/Users\32183\AppData\Roaming\Typora\typora-user-images\1554725010278.png" alt="1554725010278"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Mybatis动态SQL映射&quot;&gt;&lt;a href=&quot;#Mybatis动态SQL映射&quot; class=&quot;headerlink&quot; title=&quot;Mybatis动态SQL映射&quot;&gt;&lt;/a&gt;Mybatis动态SQL映射&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;重点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解Mybatis的动态SQL映射原理&lt;/li&gt;
&lt;li&gt;掌握Mybatis的动态SQL映射编写&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/categories/JavaEE/"/>
    
    
      <category term="Mybatis" scheme="https://soyanga.github.io/tags/Mybatis/"/>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis Mapper映射</title>
    <link href="https://soyanga.github.io/2019/04/15/Mybatis-Mapper%E6%98%A0%E5%B0%84/"/>
    <id>https://soyanga.github.io/2019/04/15/Mybatis-Mapper映射/</id>
    <published>2019-04-15T15:41:11.000Z</published>
    <updated>2019-04-15T15:41:59.624Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Mybatis的Mapper映射"><a href="#Mybatis的Mapper映射" class="headerlink" title="Mybatis的Mapper映射"></a>Mybatis的Mapper映射</h1><blockquote><p>重点</p><ol><li>掌握Mybatis的基本SQL映射</li><li>掌握Mybatis中CRUD的SQL编写</li></ol></blockquote><h2 id="1-Mapper映射概念"><a href="#1-Mapper映射概念" class="headerlink" title="1 Mapper映射概念"></a>1 Mapper映射概念</h2><p>Mapper XML文件MyBatis的真正强大在于它的映射语句，也是解决<strong>JDBC</strong>大量重复代码</p><a id="more"></a><h2 id="2-Mapper文件结构"><a href="#2-Mapper文件结构" class="headerlink" title="2 Mapper文件结构"></a>2 Mapper文件结构</h2><p>SQL映射文件有很少得到几个顶级元素（按照他们应该被定义的顺序）：</p><ul><li><p>cache-给定命名空间的缓存配置</p></li><li><p>cache-ref-其他命名空间缓存配置的引用</p></li><li><p>resultMap-最复杂也是最强的元素，用来描述如何从数据库结果集中映射</p><ul><li>java对象中的属性名   数据库列名称 跟 jdbcType属性类型 javaType类型 一一对应起来</li><li>id对应数据库的主键 </li></ul></li><li><p>sql-可以被其他语句引用的可重用语句块</p><ul><li>简化查询 可重用的语句块 </li></ul></li><li><p>insert-映射插入语句</p></li><li><p>update-映射更新语句</p></li><li><p>delete-映射删除语句</p></li><li><p>select-映射查询语句</p><p>增删改查中的id对象Mapper接口中的方法名</p></li></ul><p>参考一个完整的Mapper示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.soyanga.mybatis.mapper.ScottGroupMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ScottGroup"</span> <span class="attr">type</span>=<span class="string">"ScottGroup"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"deptno"</span> <span class="attr">column</span>=<span class="string">"deptno"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"dname"</span> <span class="attr">column</span>=<span class="string">"dname"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"loc"</span> <span class="attr">column</span>=<span class="string">"loc"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;select deptno="selectScottGroup" resultMap="scottGroup"&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--select deptno,dname,loc from scott--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--where deptno = #&#123;deptno&#125;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/select&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--SQL片段--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"basic_column"</span>&gt;</span></span><br><span class="line">        id,dname,loc</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--插入信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertScottGroup"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"deptno"</span> <span class="attr">keyColumn</span>=<span class="string">"deptno"</span>&gt;</span></span><br><span class="line">        insert into dept (deptno,loc)</span><br><span class="line">                values (#&#123;deptno&#125;,#&#123;loc&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--修改更新信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateScottInfo"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteScottInfoById"</span>&gt;</span></span><br><span class="line">        delete from dept</span><br><span class="line">        where  id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"query"</span> <span class="attr">resultMap</span>=<span class="string">"ScottGroup"</span>&gt;</span></span><br><span class="line">        select </span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"basic_column"</span>/&gt;</span> </span><br><span class="line">        from dept where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>插入操作中的Tips:</p><p>插入信息中 useGeneratedKeys = “true”主键自增长 </p><p>keyProperty=”deptno” ：对应映射对象的属性名</p><p>keyColumn=”deptno”     对应表中主键名称</p><p>查询操作中的Tips：</p><p>id = mapper接口中得对应的查询方法，resultMap 对应的查询后的结果的类型 一般返回的都是java对应得数据库的对象的List集合</p></blockquote><h2 id="3-select命令"><a href="#3-select命令" class="headerlink" title="3 select命令"></a>3 select命令</h2><p>查询语句是MyBatis最常用的元素章之一。通常查询比修改频繁。查询方式多种</p><p>简单查询如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPerson"</span> <span class="attr">paramterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"hashmap"</span>&gt;</span></span><br><span class="line">select* form person where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个语句被称作selectPerson,接收一个int(或者Integer)类型的参数，并通过HashMap类型的对象，其中键是列名，值便是结果型中的对应值。参数符#{id}MyBatis创建一个预处理的语句参数，通过JDBC这样的一个参数在SQL中会由，并被传递到一个新的预处理语句中，这跟JBC中的SQL语句中的？类作业类似。</p><h2 id="4-Insert-Update-Delete"><a href="#4-Insert-Update-Delete" class="headerlink" title="4.Insert Update Delete"></a>4.Insert Update Delete</h2><p>Insert Update Delete都属于数据变更语句，他们的基本实现类似</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"insertAuthor"</span></span></span><br><span class="line"><span class="tag"><span class="attr">parametrType</span>=<span class="string">"domain.bolg.Author"</span></span></span><br><span class="line"><span class="tag"><span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyProperty</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyColumn</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag"><span class="attr">useGeneratedKeys</span>=<span class="string">""</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"updateAuthor"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">parametrType</span>=<span class="string">"domain.bolg.Author"</span></span></span><br><span class="line"><span class="tag"><span class="attr">flushCache</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">"PREPARED"</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">"20"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br></pre></td></tr></table></figure><p>MyBatis插入时自动生成主键有两种方式</p><ul><li>数据库自动生成主键</li><li>通过SQL语句生成主键，然后使用到主键字段</li></ul><p><strong>在实际开发的项目中，主键字段通常会有一定的规则，所以该两种方式实际上，仅仅体现MyBatis的扩展能力。</strong></p><h2 id="5-sql（复用SQL语句）"><a href="#5-sql（复用SQL语句）" class="headerlink" title="5 sql（复用SQL语句）"></a>5 sql（复用SQL语句）</h2><p>sql标签可以被用来定义可重用SQL代码片段，可以包含在其他语句中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span>$&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.pssword&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"basic_column"</span>&gt;</span>        id,group_id,title,content,is_prptected,background,remind_time,create_time,modify_time</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SQL片段可以被包含在SQL语句中，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from som_table t1 cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"query"</span> <span class="attr">resultMap</span>=<span class="string">"ScottGroup"</span>&gt;</span></span><br><span class="line">        select </span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"basic_column"</span>/&gt;</span> </span><br><span class="line">        from dept where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-parameter-参数"><a href="#6-parameter-参数" class="headerlink" title="6 parameter(参数)"></a>6 parameter(参数)</h2><p>Mybatis的参数类型通常有两种类型：一种时基本类型，一种是引用类型。</p><h3 id="6-1基本类型"><a href="#6-1基本类型" class="headerlink" title="6.1基本类型"></a>6.1基本类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span>&gt;</span></span><br><span class="line">    select id,username,password</span><br><span class="line">    form users</span><br><span class="line">    where id = #&#123;id&#125;   参数类型为基本类型</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2引用类型"><a href="#6-2引用类型" class="headerlink" title="6.2引用类型"></a>6.2引用类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">insert into users (id,username,password) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)  </span><br><span class="line">    写的是这个对象的属性名（id,username,password）</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面User类型的参数对象传递到语句中，id,username 和password属性中然后将他们的值传入预处理语句的参数中，这点相对于语句中传参是比较好的</p><p>且User的这些属性必须要有geter setter方法。</p><h3 id="6-3字符串"><a href="#6-3字符串" class="headerlink" title="6.3字符串"></a>6.3字符串</h3><p>默认情况下，使用#{}格式的语法会导致Mybatis创建PerparedStatement参数设置参数（就像使用？）。这样做更安全，更迅速，通常也是首选做法，不会</p><p>出一些错误，想在直接在SQL语句中插入一个不转义的字符串。比如，想ORDER BY,你可以直接用</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by $&#123;columnName&#125;</span><br></pre></td></tr></table></figure><p>这里MyBatis会修改或转义字符串。需要额外注意的是:用这种方式接受用的将其用于语句中的参数是不安全的，会导致潜在SQL注入攻击，因此不要使用这些字段，要么自行转译并检验。</p><h2 id="7-resultMap-查询结果映射"><a href="#7-resultMap-查询结果映射" class="headerlink" title="7.resultMap(查询结果映射)"></a>7.resultMap(查询结果映射)</h2><p>resultMap元素是MyBatis种最强大的元素，可以节省%90的JDBC代码量，并在一情形下允许你做一些JDBC不支持的事情。对复杂语句进行联合映射的时候，它很可能代替数千行的同等功能的代码，简化代码量的设计思想是，简单的原句不需要明确的结果映射，而复杂的语句只需要建立联系即可。</p><p>简单的映射，未指定明确的resultmap比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">select id,username,hashedPassword</span><br><span class="line">    form some_table</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述语句只是简单的将所有的列映射到HashMap的建上，这由resultType的参数指定，然而在大部分情况下都够用，但是HashMap不是一个很好的领域模型。你的使用JavaBean或POJO(Plain Old Java Objects,普通Java对象)作为领域模型对两者都支持。</p><p>Bean映射，指定resultmap比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定user Bean</span></span><br><span class="line"><span class="keyword">package</span> com.soyanga.mode1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String hashedPassword;</span><br><span class="line">    <span class="comment">//省略getter setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于JavaBean的规范，上面这个类有3个属性：id,username和hashedPassword属性会对应到select语句中列名。这个的一个JavaBean可以被映射到Result映射到HashMap一样简单。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.soyanga.mode1.User"</span>&gt;</span></span><br><span class="line">select id,username,hashedPassword</span><br><span class="line">    form som_table</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样情况下，MyaBatis会在幕后自动创建一个ResultMap,再基于属性名称映射在javaBean的属性上。如果，列名和属性名没有精确匹配<strong>，可以再select语句中的sql的as来起一个别名（sql中起别名–-SQL特性）来匹配标签</strong>。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.soyanga.mode1.User"</span>&gt;</span></span><br><span class="line">select </span><br><span class="line">    user_id  as"id"</span><br><span class="line">    user_name as "userName",</span><br><span class="line">    hashed_password as"hashedPassword"</span><br><span class="line">    form some_table</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ResultMap方式 极大的简化繁琐的配置，resultMap和resultType只能二选一</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"UserResultMap"</span> <span class="attr">type</span>=<span class="string">"com.soynga.model.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> <span class="attr">jdbcType</span>=<span class="string">"INTEGER"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">column</span>=<span class="string">"user_name"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"hashedPassword"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="8-cache-缓存"><a href="#8-cache-缓存" class="headerlink" title="8.cache(缓存)"></a>8.cache(缓存)</h2><h3 id="8-1一级缓存"><a href="#8-1一级缓存" class="headerlink" title="8.1一级缓存"></a>8.1一级缓存</h3><p>MyBatis默认开启了一级缓存，一级缓存是SqlSession层面进行缓存的。即同一个SqlSession，多次调用同一个Mapper和同一个方法的同一参数，只会进行一次数据库查询，然后把数据缓存到缓冲中，以后直接先从缓存中取出数据，不会直接去查数据库</p><p>默认<strong>开启一级缓存</strong>是在Mybatis的配置文件的settings元素中定义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mapper映射的二级缓存默认开启，需要mapper文件设置，以及实体类的支持序列化--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span> = <span class="string">"cachaeEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--session级别的一级缓存默认开启--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-2二级缓存"><a href="#8-2二级缓存" class="headerlink" title="8.2二级缓存"></a>8.2二级缓存</h3><p>默认情况下Mapper中是没有开启缓存的，除了局部的session缓存，可以增强变现而且处理循环依赖也是必须的，要开启二级缓存，需要在你SQL映射文件中添加一行： 实体类需要实现<strong>Serializable接口支持序列化</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>从cache字面上看就是这样。这个简单语句的效果如下：</p><ul><li><p>映射语句文件中的所有<strong>select语句</strong>将会被缓存</p></li><li><p>映射语句文件中的所有<strong>insert,update和delete语句</strong>会刷新缓存</p></li><li><p>缓存会使用<strong>Least Recently Used</strong>（<strong>LRU,最近最少使用的</strong>）算法来收回</p></li><li><p>根据时间表(比如 <strong>NO Flush interval,没有刷新间隔</strong>)，缓存不会以任何时间顺序来刷新</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span>&gt;</span>  //单位是ms</span><br></pre></td></tr></table></figure></li><li><p>缓存会存储<strong>列表集合或对象</strong>(无论查询方式返回什么)的<strong>1024个引用</strong></p></li><li><p>缓存会被视为是<strong>read/write(可读/可写)的缓存</strong>，意味着对象检索不是共享的，而且可以安全地被调用者修改，而不是干扰其他调用者或线程所做的潜在修改。（<strong>两个策略</strong>）</p></li></ul><p><strong>缓存命中率：</strong>Cache Hit Ratio(缓存命中)  关心缓存命中率</p><h3 id="8-3缓存属性"><a href="#8-3缓存属性" class="headerlink" title="8.3缓存属性"></a>8.3缓存属性</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"FIFO"</span> <span class="attr">flushInterval</span>=<span class="string">"60000"</span> <span class="attr">size</span>=<span class="string">"512"</span> <span class="attr">redOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>配置了一个FIFO回收策略的缓存。每隔60秒刷新，存储结果对象或列表的512隔引用，而且返回的对象被认为是只读的，因此在不同线程中的调用者之间修改他们会导致冲突。</p><p>eviction（回收策略）：</p><ul><li>LRU  -（默认值）最近最少使用的：移除最长时间不被使用的对象。</li><li>FIFO - （先进先出） ：按对象进入缓存的顺序来移除它们。</li><li>SOFT -（软引用）：移除基于垃圾回收器状态和软引用规则的对象。</li><li>WEAK - （弱引用）：更积极地移除基于垃圾回收器状态和弱引用规则地对象。</li></ul><p>flushInerval(刷新间隔)：</p><ul><li>可以被设置为任意正整数，而且他们代表一个合理的毫秒形式的时间段</li><li>默认情况是不设置，也就是没有刷新间隔的，缓存仅仅调用语句时刷新</li></ul><p>size（引用数目）</p><ul><li>可以被设置为任意正整数，要记住你缓存的对象数目和运行环境的可用内存资源数目。</li><li>默认值是1024。</li></ul><p>readOnly（只读）</p><ul><li>可以设置为 true 或 false</li><li>只读缓存会给调用者返回缓存对象的相同实例，<strong>因此这些对象不能被修改，者提供了很重要的性能优势。</strong></li><li>可读写的<strong>缓存会返回缓存对象的拷贝</strong>(<strong>通过序列化)</strong>，这样会慢一点，的但是安全，因此默认是false.</li></ul><h3 id="8-4自定义缓存"><a href="#8-4自定义缓存" class="headerlink" title="8.4自定义缓存"></a>8.4自定义缓存</h3><p>除了使用自定义缓存的方式，还可以通过实现自己的缓存或者为其他第三方方案创建适配器来完全覆盖缓存行为。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"com.soyanga.mybaits.plugin.MyCache"</span></span></span><br></pre></td></tr></table></figure><p>这个实例展示了如何使用一个自定义的缓存实现。type属性指定的类必须实现<code>org.mybatis.cache.Cache</code>接口。这个接口是MyBatis框架中很多复杂接口之一，但是简单实现即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key,Object value)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">haskey</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义实现一个简单的Cache</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soyanga.mybatis.plugin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.cache.CacheKey;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReadWriteLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: mybatis-case</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: MyCache 自定义缓存利用MyBatis的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: SOYANGA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span>: 2019-04-05 11:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> MyBatis会为，每一个nameSpace配置一个Cache实例 将其中的id属性(nameSpace字符串)作为为cache的一个唯一标识</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyCache.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * nameSpace中的id 作为cache的标识符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开辟容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer capacity = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置最大缓存数目用户缓存回收策略--（即满即清空）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxSize = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将key和value一一对应起来 内部存储数据结构（线程安全的Map）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Object, Object&gt; cacaheData = <span class="keyword">new</span> ConcurrentHashMap&lt;Object, Object&gt;(capacity);  <span class="comment">//默认开辟1024个</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Cache的标识id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The identifier of this cache</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将key和value一一对应起来  (HashMap/数据库)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   Can be any object but usually it is a &#123;<span class="doctag">@link</span> CacheKey&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value The result of a select.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//即满即清空 回收策略</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cacaheData.size() &gt;= <span class="keyword">this</span>.getMaxSize()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        logger.debug(<span class="string">"putObject key=&#123;&#125; value=&#123;&#125;"</span>, key, value);</span><br><span class="line">        <span class="keyword">this</span>.cacaheData.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取缓存中的对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The object stored in the cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Object value = cacaheData.get(key);</span><br><span class="line">        logger.debug(<span class="string">"getObject key=&#123;&#125; value=&#123;&#125;"</span>, key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    As of 3.3.0 this method is only called during a rollback for any previous value that was missing in the cache.</span></span><br><span class="line"><span class="comment">//    This lets any blocking cache to release the lock that may have previously put on the key.</span></span><br><span class="line"><span class="comment">//    A blocking cache puts a lock when a value is null and releases it when the value is back again.</span></span><br><span class="line"><span class="comment">//    This way other threads will wait for the value to be available instead of hitting the database.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存中的某个对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Not used</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Object value = cacaheData.remove(key);</span><br><span class="line">        logger.debug(<span class="string">"removeObject key=&#123;&#125; value=&#123;&#125;"</span>, key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears this cache instance</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"clear cache"</span>);</span><br><span class="line">        cacaheData.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并不是核心方法，可以不要去实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并不是核心类，可以不去实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMaxSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxSize</span><span class="params">(Integer maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓存配置和缓存实例绑定在SQL映射文件（mapper文件）的命名空间（nameSpace）很重要的。因此，所有在相同命名空间的语句,正如绑定的缓存一样。<strong>语句可以修改和缓存交互方式</strong>，<strong>或在语句的基础上使用两种简单的属性来完全排除它们</strong>。默认情况下，语句可以这样来配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"false"</span> <span class="attr">usedCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果想改变默认的缓存行为，可以通过flushCache和useCache属性。比如在一情况下需要通过一个查询语句来刷新新缓存。</p><h3 id="8-5-第三方缓存"><a href="#8-5-第三方缓存" class="headerlink" title="8.5 第三方缓存"></a>8.5 第三方缓存</h3><p>Mybatis的Cache实现比较简单，真正使用二级缓存的时候，都会选择专业的缓存框架。EHcache是在Java领域广泛使用的分布式缓存解决方案框架。通过Mybatis集成EHcache来实现二级缓存。</p><p>memcache k - v 内存缓存</p><p><strong>redis</strong>         k - v  list map set skipList  缓存系统</p><ul><li><p>添加Mybatis集成Ehcache依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybstis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加缓存配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.EhcacheCache"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeToIdleSeconds"</span> <span class="attr">value</span>=<span class="string">"3600"</span>/&gt;</span><span class="comment">&lt;!--hour--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeToLiveSeconds"</span> <span class="attr">value</span>=<span class="string">"3600"</span>/&gt;</span><span class="comment">&lt;!--hour--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxEntriesLocalHeap"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxEntriesLocalDisk"</span> <span class="attr">value</span>=<span class="string">"10000000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"memoryStoreEvictionPolicy"</span> <span class="attr">value</span>=<span class="string">"LRU"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加Ehcache的配置文件（<code>classPath:src/main/resources/ehcache.xml</code>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">java.io.tmpdir  ：默认的temp文件目录</span></span><br><span class="line"><span class="comment">maxElementsInMemory :内存中最大缓存对象数</span></span><br><span class="line"><span class="comment">maxElementsOnDisk :磁盘中最大缓存对象数，若是0表示无穷大</span></span><br><span class="line"><span class="comment">eternal :Element是否永久有效，一但设置了，timeout将不起作用</span></span><br><span class="line"><span class="comment">overflowToDisk ;配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcahche将会Element写到磁盘中</span></span><br><span class="line"><span class="comment">timeToIdleSeconds :设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认属性值是0，也就是可闲置时间无穷大</span></span><br><span class="line"><span class="comment">timeToLiveSeconds ：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0，也就是element存活时间无穷大</span></span><br><span class="line"><span class="comment">diskExpiryThreadTntervalSeconds :磁盘失效线程运行时间间隔，默认是120秒--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--diskStore path="java.io.tmpdir/mybatis-cache"/存储临时目录--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"java.io.tmpdir/mybatis-cache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">name</span>=<span class="string">"default"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">maxElementsOnDisk</span>=<span class="string">"10000000"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span><span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_queryScottEmpAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一次打开SqlSession</span></span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    ScottEmpMapper scottEmpMapper = sqlSession.getMapper(ScottEmpMapper.class);</span><br><span class="line">    List&lt;ScottEmp&gt; scottEmpList = scottEmpMapper.queryScottEmpAll();</span><br><span class="line">    logger.info(<span class="string">"test_queryScottEmpAll  FirstResult: &#123;&#125;"</span>, scottEmpList);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//第二次打开SqlSession</span></span><br><span class="line">    sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    scottEmpMapper = sqlSession.getMapper(ScottEmpMapper.class);</span><br><span class="line">    List&lt;ScottEmp&gt; scottEmpList2 = scottEmpMapper.queryScottEmpAll();</span><br><span class="line">    logger.info(<span class="string">"test_queryScottEmpAll SecondResult: &#123;&#125;"</span>, scottEmpList2);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//第二次打开SqlSession</span></span><br><span class="line">    sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    scottEmpMapper = sqlSession.getMapper(ScottEmpMapper.class);</span><br><span class="line">    List&lt;ScottEmp&gt; scottEmpList3 = scottEmpMapper.queryScottEmpAll();</span><br><span class="line">    logger.info(<span class="string">"test_queryScottEmpAll ThirResult: &#123;&#125;"</span>, scottEmpList3);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​    返回结果日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">00.385</span> [main] DEBUG org.apache.ibatis.logging.LogFactory - Logging initialized using <span class="string">'class org.apache.ibatis.logging.slf4j.Slf4jImpl'</span> adapter.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">00.723</span> [main] DEBUG org.apache.ibatis.logging.LogFactory - Logging initialized using <span class="string">'class org.apache.ibatis.logging.slf4j.Slf4jImpl'</span> adapter.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">00.778</span> [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">00.778</span> [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">00.778</span> [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">00.778</span> [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - PooledDataSource forcefully closed/removed all connections.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.058</span> [main] DEBUG net.sf.ehcache.config.ConfigurationFactory - Configuring ehcache from ehcache.xml found in the classpath: file:/D:/IDEA%<span class="number">20</span>project/mybatis-<span class="keyword">case</span>/target/classes/ehcache.xml</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.058</span> [main] DEBUG net.sf.ehcache.config.ConfigurationFactory - Configuring ehcache from URL: file:/D:/IDEA%<span class="number">20</span>project/mybatis-<span class="keyword">case</span>/target/classes/ehcache.xml</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.061</span> [main] DEBUG net.sf.ehcache.config.ConfigurationFactory - Configuring ehcache from InputStream</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.090</span> [main] DEBUG net.sf.ehcache.config.BeanHandler - Ignoring ehcache attribute xmlns:xsi</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.090</span> [main] DEBUG net.sf.ehcache.config.BeanHandler - Ignoring ehcache attribute xsi:noNamespaceSchemaLocation</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.092</span> [main] DEBUG net.sf.ehcache.config.DiskStoreConfiguration - Disk Store Path: C:\Users\<span class="number">32183</span>\AppData\Local\Temp\/mybatis-cache</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.114</span> [main] DEBUG net.sf.ehcache.CacheManager - Creating <span class="keyword">new</span> CacheManager with <span class="keyword">default</span> config</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.119</span> [main] DEBUG net.sf.ehcache.util.PropertyUtil - propertiesString is <span class="keyword">null</span>.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.132</span> [main] DEBUG net.sf.ehcache.config.ConfigurationHelper - No CacheManagerEventListenerFactory <span class="class"><span class="keyword">class</span> <span class="title">specified</span>. <span class="title">Skipping</span>...</span></span><br><span class="line">16:33:01.900 [main] DEBUG net.sf.ehcache.Cache - No BootstrapCacheLoaderFactory class specified. Skipping...</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.901</span> [main] DEBUG net.sf.ehcache.Cache - CacheWriter factory not configured. Skipping...</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.903</span> [main] DEBUG net.sf.ehcache.config.ConfigurationHelper - No CacheExceptionHandlerFactory <span class="class"><span class="keyword">class</span> <span class="title">specified</span>. <span class="title">Skipping</span>...</span></span><br><span class="line">16:33:01.938 [main] DEBUG net.sf.ehcache.store.MemoryStore - Initialized net.sf.ehcache.store.MemoryStore for com.soyanga.mybatis.mapper.ScottEmpMapper</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.951</span> [main] DEBUG net.sf.ehcache.DiskStorePathManager - Using diskstore path C:\Users\<span class="number">32183</span>\AppData\Local\Temp\mybatis-cache</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.951</span> [main] DEBUG net.sf.ehcache.DiskStorePathManager - Holding exclusive lock on C:\Users\<span class="number">32183</span>\AppData\Local\Temp\mybatis-cache\.ehcache-diskstore.lock</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.955</span> [main] DEBUG net.sf.ehcache.store.disk.DiskStorageFactory - Failed to delete file com%<span class="number">002</span>esoyanga%<span class="number">002</span>emybatis%<span class="number">002</span>emapper%<span class="number">002</span>e%<span class="number">0053</span>cott%<span class="number">0045</span>mp%<span class="number">004</span>dapper.index</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">01.967</span> [main] DEBUG net.sf.ehcache.store.disk.DiskStorageFactory - <span class="function">Matching data file <span class="title">missing</span> <span class="params">(or empty)</span> <span class="keyword">for</span> index file. Deleting index file C:\Users\32183\AppData\Local\Temp\mybatis-cache\com%002esoyanga%002emybatis%002emapper%002e%0053cott%0045mp%004dapper.index</span></span><br><span class="line"><span class="function">16:33:01.968 [main] DEBUG net.sf.ehcache.store.disk.DiskStorageFactory - Failed to delete file com%002esoyanga%002emybatis%002emapper%002e%0053cott%0045mp%004dapper.index</span></span><br><span class="line"><span class="function">16:33:01.977 [main] DEBUG net.sf.ehcache.Cache - Initialised cache: com.soyanga.mybatis.mapper.ScottEmpMapper</span></span><br><span class="line"><span class="function">16:33:01.977 [main] DEBUG net.sf.ehcache.config.ConfigurationHelper - CacheDecoratorFactory not configured <span class="keyword">for</span> defaultCache. Skipping <span class="keyword">for</span> 'com.soyanga.mybatis.mapper.ScottEmpMapper'.</span></span><br><span class="line"><span class="function">16:33:02.017 [main] DEBUG com.soyanga.mybatis.mapper.ScottEmpMapper - Cache Hit Ratio [com.soyanga.mybatis.mapper.ScottEmpMapper]: 0.0</span></span><br><span class="line"><span class="function">16:33:02.023 [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Opening JDBC Connection</span></span><br><span class="line"><span class="function">Fri Apr 05 16:33:02 CST 2019 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by <span class="keyword">default</span> <span class="keyword">if</span> explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to '<span class="keyword">false</span>'. You need either to explicitly disable SSL by setting useSSL</span>=<span class="keyword">false</span>, or set useSSL=<span class="keyword">true</span> and provide truststore <span class="keyword">for</span> server certificate verification.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.342</span> [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Created connection <span class="number">98394724</span>.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.344</span> [main] DEBUG com.soyanga.mybatis.mapper.ScottEmpMapper.queryScottEmpAll - ==&gt;  Preparing: select empno as <span class="string">'empno'</span>, ename as <span class="string">'ename'</span>, job as <span class="string">'job'</span>, mgr as <span class="string">'mgr'</span> , sal as <span class="string">'sal'</span>, comm as <span class="string">'common'</span>, deptno as <span class="string">'deptno'</span>, hiredate as <span class="string">'hiredate'</span> from emp </span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.376</span> [main] DEBUG com.soyanga.mybatis.mapper.ScottEmpMapper.queryScottEmpAll - ==&gt; Parameters: </span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.413</span> [main] DEBUG com.soyanga.mybatis.mapper.ScottEmpMapper.queryScottEmpAll - &lt;==      Total: <span class="number">15</span></span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.414</span> [main] INFO com.soyanga.mybatis.mapper.ScottEmpMapperTest - test_queryScottEmpAll  FirstResult: [ScottEmp&#123;empno=<span class="string">'7369'</span>, ename=<span class="string">'SMITH'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7902</span>, hiredate=Wed Dec <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1980</span>, sal=<span class="number">800.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7499'</span>, ename=<span class="string">'ALLEN'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Fri Feb <span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1600.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7521'</span>, ename=<span class="string">'WARD'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Sun Feb <span class="number">22</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1250.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7566'</span>, ename=<span class="string">'JONES'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Thu Apr <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2975.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7654'</span>, ename=<span class="string">'MARTIN'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Mon Sep <span class="number">28</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1250.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7698'</span>, ename=<span class="string">'BLAKE'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Fri May <span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2850.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7782'</span>, ename=<span class="string">'CLARK'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Tue Jun <span class="number">09</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2450.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'7788'</span>, ename=<span class="string">'SCOTT'</span>, job=<span class="string">'ANALYST'</span>, mgr=<span class="number">7566</span>, hiredate=Sun Apr <span class="number">19</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CDT <span class="number">1987</span>, sal=<span class="number">3000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7839'</span>, ename=<span class="string">'KING'</span>, job=<span class="string">'PRESIDENT'</span>, mgr=<span class="keyword">null</span>, hiredate=Tue Nov <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">5000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'7844'</span>, ename=<span class="string">'TURNER'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Tue Sep <span class="number">08</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1500.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7876'</span>, ename=<span class="string">'ADAMS'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7788</span>, hiredate=Sat May <span class="number">23</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CDT <span class="number">1987</span>, sal=<span class="number">1100.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7900'</span>, ename=<span class="string">'JAMES'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7698</span>, hiredate=Thu Dec <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">950.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7902'</span>, ename=<span class="string">'FORD'</span>, job=<span class="string">'ANALYST'</span>, mgr=<span class="number">7566</span>, hiredate=Thu Dec <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">3000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7934'</span>, ename=<span class="string">'MILLER'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7782</span>, hiredate=Sat Jan <span class="number">23</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1982</span>, sal=<span class="number">1300.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'1314'</span>, ename=<span class="string">'SOYANGA'</span>, job=<span class="string">'BOSS'</span>, mgr=<span class="number">10000</span>, hiredate=Wed Apr <span class="number">03</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">39</span> CST <span class="number">2019</span>, sal=<span class="number">8888.88</span>, comm=<span class="keyword">null</span>, deptno=<span class="keyword">null</span>&#125;]</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.415</span> [main] DEBUG net.sf.ehcache.store.disk.Segment - put added <span class="number">0</span> on heap</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.418</span> [main] DEBUG org.apache.ibatis.transaction.jdbc.JdbcTransaction - Closing JDBC Connection [com.mysql.jdbc.JDBC4Connection@<span class="number">5</span>dd6264]</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.419</span> [main] DEBUG org.apache.ibatis.datasource.pooled.PooledDataSource - Returned connection <span class="number">98394724</span> to pool.</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.419</span> [main] DEBUG com.soyanga.mybatis.mapper.ScottEmpMapper - Cache Hit Ratio [com.soyanga.mybatis.mapper.ScottEmpMapper]: <span class="number">0.5</span></span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.419</span> [main] INFO com.soyanga.mybatis.mapper.ScottEmpMapperTest - test_queryScottEmpAll SecondResult: [ScottEmp&#123;empno=<span class="string">'7369'</span>, ename=<span class="string">'SMITH'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7902</span>, hiredate=Wed Dec <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1980</span>, sal=<span class="number">800.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7499'</span>, ename=<span class="string">'ALLEN'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Fri Feb <span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1600.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7521'</span>, ename=<span class="string">'WARD'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Sun Feb <span class="number">22</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1250.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7566'</span>, ename=<span class="string">'JONES'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Thu Apr <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2975.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7654'</span>, ename=<span class="string">'MARTIN'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Mon Sep <span class="number">28</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1250.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7698'</span>, ename=<span class="string">'BLAKE'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Fri May <span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2850.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7782'</span>, ename=<span class="string">'CLARK'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Tue Jun <span class="number">09</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2450.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'7788'</span>, ename=<span class="string">'SCOTT'</span>, job=<span class="string">'ANALYST'</span>, mgr=<span class="number">7566</span>, hiredate=Sun Apr <span class="number">19</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CDT <span class="number">1987</span>, sal=<span class="number">3000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7839'</span>, ename=<span class="string">'KING'</span>, job=<span class="string">'PRESIDENT'</span>, mgr=<span class="keyword">null</span>, hiredate=Tue Nov <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">5000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'7844'</span>, ename=<span class="string">'TURNER'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Tue Sep <span class="number">08</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1500.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7876'</span>, ename=<span class="string">'ADAMS'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7788</span>, hiredate=Sat May <span class="number">23</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CDT <span class="number">1987</span>, sal=<span class="number">1100.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7900'</span>, ename=<span class="string">'JAMES'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7698</span>, hiredate=Thu Dec <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">950.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7902'</span>, ename=<span class="string">'FORD'</span>, job=<span class="string">'ANALYST'</span>, mgr=<span class="number">7566</span>, hiredate=Thu Dec <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">3000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7934'</span>, ename=<span class="string">'MILLER'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7782</span>, hiredate=Sat Jan <span class="number">23</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1982</span>, sal=<span class="number">1300.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'1314'</span>, ename=<span class="string">'SOYANGA'</span>, job=<span class="string">'BOSS'</span>, mgr=<span class="number">10000</span>, hiredate=Wed Apr <span class="number">03</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">39</span> CST <span class="number">2019</span>, sal=<span class="number">8888.88</span>, comm=<span class="keyword">null</span>, deptno=<span class="keyword">null</span>&#125;]</span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.420</span> [main] DEBUG com.soyanga.mybatis.mapper.ScottEmpMapper - Cache Hit Ratio [com.soyanga.mybatis.mapper.ScottEmpMapper]: <span class="number">0.6666666666666666</span></span><br><span class="line"><span class="number">16</span>:<span class="number">33</span>:<span class="number">02.420</span> [main] INFO com.soyanga.mybatis.mapper.ScottEmpMapperTest - test_queryScottEmpAll ThirResult: [ScottEmp&#123;empno=<span class="string">'7369'</span>, ename=<span class="string">'SMITH'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7902</span>, hiredate=Wed Dec <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1980</span>, sal=<span class="number">800.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7499'</span>, ename=<span class="string">'ALLEN'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Fri Feb <span class="number">20</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1600.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7521'</span>, ename=<span class="string">'WARD'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Sun Feb <span class="number">22</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1250.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7566'</span>, ename=<span class="string">'JONES'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Thu Apr <span class="number">02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2975.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7654'</span>, ename=<span class="string">'MARTIN'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Mon Sep <span class="number">28</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1250.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7698'</span>, ename=<span class="string">'BLAKE'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Fri May <span class="number">01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2850.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7782'</span>, ename=<span class="string">'CLARK'</span>, job=<span class="string">'MANAGER'</span>, mgr=<span class="number">7839</span>, hiredate=Tue Jun <span class="number">09</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">2450.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'7788'</span>, ename=<span class="string">'SCOTT'</span>, job=<span class="string">'ANALYST'</span>, mgr=<span class="number">7566</span>, hiredate=Sun Apr <span class="number">19</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CDT <span class="number">1987</span>, sal=<span class="number">3000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7839'</span>, ename=<span class="string">'KING'</span>, job=<span class="string">'PRESIDENT'</span>, mgr=<span class="keyword">null</span>, hiredate=Tue Nov <span class="number">17</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">5000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'7844'</span>, ename=<span class="string">'TURNER'</span>, job=<span class="string">'SALESMAN'</span>, mgr=<span class="number">7698</span>, hiredate=Tue Sep <span class="number">08</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">1500.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">30</span>&#125;, ScottEmp&#123;empno=<span class="string">'7876'</span>, ename=<span class="string">'ADAMS'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7788</span>, hiredate=Sat May <span class="number">23</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CDT <span class="number">1987</span>, sal=<span class="number">1100.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7900'</span>, ename=<span class="string">'JAMES'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7698</span>, hiredate=Thu Dec <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">950.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7902'</span>, ename=<span class="string">'FORD'</span>, job=<span class="string">'ANALYST'</span>, mgr=<span class="number">7566</span>, hiredate=Thu Dec <span class="number">03</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1981</span>, sal=<span class="number">3000.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">20</span>&#125;, ScottEmp&#123;empno=<span class="string">'7934'</span>, ename=<span class="string">'MILLER'</span>, job=<span class="string">'CLERK'</span>, mgr=<span class="number">7782</span>, hiredate=Sat Jan <span class="number">23</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> CST <span class="number">1982</span>, sal=<span class="number">1300.00</span>, comm=<span class="keyword">null</span>, deptno=<span class="number">10</span>&#125;, ScottEmp&#123;empno=<span class="string">'1314'</span>, ename=<span class="string">'SOYANGA'</span>, job=<span class="string">'BOSS'</span>, mgr=<span class="number">10000</span>, hiredate=Wed Apr <span class="number">03</span> <span class="number">22</span>:<span class="number">12</span>:<span class="number">39</span> CST <span class="number">2019</span>, sal=<span class="number">8888.88</span>, comm=<span class="keyword">null</span>, deptno=<span class="keyword">null</span>&#125;]</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p>结论：缓存命中率提高 0 -&gt;0.5–&gt;0.666666所有配置缓存是生效的，且除了第一次以外的其他两次查询没有生成SQL语句是直接在缓存中进行查询的</p></blockquote><p>小Tips：</p><blockquote><p>Ehcache本身不支持Mybatis的Cache接口，MyBatis创建了一个新的接口（org\mybatis\caches\ehcache）来将Ehcache和Mybatis的Cache适配起来   –——<strong>适配器设计模式</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;Mybatis的Mapper映射&quot;&gt;&lt;a href=&quot;#Mybatis的Mapper映射&quot; class=&quot;headerlink&quot; title=&quot;Mybatis的Mapper映射&quot;&gt;&lt;/a&gt;Mybatis的Mapper映射&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;重点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;掌握Mybatis的基本SQL映射&lt;/li&gt;
&lt;li&gt;掌握Mybatis中CRUD的SQL编写&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-Mapper映射概念&quot;&gt;&lt;a href=&quot;#1-Mapper映射概念&quot; class=&quot;headerlink&quot; title=&quot;1 Mapper映射概念&quot;&gt;&lt;/a&gt;1 Mapper映射概念&lt;/h2&gt;&lt;p&gt;Mapper XML文件MyBatis的真正强大在于它的映射语句，也是解决&lt;strong&gt;JDBC&lt;/strong&gt;大量重复代码&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/categories/JavaEE/"/>
    
    
      <category term="Mybatis" scheme="https://soyanga.github.io/tags/Mybatis/"/>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis配置</title>
    <link href="https://soyanga.github.io/2019/04/05/Mybatis%E9%85%8D%E7%BD%AE/"/>
    <id>https://soyanga.github.io/2019/04/05/Mybatis配置/</id>
    <published>2019-04-05T15:58:18.000Z</published>
    <updated>2019-04-05T15:59:39.196Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Mybatis的配置"><a href="#Mybatis的配置" class="headerlink" title="Mybatis的配置"></a>Mybatis的配置</h1><p><strong>重点</strong></p><p>==<strong>了解掌握Mybatis的配置</strong>==</p><p>==<strong>掌握Mybatis的environments配置</strong>==</p><h2 id="1-XML配置"><a href="#1-XML配置" class="headerlink" title="1.XML配置"></a>1.XML配置</h2><h3 id="1-1XML结构"><a href="#1-1XML结构" class="headerlink" title="1.1XML结构"></a>1.1XML结构</h3><p>Mybatis的配置文件包含了会影响MyBatis行为的设置(settings)和属性(properties)信息。其中配置文件的顶层结构如下：</p><ul><li>configuration 配置<ul><li>properties 属性</li><li>settings 设置</li><li>typeAliass 类型别名</li><li>objectFactory 对象工厂</li><li>plugins 插件</li><li><strong>environments 环境集合</strong><ul><li>environment 环境<ul><li>transactionManager 事务管理</li><li>dataSource 数据源</li></ul></li></ul></li><li>databaseldProvider 数据库厂商标识</li><li><strong>mappers 映射器</strong></li></ul></li></ul><a id="more"></a><h3 id="1-2属性-properties"><a href="#1-2属性-properties" class="headerlink" title="1.2属性(properties )"></a>1.2属性(properties )</h3><p>这些属性可外部配置且课动态替换的，既可以在典型的java属性文件中配置，亦可通过properties元素的子元素来传递。例如:</p><p><em>k-v格式</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"config/database.properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"dev_user"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"F2Fa3!33TYyg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中属性就可以在整个配置文件中使用，来替换需要动态配置属性值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子中的username和password将会由properties元素中设置的相应值来替换。driver和url属性将会由config.propertied文件中对应得值来替换。这样就为配置提供了</p><p>属性也可以被传递到SqlSessionFactoryBuilder.build()方法中。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader,props);</span><br><span class="line"><span class="comment">//...or...</span></span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader,environment,props);</span><br></pre></td></tr></table></figure><p>如果属性在不只一个地方进行了配置，那么MyBatis将按照下面得顺序来加载。</p><ul><li><p>在properties元素体内指定得属性首先被读取。</p></li><li><p>然后根据properties元素中得resource属性读取类路径下属性文件或根据url属性指定得路径读取属性文件，并覆盖以读取得同名属性。</p></li><li><p>最后读取作为方法参数传递的属性，并覆以读取的同名属性。</p><p><strong>因此，通过方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级的是properties属性中指定的属性。</strong> <em>（最先读取的属性的会被后来读取同名属性的方式覆盖)</em></p></li></ul><p>从Mybatis 3.4.2开始，你可以为占位符指定一个默认值。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果username的key不存在的话就使用ut_user作为username的值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username:ut_user&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个特性默认是关闭的。如果你想为占位符指定一个默认值，你应该添加一个指定的属性来开启这个特性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"config/database.properties"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--属性解析启动默认值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"org.apache.ibatis.parsing.PropertyParser.enable-default-value"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-3-settings-核心配置"><a href="#1-3-settings-核心配置" class="headerlink" title="1.3 settings(核心配置)"></a>1.3 settings(核心配置)</h3><p>这时Mybatis中极为重要的配置，他们会改变Mybatis的运行时行为。下表描述了设置中各项的意图，默认值等。</p><table><thead><tr><th>设置参数</th><th>描述</th><th>有效值</th><th>默认值</th></tr></thead><tbody><tr><td>cacheEnabled</td><td>该设置影响所有映射器中配置的缓存全局开关</td><td>true\</td><td>false</td><td>true</td></tr><tr><td>lazyLoadingEnabled</td><td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。特定关联关系中可通过设置<code>fetchType</code>属性来覆盖该项开关状态</td><td>true\</td><td>false</td><td>false</td></tr><tr><td>aggresslveLazyLoading</td><td>当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需要加载（参考<code>lazyLoafTriggerMethodes</code>）</td><td>true\</td><td>false</td><td>false(true in  &lt;= 3.4.1)</td></tr><tr><td>mulitipleResultSetsEnabled</td><td>是否允许单一语句返回多结果集(需要兼容驱动)</td><td>true\</td><td>false</td><td>true</td></tr><tr><td>useColumnLabel</td><td>使用列标签代替列名。不同驱动载这方面会有不同的表现，具体可参考相关驱动文档或者通过测试这两种不同的模式来观察所有驱动的结果</td><td>true\</td><td>false</td><td>true</td></tr><tr><td>useGeneratedKeys</td><td>允许JDBC支持自动生成主键，需要驱动兼容。如果设备为true则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可以正常工作（比如Derby）</td><td>true\</td><td>false</td><td>false</td></tr><tr><td>autoMappingUnknownColumnBehavior</td><td>- 指定发现自动映射目标未知列(或者位置属性类型)的行为。<code>NONE</code>：不做任何反应   <code>WARNING</code>：输出提醒日志<code>FAILING</code>：映射失败（抛出<code>SqlSessionExection</code>）</td><td>NONE,WARNING,FAILING</td><td>NONE</td></tr><tr><td>autoMappingBehavior</td><td>指定Mybatis应如何自动映射列到字段或者属性。NONE表示取消自动映射；PARTIAL只会自动映射没有定义嵌套结果集映射的结果集。FULL会自动映射任意复杂的结果集(无论是否嵌套)</td><td>NONE，PARTIAL,FULL</td><td>PARTIAL</td></tr><tr><td>defaultExecutorType</td><td>配置默认的执行器，SIMPLE就是普通的执行器；REUSE执行器会重用预处理语句(perpared statements) :BATCH执行器将重用语句并执行批量更新。</td><td>SIMPLE REUSE BATCH</td><td>SIMPLE</td></tr></tbody></table><table><thead><tr><th>localCaheScope</th><th>Mybatis利用本地缓存机制(Local Cache)防止循环引用(circular references)和加速重复嵌套查询。默认值为SESION，这种情况下会缓存一个会话执行的所有查询。若设置为STATEMENT，本地会话仅用在语句执行上，对相同SqlSession的不同调用将不会共享数据</th><th>SESSION  STATEMENT</th><th>SESSION</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>完整配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mutipleResultSetsEnbale"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span> = <span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedkeys"</span> <span class="attr">value</span> = <span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"atuoMapingBehavior"</span> <span class="attr">value</span>=<span class="string">"PARTIAl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingUnknownColumnBehavior"</span> <span class="attr">value</span>=<span class="string">"WARNING"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultFetchSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defauktStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"safeRowBoundsEnable"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreTocamelCase"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span>  <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">nme</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"OTHER"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMenthods"</span> <span class="attr">value</span>=<span class="string">"equals,clone,hashCode,toString"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-1配置日志"><a href="#1-3-1配置日志" class="headerlink" title="1.3.1配置日志"></a>1.3.1配置日志</h4><ul><li>日志框架：<a href="https://www.slf4j.org/manual.html" target="_blank" rel="noopener">SLF4j </a>的 Logback实现</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--日志框架--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>配置日志</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis配置，主要影响mybatis的运行行为--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"SLF4j"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>SLE4j的实现类 -&gt;Logback</p><h3 id="1-4-类型别名-typeAliases"><a href="#1-4-类型别名-typeAliases" class="headerlink" title="1.4 类型别名(typeAliases)"></a>1.4 类型别名(typeAliases)</h3><p>类型别名是为java类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类的完全限定名。</p><h4 id="1-4-1默认内建类型别名"><a href="#1-4-1默认内建类型别名" class="headerlink" title="1.4.1默认内建类型别名"></a>1.4.1默认内建类型别名</h4><p>Mybatis框架已经为许多常见的java类型内建了相应的类型别名。他们都是大小写不敏感的，需要注意的是由基本类型名称重复导致的特殊处理。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr></tbody></table><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr></tbody></table><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><h4 id="1-4-2自定义类型别名"><a href="#1-4-2自定义类型别名" class="headerlink" title="1.4.2自定义类型别名"></a>1.4.2自定义类型别名</h4><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"ScottGroup"</span> <span class="attr">type</span>=<span class="string">"com.soyanga.mybatis.entity.ScottGroup"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"ScottInfo"</span> <span class="attr">type</span>=<span class="string">"com.soyanga.mybatis.entity.ScottInfo"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"ScottShare"</span> <span class="attr">type</span>=<span class="string">"com.soyanga.mybatis.entity.ScottShare"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当这样的配置时，ScottGroup可以用在任何使用com.soyanga.mybatis.emtity.ScottGroup的地方。也可以指定一个包名，MyBatis会在包名下搜索需要的Java Bean,同时默认使用类名小写作为别名，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置类的别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定一个包名，别名默认为类名的全小写--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.soyanga.mybatis.entity"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：由于IDE工具的智能化，定义类型的别名使用的频率较低</p></blockquote><h3 id="1-5-类型处理器-typeHandlers"><a href="#1-5-类型处理器-typeHandlers" class="headerlink" title="1.5 类型处理器(typeHandlers)"></a>1.5 类型处理器(typeHandlers)</h3><p>无论是MyBatis在预处理语句(PreparedStatement)中<strong>设置一个参数时，还是从结果集中取出一个值时</strong>，都会用类型处理器将获取的值以适合的方式转换成Java类型。</p><h4 id="1-5-1默认的类型处理器"><a href="#1-5-1默认的类型处理器" class="headerlink" title="1.5.1默认的类型处理器"></a>1.5.1默认的类型处理器</h4><p>Mybatis框架默认提供了多种类型的处理器，基本涵盖了java中使用到的各种数据类型。</p><h4 id="1-5-2-自定义类型处理器"><a href="#1-5-2-自定义类型处理器" class="headerlink" title="1.5.2 自定义类型处理器"></a>1.5.2 自定义类型处理器</h4><p>Mybatis为用户提供了重写类型处理器或创建自己的类型处理器来处理不支持的或非标准的类型。</p><p>具体做法：实现 <code>org.apache.ibatis.type.TypeHandler</code>接口，或继承一个很便利的类<code>org.apache.ibatis.type.BaseTypeHandler</code>,然后可以选择性的将它映射到一个JDBC类型。</p><p>实现示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExampleTypeHandler.java</span></span><br><span class="line"><span class="meta">@MappedJdbcTypes</span>(jdbctype.VARCHAR)</span><br><span class="line"><span class="meta">@MApperTypes</span>(value = String.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStringTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        ps.setString(i, parameter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建的MyStringHander会覆盖已经存在的处理java的String类型属性和VARCHAR参数及结果的类型处理器。</p><p>MyBatis不会窥探数据库元信息来决定使用那种类型，所以你必须在参数和结果映射中指明那是VARCHAR类型的字段，以使其能够绑定到正确的类型处理器上。这是因为：Mybatis直到语句被执行才清除数据类型</p><p>通过类型处理器的泛型，MyBatis可以得知该类型处理器的处理java类型，同时可以通过修改配置或者添加注解的方式来改变处理器的处理类型</p><ul><li><p>第一种：在类型处理器的配置元素（typeHandler element）上增加一个javaType属性（比如：javaType=“Stirng”）和jdbcType属性（比如： jdbcType = “VARCHAR”）;</p></li><li><p>第二种：在类型处理器的类上(TypeHandler class)增加@MappedTyped注解来指定与其关联的java类型列表；@MappedJdbcTypes注解来只当与其关联的JDBC类型。</p><blockquote><p>如果在配置中指定了javaTyped或者jdbcType属性，则注解方式将被忽略</p><p>建议：选择一种方式来配置类型处理器（配置或者注解）</p></blockquote></li><li><p>配置类型处理器</p><ul><li><p>第一种：配置处理器类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.soyanga.mybatis.plugin.MyStringTypeHandler"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">javaType</span>=<span class="string">"string"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>第二种：自动检索（autodiscovery）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--类型处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--多个类型处理器的加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.soyanga.mybatis.plugin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用自动检索配置功能的时候，只能通过注解的方式来指定JDBC和Java类型</p></blockquote></li></ul></li></ul><h4 id="1-5-3泛型类型处理器（了解）"><a href="#1-5-3泛型类型处理器（了解）" class="headerlink" title="1.5.3泛型类型处理器（了解）"></a>1.5.3泛型类型处理器（了解）</h4><p>用户可以创建一个泛型类型处理器，它可以处理多于一个类。为了达到此目的，需要增加一个接收类作为参数的构造器，这样在构造一个类型处理器的时候Mybatis就会传入一个具体的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GenericTypeHandler.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTypeHandler</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">MyObject</span>&gt; <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">    <span class="title">BaseTypeHandler</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;E&gt; type;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericTypeHandler</span><span class="params">(Class&lt;E&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tyep = <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Type argument count be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>EnumTypeHandler</code>和<code>EnumOrdinalTypeHandler</code>都是泛型类型处理器(genericTypeHandlers)</p><h3 id="1-6对象工厂-ObjectFactory"><a href="#1-6对象工厂-ObjectFactory" class="headerlink" title="1.6对象工厂(ObjectFactory)"></a>1.6对象工厂(ObjectFactory)</h3><p>MyBatis每次<strong>创建结果对象</strong>的新实例时，他都会使用一个对象工厂（ObjectFactory）实例来完成。默认的对象工厂需要做的仅仅时实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实现实例化。如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。比如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExampleObjectFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleObjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultObjectFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *type：对象类型</span></span><br><span class="line"><span class="comment">    *constructorArgTypes：参数类型集合</span></span><br><span class="line"><span class="comment">    *construstorArgs：参数集合</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type,List&lt;Class&gt; constructorArgTypes,List&lt;Object&gt; construstorArgs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(type,constructorArgTypes,constructorArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *配置元素的属性包装成Properties对象，再转换为对象的属性</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setProperties(properties);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>&lt;T&gt; bollean <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collection.class.isAssignableFrom(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--mybatis-config.xml--&gt;</span><br><span class="line">    &lt;!--对象工厂-对象的构建--&gt;</span><br><span class="line">    &lt;!--&lt;objectFactory type=<span class="string">"org.apache.ibatis.reflection.factory.DefaultObjectFactory"</span>&gt;--&gt;</span><br><span class="line">    &lt;objectFactory type=<span class="string">"org.mybatis.example.ExampleObjectFactory"</span>&gt;</span><br><span class="line">        &lt;!--name属性名 value属性个数--&gt;</span><br><span class="line">        &lt;property name=<span class="string">"abc"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"def"</span> value=<span class="string">"2"</span>/&gt;</span><br><span class="line">    &lt;/objectFactory&gt;</span><br></pre></td></tr></table></figure><p>ObjectFactory接口很简单，它包含两个创建用的方法，一个是处理默认构造方法的，另外一个是处理带参数的构造方法的。最后setProperties方法可以被用来配置ObjectFactory 在初始化你的ObjectFactory实例后，ObjectFactory元素中定义属性会被传递给setProperties方法。</p><h3 id="1-7插件-plugins"><a href="#1-7插件-plugins" class="headerlink" title="1.7插件(plugins)"></a>1.7插件(plugins)</h3><p>MyBatis允许你在已映射语句执行过程中得某一点进行拦截调用。默认情况下，MyBatis允许使用插件来拦截得方法调用包括：</p><ul><li><code>statementHandler</code>的<code>perpare,parameterize,batch,update,query</code>方法 创建sql命令</li><li><code>ParamentHandler</code>的<code>getParameterObject，setParameters</code>方法 传入参数处理</li><li><code>Executor</code>的<code>update,query,flushStatements,commit,rollback,getTransaction,close,isClosed</code>方法  执行器</li><li><code>ResuitSetHandler</code>的<code>handleResultSets,handleOutputParameters</code>方法 结果处理</li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看MyBatis的发行包中的源码。假设你想做的不仅仅是监控方法的调用，那么你应该很好的了解正在重写的方法的行为。因为如果在试图修改或者重写已有方法的行为的时候，你很可能在破坏MyBatis的核心模块。这些都是很底层的类和方法，所以<strong>使用插件的时候要特别的当心。</strong></p><p>通过MyBatis提供的强大机制，使用插件是非常简单的，只需实现Interceptor接口，并指定了想要拦截的方法签名即可。</p><blockquote><p>拦截器从一些列的MyBatis的执行流程中修改某些流程。</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExamplePlugin.java</span></span><br><span class="line"><span class="meta">@Intercepts</span>(&#123;<span class="meta">@Signature</span>(</span><br><span class="line">type = Executor.class,</span><br><span class="line">method = <span class="string">"update"</span>,</span><br><span class="line">args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="title">implement</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">plugin</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- mybatis-config.xml --&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">    &lt;plugin interceptor=<span class="string">"org.mybatis.example.ExamplePlugin"</span>&gt;</span><br><span class="line">    &lt;property name = <span class="string">"somProperty"</span> value=<span class="string">"100"</span>/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br></pre></td></tr></table></figure><p>上面的插件将会拦截在Executor实例中所有的update方法调用，这理的Executor是负责执行底层映射语句的内部对象。</p><h3 id="1-7配置环境-environments"><a href="#1-7配置环境-environments" class="headerlink" title="1.7配置环境(environments)"></a>1.7配置环境(environments)</h3><p>MyBatis可以配置成适应多种环境，这种机制有助于将SQL映射应用于多种数据库中，现实情况下有多种理由需要这么做。例如：开发，测试和生产环境需要有不同的配置；或者共享相同Schema的多个生产数据库使用相同的SQL映射。</p><blockquote><p>尽管可以配置多个环境，每个SqlSessionFactory实例只能选择其一，<strong>每个数据库对应一个SqlSessionFactory实例</strong></p></blockquote><p>为了指定创建哪种环境，只要将它作为可选参数传递给SqlSessionFactoryBuilder即可。可以接受环境配置的两个方法签名是：</p><p>方法参数优先级是最高的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlSexxionFactory factory  = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader,environment);</span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader,environment,properties);</span><br></pre></td></tr></table></figure><p>如果忽略了环境参数，那么默认环境将会被加载，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlSexxionFactory factory  = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader,properties);</span><br></pre></td></tr></table></figure><p>环境元素定义了如何配置环境：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span>  //默认的环境配置</span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver:com.mysql.jdbc.Driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/scott"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username:root&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password:123456789&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"prod"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span> //事务管理</span><br><span class="line">            <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver:com.mysql.jdbc.Driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/scott"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username:root&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password:123456789&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意这里的关键点：</p><ul><li>默认的环境ID（比如：default=“development”）</li><li>每个environment元素定义的环境ID(比如：id = “development”)</li><li>事务管理器配置（比如：type=“JDBC”）</li><li>数据源的配置（比如：type=“POOLED”）</li></ul><p>默认的环境和环境ID是可以随意命名的，只要保证默认环境要匹配其中一个环境ID。</p><h4 id="1-7-1事务管理"><a href="#1-7-1事务管理" class="headerlink" title="1.7.1事务管理"></a>1.7.1事务管理</h4><p>在MyBatis中两种类型的事务管理器（也就是 type=“[JDBC | MANAGED]”）:</p><ul><li><p>JDBC-这个配置就是直接使用JDBC的提交回滚设置，它<strong>依赖从数据源得到的连接</strong>来管理事务作用域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = sqlSessionFactory.openSession(<span class="keyword">true</span>); <span class="comment">//true是自动提交  反之需要自己提交</span></span><br></pre></td></tr></table></figure></li><li><p>MANAGED-这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如JEE应用服务器的上下文tomcat,jetty,jboss），默认情况下会关闭连接，然后一些容器并不希望这样，因此需要将closeConnection属性设置为false来阻止它默认的关闭行为，例如：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"closeConnection"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用Spring+MyBatis，则没有必要配置事务管理器，因为Spring模块会使用自带的管理器来覆盖前面的配置</p></blockquote><h4 id="1-7-2数据源（dataSource）"><a href="#1-7-2数据源（dataSource）" class="headerlink" title="1.7.2数据源（dataSource）"></a>1.7.2数据源（dataSource）</h4><p>dataSource元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源，许多MyBatis的应用程序将会按示例子中来配置数据源。然而它并不是必须的。要知道为了方便使用延迟加载，数据源才是必须的。</p><p>MyBatis有三种呢见数据源类型 (也就是 type = “[<strong>UNPOOLED|POOLED|JNDI</strong>]”):</p><ul><li><p><strong>UNPOOLED</strong>:这个数据源的是实现<em>只在每次被请求时打开 和 关闭连接</em>。虽然有一点慢，它对在及时可用连接方面没有性能要求的简单应用程序是一个很好的选择，不同的数据库在这方面表现也是不一样的，所以对某些数据库来说使用连接池并不重要，这个配置也是理想的。UNPOOLED类型的数据源仅仅需要配置以下5种属性：</p><p>| 属性                             | 描述                                                         |<br>| ——————————– | ———————————————————— |<br>| driver                           | 这是JDBC驱动的java类的完全限定名（并不是JDBC驱动中可能包含的数据源类型） |<br>| url                              | 这是数据库的JDBC URL地址                                     |<br>| username                         | 登陆数据库的用户名                                           |<br>| password                         | 登陆数据库的密码                                             |<br>| defaultTransactionIsolationLevel | 默认的连接事务隔离级别                                       |<br>| driver.*                         | 作为可选项，可以传递属性给数据库驱动，例如：driver.encoding=UTF8 |</p><p>这将通过DriverManager.getConnection(url,driverProperties)方法传递值为UTF8的encoding属性给数据库驱动。</p></li></ul><p><strong>POOLED</strong>-这种数据源的实现利用“池”的概念将JDBC连接对象组织起来，避免了创建新的连接实例所必须的初始化和认证时间。这是一种使得并发<strong>Web应用快速响应请求的流行处理方式</strong>。</p><p>除了上述提到UNPOOLED下的属性外，会有更多属性来配置POOLED的数据源：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>poolMaximumActiveConnections</td><td>在任意时间可以存在的活动（也就是正在用）连接数量，默认值：10</td></tr><tr><td>poolMaximumldleConnections</td><td>任意时间可能存在的空闲连接数</td></tr><tr><td>poolMaximumCheckoutTime</td><td>在被强制返回之前，池中连接被检出（out）时间，默认值:20000毫秒</td></tr><tr><td>poolTimeToWait</td><td>这是一个底层设置，如果获取连接花费很长时间，他会给连接池打印状态日志，并再次尝试获取一个连接（避免误配置的情况下一致安静的失败），默认值：20000毫秒</td></tr><tr><td>poolMaximumLocalBadConnectionTolerance</td><td>这是一个关于坏链接容忍度的底层设置，对于每一个尝试从缓存池获取连接的线程，一个线程获取到的是一个坏链接，那么数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过poolMaximumldleConnections与poolMaximumLocalBadConnectionTolerance之和。默认值：3（since:3.4.5）</td></tr><tr><td>pollPingQuery</td><td>发送到数据库的侦测查询，用来检验连接处在正常工作秩序中并接受请求是“NO PING QUERY SET”,这回导致多个数据驱动失败时带有一个恰当的错误信息</td></tr><tr><td>pollPingEnabled</td><td>是否启用侦测查询。若开启，也必须使用可执行的SQL语句设置pollPingQuery（最好是一个非常快的SQL）默认值true</td></tr><tr><td>poolPingConnectionsNotUsedFor</td><td>配置pollPingQuery的使用频度，这可以设置成具体的数据库连接超时时间，避免不必要的侦测，默认值为0（即所有连接时刻被侦测-当然仅当pollPingEnabled为true时使用）</td></tr></tbody></table><p><strong>JNDI(Java Naming and Directory Interface)</strong> - 这个数据源的实现是为了能在EJB或应用服务器这类容器中使用，容器可以集中或在<strong>外部配置数据源</strong>，然后放置一个JNDI上下文的引用。这种数据源配置只需要两个属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>initial_context</td><td>这个属性用来在 initialContext中寻找上下文（即，initialContext.lookup(initial_context))。这是个可选属性，如果忽略，那么data_source属性将会直接从initialContext中寻找</td></tr><tr><td>data_source</td><td>z这是引用数据源实例位置的上下文的路径。提供了initial_context配置时会在其返回的上下文中进行查找，没有提供时则直接在initialContext中查找</td></tr><tr><td>env.*</td><td>h和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给初始上下文，例如：env.encoding=UTF8</td></tr></tbody></table><h3 id="1-8映射器-mappers"><a href="#1-8映射器-mappers" class="headerlink" title="1.8映射器(mappers)"></a>1.8映射器(mappers)</h3><p>MyBatis的行为已经由上述元素配置完了，我们现在就要定义SQL映射语句了。但是首先我们需要告诉MyBatis到哪里区找这些语句。Java在自动查找这个方面没有提供一个很好的方法，最佳方式是告诉MyBatis到哪里区找映射文件。你可以使用想到一类路径的资源引用，或完全限定资源定位符（包括file:///的URL），或类名和包名等。例如：</p><ul><li><p>加载类路径下的映射器配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用 classpath相对资源 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/ScottGroupMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载全路径下的映射器配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用url路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file"</span>///<span class="attr">var</span>/<span class="attr">mappers</span>/<span class="attr">ScottGroupMapper.xml</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加载指定包下的Mapper接口类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册一个包下的所有mapper接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">com.soyanga.mybatis.mapper</span>"/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScottGroupMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(value = &#123;<span class="string">"select * from dept;"</span>&#125;)</span><br><span class="line">    <span class="function">List&lt;ScottGroup&gt; <span class="title">query</span><span class="params">(@Param(<span class="string">"id"</span>)</span> String id)</span>; <span class="comment">//参数注解</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertScottGroup</span><span class="params">(ScottGroup scottGroup)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解由局限性：虽然便利但是，不能完全支持MyBatis配置。且破坏了SQL的 隔离/集中处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Mybatis的配置&quot;&gt;&lt;a href=&quot;#Mybatis的配置&quot; class=&quot;headerlink&quot; title=&quot;Mybatis的配置&quot;&gt;&lt;/a&gt;Mybatis的配置&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;==&lt;strong&gt;了解掌握Mybatis的配置&lt;/strong&gt;==&lt;/p&gt;
&lt;p&gt;==&lt;strong&gt;掌握Mybatis的environments配置&lt;/strong&gt;==&lt;/p&gt;
&lt;h2 id=&quot;1-XML配置&quot;&gt;&lt;a href=&quot;#1-XML配置&quot; class=&quot;headerlink&quot; title=&quot;1.XML配置&quot;&gt;&lt;/a&gt;1.XML配置&lt;/h2&gt;&lt;h3 id=&quot;1-1XML结构&quot;&gt;&lt;a href=&quot;#1-1XML结构&quot; class=&quot;headerlink&quot; title=&quot;1.1XML结构&quot;&gt;&lt;/a&gt;1.1XML结构&lt;/h3&gt;&lt;p&gt;Mybatis的配置文件包含了会影响MyBatis行为的设置(settings)和属性(properties)信息。其中配置文件的顶层结构如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;configuration 配置&lt;ul&gt;
&lt;li&gt;properties 属性&lt;/li&gt;
&lt;li&gt;settings 设置&lt;/li&gt;
&lt;li&gt;typeAliass 类型别名&lt;/li&gt;
&lt;li&gt;objectFactory 对象工厂&lt;/li&gt;
&lt;li&gt;plugins 插件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;environments 环境集合&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;environment 环境&lt;ul&gt;
&lt;li&gt;transactionManager 事务管理&lt;/li&gt;
&lt;li&gt;dataSource 数据源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;databaseldProvider 数据库厂商标识&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mappers 映射器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/categories/JavaEE/"/>
    
    
      <category term="Mybatis" scheme="https://soyanga.github.io/tags/Mybatis/"/>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis初始</title>
    <link href="https://soyanga.github.io/2019/04/05/Mybatis%E5%88%9D%E5%A7%8B/"/>
    <id>https://soyanga.github.io/2019/04/05/Mybatis初始/</id>
    <published>2019-04-05T15:51:01.000Z</published>
    <updated>2019-04-05T15:54:45.027Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="Mybatis-简介和开始"><a href="#Mybatis-简介和开始" class="headerlink" title="Mybatis 简介和开始"></a>Mybatis 简介和开始</h1><p><strong>重点</strong></p><p>==了解Mybatis框架==  </p><p>==Mybatis快速入门== </p><h1 id="1-Mybatis是什么？"><a href="#1-Mybatis是什么？" class="headerlink" title="1.Mybatis是什么？"></a>1.Mybatis是什么？</h1><p><img src="/2019/04/05/Mybatis初始/Mybatis图标.png" alt="Mybatis图标"></p><p>MyBatis(3.X以前的版本叫ibatis)</p><a id="more"></a><p>==<strong>支持自定义SQL,存储过程和高级映射的持久化框架</strong>==</p><p>MyBatis<strong>几乎消除了所有的JDBC代码</strong>，也基本<strong>不需要手工去设置参数和获取检索结果</strong>。Mybatis能够使用<strong>简单的XML格式或者注解进来配置</strong>，能够映射基本数据结构，Map接口和POJOs（普通java对象）到数据库中的记录。</p><p><strong>JDBC</strong>——&gt;  将面向对象的语句转化问面向过程的SQL语句（我们只关注SQL语句的结果）。    </p><p>​    &lt;——   将对象转化为SQL语句存储在数据库中持久化处理。</p><p><strong>阻抗不匹配</strong>：持久化存储数据所采用的数据模型（无论是文件系统或者数据库管理系统）在编写程序时跟我们采用的数据模型有差异，就称为阻抗不匹配。</p><p>我们通过JDBC转化将<strong>数据库中的数据模型</strong>与<strong>java中的数据模型进行转化</strong>。</p><p>持久化框架：事务的ACID特性 D：持久化 A：原子性 C：一致性  I：隔离性</p><p><strong>ORM框架（Object Relational Mapping）</strong>采用<strong>元数据</strong>来描述对象–关系映射细节，元数据一般采用XML格式，并且存放在专门的对象映射文件中。</p><p>[Hibernate,iBATIS,MyBatis,EclipseLink,JFinal。]</p><p>采用的<code>Mybatis-3.4.5</code> </p><p>Mybatis框架时JavaEE是最容易掌握的框架。</p><h3 id="1-1-Mybatis-VS-JDBC-SQL"><a href="#1-1-Mybatis-VS-JDBC-SQL" class="headerlink" title="1.1 Mybatis VS JDBC SQL"></a>1.1 Mybatis VS JDBC SQL</h3><table><thead><tr><th>对比</th><th>Mybatis</th><th>JDBC SQL</th></tr></thead><tbody><tr><td>连接</td><td>托管</td><td>编码 Connection connection = DriverManager.getConnection(url)</td></tr><tr><td>SQL</td><td>隔离/集中</td><td>混合/分散  java中有SQL语句</td></tr><tr><td>缓存</td><td>两级缓存</td><td>不支持</td></tr><tr><td>结果映射</td><td>自动映射</td><td>硬编码</td></tr><tr><td>维护性</td><td>高</td><td>低</td></tr></tbody></table><p>缓存：提高访问效率</p><p>JDBC的执行流程</p><ol><li>加载数据库驱动建立连接/获得数据源  建立连接</li><li>创建操作命名</li><li>执行SQL语句–-&gt;返回结果集</li><li>对返回的结果集进行处理（sql–&gt;Java对象）</li><li>资源回收（关闭结果集，关闭操作命令，关闭连接）</li></ol><ul><li><p>加在数据库驱动建立连接/获得数据源建立连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br></pre></td></tr></table></figure></li><li><p>建立数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/memo?</span></span><br><span class="line"><span class="string">user = root &amp; password = root &amp; useUnicode = true &amp; characterEncoding = "</span>UTF-<span class="number">8</span><span class="string">");</span></span><br></pre></td></tr></table></figure><blockquote><p>//MySQL数据库连接得url参数格式如下：</p><p>jdbc:mysql://服务器地址:端口/数据库名称？参数名 = 参数值</p></blockquote></li><li><p>创建操作命令(statement)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement statemnt = connection.createStatement();</span><br></pre></td></tr></table></figure></li><li><p>执行SQL语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResultSet resultSet = statement.executeQuery(</span><br><span class="line">  <span class="string">"select id,group_id,title,content,is_protected, background,is_remind,remind_time,created_time,modify_time from memo_info"</span>);</span><br></pre></td></tr></table></figure></li><li><p>处理结果集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next()) &#123;    </span><br><span class="line">    <span class="keyword">int</span> id = resultSet.getInt(<span class="string">"id"</span>);    </span><br><span class="line">    String title = resultSet.getString(<span class="string">"title"</span>);    </span><br><span class="line">    String content = resultSet.getString(<span class="string">"content"</span>);    </span><br><span class="line">    Date createTime = resultSet.getDate(<span class="string">"created_time"</span>);    System.out.println(String.format(<span class="string">"Memo: id=%d, title=%s, content=%s, createTime=%s"</span>, id, title, content, createTime.toString())); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>释放资源（关闭结果集，命令，连接）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭结果集</span></span><br><span class="line"><span class="keyword">if</span> (resultSet != <span class="keyword">null</span>) &#123;    </span><br><span class="line"><span class="keyword">try</span> &#123;        </span><br><span class="line">resultSet.close();    </span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;        </span><br><span class="line">e.printStackTrace();    </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//关闭命令</span></span><br><span class="line"><span class="keyword">if</span> (statement != <span class="keyword">null</span>) &#123;    </span><br><span class="line"><span class="keyword">try</span> &#123;        </span><br><span class="line">statement.close();    </span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;        </span><br><span class="line">e.printStackTrace();    </span><br><span class="line">&#125; </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//关闭连接命令</span></span><br><span class="line"><span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;    </span><br><span class="line"><span class="keyword">try</span> &#123;        </span><br><span class="line">connection.close();    </span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;        </span><br><span class="line">e.printStackTrace();    </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-开始使用Mybatis"><a href="#2-开始使用Mybatis" class="headerlink" title="2.开始使用Mybatis"></a>2.开始使用Mybatis</h2><h3 id="2-1准备工作"><a href="#2-1准备工作" class="headerlink" title="2.1准备工作"></a>2.1准备工作</h3><ul><li>IDEA安装Mybatis插件（Free Mybatis Plugin）<ul><li>IDEA Settings-&gt;Plugins-&gt;Browse repositorites-&gt;Free Mybatis Plugin</li><li>安装完成之后重启IDEA</li></ul></li><li>准备mybatis项目<ul><li>创建一个Maven的Application项目</li><li>pom.xml中添加Mybatis依赖 org.mybatis:mybatis:3.4.5</li><li>pom.xml中添加JDBC驱动依赖,如:mysql:mysql-connector-java:5.1.43</li></ul></li><li>准备数据库<ul><li>创建数据库</li><li>创建数据库表</li></ul></li></ul><h3 id="2-2构建SqlSessionFactory"><a href="#2-2构建SqlSessionFactory" class="headerlink" title="2.2构建SqlSessionFactory"></a>2.2构建SqlSessionFactory</h3><h4 id="2-1-1XML构建-重点"><a href="#2-1-1XML构建-重点" class="headerlink" title="2.1.1XML构建(重点)"></a>2.1.1XML构建(<strong>重点</strong>)</h4><p>每个基于Mybatis的应用都是以一个SqlSessionFactory的实例为中心的。SqlSessionFactory的实例可以通过SqlSessionFactoryBuilder获得。而SqlSessionFactoryBuilder则可以从XML配置文件或者一个预先定制的Configuration的实例构建出SqlSessionFactory的实例。</p><ul><li>创建Mybatis配置文件(<code>mybatis-config.xml</code>)归档到<code>src/main/resources/mybatis-comfig.xml</code>)</li><li>利用Resouce类来获取xml文件名解析创建成一个SqlSessionFactory实例</li></ul><h4 id="2-1-2编码构建（了解）"><a href="#2-1-2编码构建（了解）" class="headerlink" title="2.1.2编码构建（了解）"></a>2.1.2编码构建（了解）</h4><p>如果你愿意直接从java程序而不是XML文件中创建configuration,或者创建你自己的configuraton构建器，MyBatis也提供了完整的配置类，提供所有和XML文件相同功能的配置项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataSource dataSource = <span class="keyword">new</span> PooledDataSource();<span class="comment">//mybatis提供的数据库连接池</span></span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.addMapper(MemoGroupMapper.clss);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure><p>configuration添加了一个映射器类（mapper class)。映射器类是java类，他们包含SQL映射语句的注解，从而避免了XML文件的依赖，不过由于java注解的一些限制加之某些MyBatis映射的复杂性，XML映射对于大多数高级映射（比如：嵌套Join映射）来说仍然是必须的。有鉴于此，如果存在一个对等的XML配置文件的话。MyBatis会自动查找并加载它（这种情况下，MemoGroupMapper.xml将会基于类路径和MemGruopMapper.class的类名被加载进来）。</p><h2 id="2-2使用SqlSession"><a href="#2-2使用SqlSession" class="headerlink" title="2.2使用SqlSession"></a>2.2使用SqlSession</h2><p>我们可以通过SqlSession的实例。SqlSession完全包含了面向数据库执行SQL命令所需的所有方法，你可以通过SqlSession实例来执行已经映射的SQL语句。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.getMapper(.class);</span><br></pre></td></tr></table></figure><p>基于Mybatis项目</p><ol><li>创建Maven项目<ol><li>添加依赖 mybatis org.mybatis:3.4.5</li><li>添加依赖 mysql驱动 mysql:mysql-connector-java:5.1.43驱动</li><li>准备数据库</li></ol></li><li>创建mybatis配置<ol><li>sec/main/resources  -&gt; mybatis-config.xml</li><li>配置文件中需要配置数据库信息 driver url username password</li></ol></li><li>编码<ol><li>entity 包 实体类 -&gt; 数据库表</li><li>mapper 包 mapper接口 -&gt; 数据库操作的方法</li><li>src/main/resources/mapper 创建mapper.xml映射文件 定义信息</li><li>编码 创建SqlSessionFactory SqlSession Mapper Interface</li><li>测试一下代码</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;Mybatis-简介和开始&quot;&gt;&lt;a href=&quot;#Mybatis-简介和开始&quot; class=&quot;headerlink&quot; title=&quot;Mybatis 简介和开始&quot;&gt;&lt;/a&gt;Mybatis 简介和开始&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;==了解Mybatis框架==  &lt;/p&gt;
&lt;p&gt;==Mybatis快速入门== &lt;/p&gt;
&lt;h1 id=&quot;1-Mybatis是什么？&quot;&gt;&lt;a href=&quot;#1-Mybatis是什么？&quot; class=&quot;headerlink&quot; title=&quot;1.Mybatis是什么？&quot;&gt;&lt;/a&gt;1.Mybatis是什么？&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2019/04/05/Mybatis初始/Mybatis图标.png&quot; alt=&quot;Mybatis图标&quot;&gt;&lt;/p&gt;
&lt;p&gt;MyBatis(3.X以前的版本叫ibatis)&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/categories/JavaEE/"/>
    
    
      <category term="Mybatis" scheme="https://soyanga.github.io/tags/Mybatis/"/>
    
      <category term="JavaEE" scheme="https://soyanga.github.io/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>二叉树基础(上)</title>
    <link href="https://soyanga.github.io/2019/04/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/04/05/二叉树基础(上)/</id>
    <published>2019-04-05T15:47:04.000Z</published>
    <updated>2019-04-05T15:49:03.516Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="23-二叉树基础-上-：什么样的二叉树适合用数组来存储？"><a href="#23-二叉树基础-上-：什么样的二叉树适合用数组来存储？" class="headerlink" title="[23]二叉树基础(上)：什么样的二叉树适合用数组来存储？"></a>[23]二叉树基础(上)：什么样的二叉树适合用数组来存储？</h1><p>二叉树有哪些存储方式，什么样的二叉树适合用数组来存储？</p><p>树的<strong>高度(Height)、深度(Depth)、层(Level)</strong>。</p><blockquote><ul><li>节点高度 = 节点到叶子节点的最长路径(<strong>边数</strong>)</li><li>节点深度 = 根节点到这个节点所经的边的个数</li><li>节点层数 = 节点深度 + 1</li><li>树的高度 = 根节点的高度</li></ul></blockquote><p><img src="/2019/04/05/二叉树基础(上)/婕\数据结构与算法之美\picture\二叉树节点深度，高度，层数图.jpg" alt="二叉树节点深度，高度，层数图"></p><p>记忆小Tips：</p><p><strong>高度</strong>是从下往上度量，比如我们要度量第10层楼的高度，起点都是地面。所以，树这种这种数据结构高度也一样，从树的最底层开始算，并且计数的起点是0。</p><p><strong>“深度”</strong>这个概念在生活中是从上往下度量，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似，从根节点开始度量，并且计数起点也是0。</p><p><strong>“层数”</strong>跟深度得到计算类似，不过，计数起点是1，也就是说根节点的位于第1层。</p><a id="more"></a><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><h4 id="二叉树的结点（孩子表示法）-二插链"><a href="#二叉树的结点（孩子表示法）-二插链" class="headerlink" title="二叉树的结点（孩子表示法）-二插链"></a>二叉树的结点（孩子表示法）-二插链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T data;<span class="comment">//结点数据</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; lchild;<span class="comment">//左孩子</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;T&gt; rchild;<span class="comment">//右孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getLchild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lchild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">getRchild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rchild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String lchildInfo = lchild == <span class="keyword">null</span> ? <span class="keyword">null</span> : lchild.getData().toString();</span><br><span class="line">            String rchildInfo = rchild == <span class="keyword">null</span> ? <span class="keyword">null</span> : rchild.getData().toString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Node&#123;"</span> +</span><br><span class="line">                    <span class="string">"data="</span> + data +</span><br><span class="line">                    <span class="string">", lchild="</span> + lchildInfo +</span><br><span class="line">                    <span class="string">", rchild="</span> + rchildInfo +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="树的高度（从下到上）-树的深度（从上到下）-从0开始"><a href="#树的高度（从下到上）-树的深度（从上到下）-从0开始" class="headerlink" title="树的高度（从下到上）/树的深度（从上到下）-从0开始"></a>树的高度（从下到上）/树的深度（从上到下）-从0开始</h4><p>递归左树，递归右树 谁大树的深度就是谁。</p><p>递归递推公式： 深度 = 左树深度&gt;右树深度？ 左树深度+1 ：右树深度+1；</p><p>递归停止条件：node  = null    return 0;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回指定结点的深度</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> node 结点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 树的深度</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthForSubTree</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//从上到下递归，从下到上分会深度，</span></span><br><span class="line">      <span class="comment">// 下面就是返回某结点两个孩子中深度最大的那个，加1继续返回到最上一层。</span></span><br><span class="line">      <span class="keyword">int</span> lDepth = depthForSubTree(node.lchild);</span><br><span class="line">      <span class="keyword">int</span> rDepth = depthForSubTree(node.rchild);</span><br><span class="line">      <span class="keyword">return</span> lDepth &gt; rDepth ? lDepth + <span class="number">1</span> : rDepth + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="树的度"><a href="#树的度" class="headerlink" title="树的度"></a>树的度</h4><p>树的度是指的是树的最大子节点的个数，二叉树中树的度有3种 0（只有根结点）， 1（斜树） ，2(普通二叉树)  </p><p>斜树分为左斜树，右斜树（斜树深度为斜树结点个数）  -相当于一个链表。</p><p><strong>由于斜树的判断方式包含根节点，所以先判断是否树的度为0，其次再判断斜树，和其他。</strong></p><p>既然要求树的深度，这里接着说。求树的深度也用了<strong>递归算法——从上往下递归</strong>，从最后一层往根结点返回。如果某个结点为空，当然深度返回0；否则递归查找其左右子树，直到最后一层，开始返回。返回当前结点左右子树的深度值较大者并<strong>加上1</strong>，<strong>这里加上1的意义是因为函数返回对应着返回到上一层中的父结点了，深度自然增加1。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查看树的度</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 树的度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无非有三种情况</span></span><br><span class="line">    <span class="comment">//1.只有一个根节点，度为0</span></span><br><span class="line">    <span class="comment">//斜树 度为1</span></span><br><span class="line">    <span class="comment">//其余情况是 2</span></span><br><span class="line">    <span class="keyword">if</span> (root.lchild == <span class="keyword">null</span> &amp;&amp; root.rchild == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//斜树的结点个数等于其深度，包括了只有根节点的情况，所以上面的条件要先判断跟结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodesNum == depth()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树-Binary-Tree"><a href="#二叉树-Binary-Tree" class="headerlink" title="二叉树(Binary Tree)"></a>二叉树(Binary Tree)</h2><p><strong>满二叉树，完全二叉树</strong></p><p><img src="/2019/04/05/二叉树基础(上)/婕\数据结构与算法之美\picture\二叉树.jpg" alt="二叉树"></p><p>1.普通二叉树</p><p>2.满二叉树</p><p>除了叶子节外，每个节点都有左右两个子节点</p><p>3.完全二叉树</p><p>最后一层的叶子节点靠左排列，且除去最后一层就是一颗满二叉树。</p><h2 id="存储树的方式"><a href="#存储树的方式" class="headerlink" title="存储树的方式"></a>存储树的方式</h2><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p><img src="/2019/04/05/二叉树基础(上)/婕\数据结构与算法之美\picture\链式存储二叉树.jpg" alt="链式存储二叉树"></p><p>每个节点都存储了三个元素（数据data 左节点（指针） 右节点（指针）)</p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>基于数组存储方式，我们把</p><p><strong>根节点存储在下标i = 1的位置</strong></p><p><strong>左子节点存储在2*i=2的位置</strong></p><p><strong>右子节点存储在2*i+1=3的位置</strong></p><p><strong>以此类推</strong></p><p><img src="/2019/04/05/二叉树基础(上)/婕\数据结构与算法之美\picture\顺序存储二叉树.jpg" alt="顺序存储二叉树"></p><p>总结：</p><p>如果x存储在数组中下标为i的位置，下标为2<em>i的位置存储的就是左子节点，下标为2\</em>i+1的位置存储的就是右子节点。</p><p>反过来，下标为i/2的位置存储就是它的父节点。通过这种形式，我们只要知道根节点存储的位置(一般情况下为了方便计算子节点，根节点会存储在下标为1的位置)，这样我们通过下标计算，把整个树组织起来。</p><p>假如不是一颗完全二叉树，则就会浪费大量的存储空间(数组)，如下：</p><p><img src="/2019/04/05/二叉树基础(上)/婕\数据结构与算法之美\picture\非完全二叉树顺序存储.jpg" alt="非完全二叉树顺序存储"></p><p>如果某棵树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存方式并不需要像链式存储那样，要存储额外的左右节点指针。这也是为什么完全二叉树会单独作为一类树的统称。也是为什么完全二叉树要求最后一层的子节点都靠左的原因。</p><p>堆其实就是一颗完全二叉树，最常用的存储方式就是数组。</p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历的遍历方式有三种</p><h3 id="前序遍历（自左右）"><a href="#前序遍历（自左右）" class="headerlink" title="前序遍历（自左右）"></a>前序遍历（自左右）</h3><ul><li>前序遍历是指，对于树中的任意节点来说，<strong>当前结点不为空就先打印这个节点，然后再打印它得到左子树，最后打印它的右子树，为空则，返回父节点，继续开始处理父节点的右子树。</strong></li></ul><p><img src="/2019/04/05/二叉树基础(上)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552204034380.png" alt="1552204034380"></p><h4 id="代码分析-递归"><a href="#代码分析-递归" class="headerlink" title="代码分析(递归)"></a>代码分析(递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前序遍历--递归(自 左 右)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">    preOrder(node.lchild);</span><br><span class="line">    preOrder(node.rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析（非递归）"><a href="#代码分析（非递归）" class="headerlink" title="代码分析（非递归）"></a>代码分析（非递归）</h4><p>递归变非递归就用循环或者栈模拟函数栈帧出栈入栈</p><p>入栈就打印（自 左 右）</p><p><strong>每访问一个结点，若不为空，存入栈，并立即打印。然后不断深入左子树，直到为空，此时返回到父结点（对应的栈操作是出栈），接着处理它的右子树。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前序遍历 --非递归</span></span><br><span class="line"><span class="comment"> 用栈模拟递归调用的过程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder2</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="comment">//用栈保存已经访问过的结点，便于返回到父节点 //链表</span></span><br><span class="line">LinkedList&lt;Node&lt;Item&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"> <span class="comment">//当前根结点不为空，或者为空但有可以返回的父节点(栈中有其他结点)（可以进行pop()操作)都可以进入循环</span></span><br><span class="line"><span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">//只要当前结点不为空，就打印，同时入栈</span></span><br><span class="line">     <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stack.push(node);</span><br><span class="line">      System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">        node = node.lchild;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上面while终止说明当前结点为空；返回到父结点并处理它的右子树。由于要执行pop操作，先判空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回到父节点。由于左孩子为空返回时已经弹出过父节点了，所以若是由于右孩子为空返回，</span></span><br><span class="line"><span class="comment">// 会一次性返回到多层</span></span><br><span class="line">node = stack.pop();</span><br><span class="line"><span class="comment">//开始右子树的大循环(第一个while)</span></span><br><span class="line"><span class="comment">//子问题访问左树</span></span><br><span class="line"> node = node.rchild;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历（左自右）"><a href="#中序遍历（左自右）" class="headerlink" title="中序遍历（左自右）"></a>中序遍历（左自右）</h3><ul><li>中序遍历是指，对于树中任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树</li><li><img src="/2019/04/05/二叉树基础(上)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552206203824.png" alt="1552206203824"></li></ul><h4 id="代码分析-递归-1"><a href="#代码分析-递归-1" class="headerlink" title="代码分析(递归)"></a>代码分析(递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 中序遍历 --递归 （左自右）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    inOrder(node.lchild);</span><br><span class="line">    System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">    inOrder(node.rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析（非递归）-1"><a href="#代码分析（非递归）-1" class="headerlink" title="代码分析（非递归）"></a>代码分析（非递归）</h4><p>先出栈再打印（左 自 右）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 中序遍历非递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder2</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Node&lt;Item&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">           node = node.lchild;</span><br><span class="line">     &#125;</span><br><span class="line">        <span class="comment">//和前序遍历唯一不同就是，前序遍历是入栈时打印。中序遍历是出栈时返回父节点才打印</span></span><br><span class="line">        <span class="comment">//和前序遍历一样，由于左孩子为空返回时已经弹出过父节点，所以若是由于右孩子为空返回，会一次性返回多层</span></span><br><span class="line">         node = stack.pop();</span><br><span class="line">         System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">         <span class="comment">//子问题访问右树</span></span><br><span class="line">         node = node.rchild;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历（左右自）"><a href="#后序遍历（左右自）" class="headerlink" title="后序遍历（左右自）"></a>后序遍历（左右自）</h3><ul><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</li><li><img src="/2019/04/05/二叉树基础(上)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552206225972.png" alt="1552206225972"></li></ul><h4 id="代码分析-递归-2"><a href="#代码分析-递归-2" class="headerlink" title="代码分析(递归)"></a>代码分析(递归)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后续序遍历--递归（左右自）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">postOrder(node.lchild);</span><br><span class="line">postOrder(node.rchild);</span><br><span class="line">System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码分析（非递归）-2"><a href="#代码分析（非递归）-2" class="headerlink" title="代码分析（非递归）"></a>代码分析（非递归）</h4><p>左 右 自  （左标记1） （右标记2） 然后才进行打印 每个结点如此</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后续遍历--非递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder2</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Node&lt;Item&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放系欸但被访问的信息，1表示只访问过左孩子，2表示右孩子访问过了（此时可以打印自结点）</span></span><br><span class="line">    LinkedList&lt;Integer&gt; visitedState = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">     <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.lchild;</span><br><span class="line">             <span class="comment">//上面访问过左孩子，放入1</span></span><br><span class="line">             visitedState.push(<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//这个while和下面的if不可交换执行顺序，否则变成了中序遍历</span></span><br><span class="line">         <span class="comment">//用while儿不用if是因为：结点已经访问过它的两个孩子了，先不打印而处于等待状态。随即判断若它的右孩子不为空，则仍会被push进入，</span></span><br><span class="line">         <span class="comment">// 待右孩子处理完后按照递归思想应该返回到等待中父节点，由于父节点访问状态已经是2.直接打印</span></span><br><span class="line"><span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; visitedState.peek() == <span class="number">2</span>) &#123;</span><br><span class="line">visitedState.pop();</span><br><span class="line">            System.out.println(stack.pop().getData() + <span class="string">" "</span>);</span><br><span class="line">       &#125;</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//注意先取出来而不删除，等到访问状态为2才删除</span></span><br><span class="line">            node = stack.peek();</span><br><span class="line">            node = node.rchild;</span><br><span class="line">            <span class="comment">//上面访问过有孩子了，应该更新访问状态为2</span></span><br><span class="line">            visitedState.pop();<span class="comment">//弹出1，压入2</span></span><br><span class="line">            visitedState.push(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>二叉树的前序，中序，后序其实就相当与深度优先遍历DFS,所以用递归和栈都可以实现。层序遍历相当于广度优先BFS，故可以用队列实现。从根节点开始，一层一层的从左往右打印（或其他操作）每个结点，比如下面层序遍历的结果为A-B-C-D-E-F-G-H-I</p><p><img src="http://upload-images.jianshu.io/upload_images/2726327-a0a9493ea07294de.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 层序遍历 --借助队列</span></span><br><span class="line"><span class="comment">* 将元素添加到队列中快于打印，要动手在纸上画画</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        Node front = queue.poll();</span><br><span class="line">        System.out.println(front.getData() + <span class="string">" "</span>); <span class="comment">//一次打印一个</span></span><br><span class="line">        <span class="keyword">if</span> (front.lchild != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(front.lchild);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (front.rchild != <span class="keyword">null</span>) &#123;</span><br><span class="line">             queue.offer(front.rchild);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归遍历总结"><a href="#递归遍历总结" class="headerlink" title="递归遍历总结"></a>递归遍历总结</h2><p><img src="/2019/04/05/二叉树基础(上)/婕\数据结构与算法之美\picture\前中后续遍历.jpg" alt="前中后续遍历"></p><p>二叉树的前中后续遍历，就是一个递归过程。比如，前序遍历，就是先打印根节点，然再递归打印左子树，最后递归打印右子树</p><p>写递归代码的关键，写递推公式，找到递归终止条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">前序遍历的递推公式：</span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">中序遍历的递推公式：</span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line">后序遍历的递推公式：</span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><p>终止条件  -遍历到节点为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前序遍历--递归(自 左 右)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">    preOrder(node.lchild);</span><br><span class="line">    preOrder(node.rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 中序遍历 --递归 （左自右）</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    inOrder(node.lchild);</span><br><span class="line">    System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">    inOrder(node.rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 后续序遍历--递归（左右自）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node&lt;Item&gt; node)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">postOrder(node.lchild);</span><br><span class="line">postOrder(node.rchild);</span><br><span class="line">System.out.print(node.getData() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前、中、后序遍历的顺序图，可以看出，每个节点最多会被访问两次，所以遍历操作的时间复杂度，跟节点个数n成正比，<strong>也就是说二叉树遍历时间复杂度是O(n)。</strong></p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>二叉树既可以用链式存储，也可以用数组顺序存储。数组顺序存储的方式比较适合完全二叉树，其他类型的二叉树用数组存储会比较浪费存储空间。 </p><p><strong>二叉树前中后序遍历的时间复杂度是O(n);</strong></p><h2 id="补充1"><a href="#补充1" class="headerlink" title="补充1:"></a>补充1:</h2><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul><li><p>二叉树的第i层至多有$2^{i-1}$个结点，这个多画图很容易的出结论</p></li><li><p>深度为k的二叉树最多有$2^k-1$个结点；拥有最多结点的是满二叉树，根据第一条其实就是$$\sum_{i=1}^n(2^0+2^1+2^2+…+2^{k-1})$$</p></li><li><p>任意一棵二叉树，如果叶子结点个数为$n_0$,度为2的结点个数为$n_2$,则$n_0=n_2+1$。</p><ul><li><p>证明：设n为二叉树总结点个数，那么树的连线（分支）条数就为$n-1$,这个指的由来可以从下往上看，除了根结点外，每个结点都有一条指向父节点的连线。所以连线个数为$n-1$。</p></li><li><p>另外用$n_1$表示度为1的个数，则 $n=n_0+n_1+n_2$;</p></li><li><p>计算分支结点（连线）的方法也可以是从上到下，叶子结点没有孩子，又有一个孩子的结点可引出一条连线，拥有两个孩子的结点可以引出两条连线。所以<code>分支数</code>=$n_1+2n_2=n-1$,</p><p>将$n=n_0+n_1+n_2$带入上式中得$n_0=n_2+1$。</p></li><li><p>结论：二叉树叶子结点的个数一定比度为2的结点个数多一个。</p></li></ul></li><li><p>有n个节点的完全二叉树的深度为$\lfloor\log_2n\rfloor+1$，其中$\lfloor x \rfloor$表示向下取整。因为完全二叉树额节点（最上面的叶子结点）个数肯定不大于满二叉树结点数$2^k-1$个，但是也肯定大于$2^{k-1}-1$个（最少的时候，第k层就1个结点，但是上面的$k-1$层都是满的），也就是说$x^{k-1}-1&lt;n\le 2^k-1$，又n为正整数，该不等式等价于$x^{k-1} \le n &lt; 2^k$ ,两边取对数得到的$k-1 \le \log_2n &lt; k$（k为二叉树深度）</p></li><li><p>按层序编号，根节点编号为1，对于任意一个编号为i的结点，编号2i为其左孩子，2i+1为其有孩子；相反，对于任意一个1编号为i的结点，其父节点编号为$\lfloor i/2 \rfloor$</p></li><li><p>如果$2i&gt;n$则结点i无孩子；如果$2i+1&gt;n$,结点i只有左孩子没有右孩子。</p></li></ul><h3 id="由遍历次序的确定一颗二叉树"><a href="#由遍历次序的确定一颗二叉树" class="headerlink" title="由遍历次序的确定一颗二叉树"></a>由遍历次序的确定一颗二叉树</h3><p>已知前序遍历序列和中序遍历序列或者已知中序序列序列和后序遍历序列是可以确定一棵二叉树的，这就是说推导出的二叉树有唯一形态。</p><h4 id="已知前序和中序"><a href="#已知前序和中序" class="headerlink" title="已知前序和中序"></a>已知前序和中序</h4><p>比如前序遍历的顺序是ABCDEF,中序遍历的顺序是CBAEDF。问中序那边遍历序列？</p><p>由于二叉树形态唯一，中序遍历只有一种结果。现在来分析：前序中，A为根节点。于是中序中，C、B为左子树，E、D，F为右子树。回到前序中，A下一个是B,B肯定是左孩子，C是B的孩子但不确定是左孩子还是右孩子；再看中序，先打印的C说明C是B的左孩子。然后看右树DEF，前序中先打印D说明D是A的右孩子，接着打印了E说明E是D的左孩子。F可能是D的右孩子也可能是E的某一个孩子。再看中序，E之后是D说明E没有孩子，只能是F是D的右孩子。完毕，由此画出的二叉树就能得到后序遍历的结果。  CBEFDA</p><p><img src="/2019/04/05/二叉树基础(上)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552206123619.png" alt="1552206123619"></p><h4 id="已知中序和后序"><a href="#已知中序和后序" class="headerlink" title="已知中序和后序"></a>已知中序和后序</h4><p>比如中序序列ABCDEFG，后序序列BDCAFGE，求前序序列？</p><p>先看后序序列确定根节点是E,则在中序中，ABCD为左子树，FG为右子树。由后序BDCA的顺序，得知A是个节点的左孩子，后序中FG可以看出G是根节点E的右孩子。中序中先打印A说明A没有左孩子，BCD为于A的右侧，结合后序的BDCA，说明C是A的右孩子，则中序中ABCD的打印顺序，知道B是C的左孩子，D是C的右孩子。接下来看根节点E的右子树FG，中序中先打印F,说明F是G的左孩子。由此画出的二叉树就能得到前序遍历的结果。   EACBDGF</p><p><img src="/2019/04/05/二叉树基础(上)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552207115851.png" alt="1552207115851"></p><p>不能根据前序跟后序确定一个唯一的二叉树，因为中序遍历可以区分出左右子树。（根据根结点左边的是左子树，右边的是右子树），所以只根据前序遍历序列和后序遍历序列，可能得到多个形态的二叉树，它们前序、后序遍历出来是的结果相同。</p><h2 id="补充2："><a href="#补充2：" class="headerlink" title="补充2："></a>补充2：</h2><p>具有n个结点的二叉树，共有$h(n) = C(2n, n) - C(2n, n+1)$种形态，C即组合。–&gt;卡特兰数，类似问题还有可能的进出栈顺序，括号问题等。</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据卡兰特数递推公式 h(n) = h(n-1)*(4*n-2)/(n+1)</span></span><br><span class="line"><span class="comment">* 已知h(1)=1;</span></span><br><span class="line"><span class="comment">* 无穷数列，越到后面数字也大，使用BigIjteger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 二叉树的结点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  多少种组合方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">numofTreeShape</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     BigInteger a = BigInteger.ONE;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a = a.multiply(BigInteger.valueOf(<span class="number">4</span> * i - <span class="number">2</span>)</span><br><span class="line">                       .divide(BigInteger.valueOf(i + <span class="number">1</span>)));</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;23-二叉树基础-上-：什么样的二叉树适合用数组来存储？&quot;&gt;&lt;a href=&quot;#23-二叉树基础-上-：什么样的二叉树适合用数组来存储？&quot; class=&quot;headerlink&quot; title=&quot;[23]二叉树基础(上)：什么样的二叉树适合用数组来存储？&quot;&gt;&lt;/a&gt;[23]二叉树基础(上)：什么样的二叉树适合用数组来存储？&lt;/h1&gt;&lt;p&gt;二叉树有哪些存储方式，什么样的二叉树适合用数组来存储？&lt;/p&gt;
&lt;p&gt;树的&lt;strong&gt;高度(Height)、深度(Depth)、层(Level)&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;节点高度 = 节点到叶子节点的最长路径(&lt;strong&gt;边数&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;节点深度 = 根节点到这个节点所经的边的个数&lt;/li&gt;
&lt;li&gt;节点层数 = 节点深度 + 1&lt;/li&gt;
&lt;li&gt;树的高度 = 根节点的高度&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2019/04/05/二叉树基础(上)/婕\数据结构与算法之美\picture\二叉树节点深度，高度，层数图.jpg&quot; alt=&quot;二叉树节点深度，高度，层数图&quot;&gt;&lt;/p&gt;
&lt;p&gt;记忆小Tips：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高度&lt;/strong&gt;是从下往上度量，比如我们要度量第10层楼的高度，起点都是地面。所以，树这种这种数据结构高度也一样，从树的最底层开始算，并且计数的起点是0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“深度”&lt;/strong&gt;这个概念在生活中是从上往下度量，比如水中鱼的深度，是从水平面开始度量的。所以，树这种数据结构的深度也是类似，从根节点开始度量，并且计数起点也是0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“层数”&lt;/strong&gt;跟深度得到计算类似，不过，计数起点是1，也就是说根节点的位于第1层。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="二叉树" scheme="https://soyanga.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法(下)</title>
    <link href="https://soyanga.github.io/2019/04/04/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/04/04/哈希算法(下)/</id>
    <published>2019-04-04T15:44:47.000Z</published>
    <updated>2019-04-04T15:47:14.400Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="22-哈西算法-下-哈希算法在分布式系统中有哪些应用"><a href="#22-哈西算法-下-哈希算法在分布式系统中有哪些应用" class="headerlink" title="[22]哈西算法(下): 哈希算法在分布式系统中有哪些应用"></a>[22]哈西算法(下): 哈希算法在分布式系统中有哪些应用</h1><p>哈希算法上讲了，哈希算法的四个应用，分别是 安全加密、数据检验、唯一标识、散列函数</p><p>还剩下 ：<strong>负载均衡、数据分片、分布式存储</strong></p><a id="more"></a><h2 id="应用5：负载均衡"><a href="#应用5：负载均衡" class="headerlink" title="应用5：负载均衡"></a>应用5：负载均衡</h2><p>我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器。（会话粘滞session sticky）</p><p>最初想到的是类似 Linux中的页表（将存储虚拟地址空间的虚拟地址映射到物理内存中）一张映射表，我们的维护是（会话粘滞的）一张表内容是将客户端的IP地址和会话ID 与服务器编号，然后再请求变化对应的服务器。这个方法很简单直观，但是又缺陷：</p><ul><li>客户太多，要维护的表很大，比较浪费内存空间</li><li>客户端下线，上线，服务器扩容，缩容都会导致映射失效，这样维护表的成本就会很大；</li></ul><p>如果借助哈希算法，这些问题都可完美解决。<strong>我们可以通过哈希算法，对客户IP地址或者会话IP计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到服务器编号。（类似一致性哈希算法）</strong></p><h2 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h2><h3 id="1-IT日志文件，快速计算关键词被搜索了几次"><a href="#1-IT日志文件，快速计算关键词被搜索了几次" class="headerlink" title="1.IT日志文件，快速计算关键词被搜索了几次"></a>1.IT日志文件，快速计算关键词被搜索了几次</h3><p>举例说明，IT日志文件，这里面记录了用户的搜索关系词，我们想要快速统计出每个是关键次被搜索的记录次数，该怎么做呢？</p><p>难点：</p><ul><li>搜索日志很大，没办法放到一台机器的内存中。</li><li>第二个难点，如果只用一台机器来处理这么巨大的数据，处理时间会很长。</li></ul><p>解决：</p><ul><li><p>首先对数据进行分片。</p><ul><li>首先为了提高处理的速度，我们使用n台机器并行处理。</li></ul></li><li><p>然后采集多台机器处理的方法，来提高处理速度。</p><ul><li><p>我们根据搜索记录的日志文件中一次读出每个搜索的关键次，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器的编号。</p><p>这样所有哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最终合并起来就是最终的结果。</p></li></ul></li></ul><h3 id="2-如何快速判断图片是否在图库中"><a href="#2-如何快速判断图片是否在图库中" class="headerlink" title="2.如何快速判断图片是否在图库中"></a>2.如何快速判断图片是否在图库中</h3><p>同上，按照图片唯一标识（图片前100比特+中间100比特+图片最后100比特）使用加密算法计算哈希值</p><p>然后与机器个数n求于取模，存放在n台机器上。</p><p>查找时也是按照以上的方法进行查找。</p><p>实际上这种<strong>，针对海量数据的处理问题，我们都可以采用多机分布式处理。借助这种分片思路，可以突破单机内存，CPU等资源限制。</strong></p><h2 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h2><p>一致性哈希的应用，海量数据，海量用户。为了提高效率采用分布式存储，分布式缓存。我们有海量数据需要缓存，所以一个缓存机器肯定不够。于是我们就需要将数据分布在多台机器上。</p><p>数据存储在那台机器上我们使用数据分片思想，进行缓存。</p><p>但是随着数据的增长，预估的机器难以缓存的下，我们就需要扩容，但是扩容我们需要rehash，数据分片然后存储，等于将老数据进行了一次数据搬移，耗时太长，效率太低。</p><p>而且重新搬移过程中，所有缓存都失效了。所有数据请求都会穿透缓存，直接去请求数据库。这样就可能发生雪崩效应，压垮数据库。</p><p>所以我们不能使用这种扩容机制，我们需要一致性哈希算法。我们有k台机器，我们按照数据哈希值的范围。我们将整个范围划分成m个小区间(m远大于k),每个机器负责m/k个小区间。这样，既不用重新哈希也不用搬移数据，也保持了各个机器上数据数量的均衡。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>负载均衡</strong>中利用哈希算法代替了映射表，可实现会话粘滞的负载均衡策略。</p><p>在<strong>数据分片</strong>应用中，通过哈希算法对处理的海量数据进行分片，多机分布式处理，突破单继资源限制。</p><p>在<strong>分布式存储应用</strong>中，利用一致性哈希算法，可以解决缓存等分布式系统的扩容，缩容导致数据大量搬移的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;22-哈西算法-下-哈希算法在分布式系统中有哪些应用&quot;&gt;&lt;a href=&quot;#22-哈西算法-下-哈希算法在分布式系统中有哪些应用&quot; class=&quot;headerlink&quot; title=&quot;[22]哈西算法(下): 哈希算法在分布式系统中有哪些应用&quot;&gt;&lt;/a&gt;[22]哈西算法(下): 哈希算法在分布式系统中有哪些应用&lt;/h1&gt;&lt;p&gt;哈希算法上讲了，哈希算法的四个应用，分别是 安全加密、数据检验、唯一标识、散列函数&lt;/p&gt;
&lt;p&gt;还剩下 ：&lt;strong&gt;负载均衡、数据分片、分布式存储&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="哈希算法" scheme="https://soyanga.github.io/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希算法(上)</title>
    <link href="https://soyanga.github.io/2019/04/01/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/04/01/哈希算法(上)/</id>
    <published>2019-04-01T14:45:02.000Z</published>
    <updated>2019-04-01T14:46:12.926Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="21-哈希算法-上-：如何防止数据库中的用户信息被脱库？"><a href="#21-哈希算法-上-：如何防止数据库中的用户信息被脱库？" class="headerlink" title="[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？"></a>[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？</h1><p>哈希算法：将任意长度的二进制串映射成固定长度的二进制串，这个映射的规则就是哈希算法，通过原始数据映射后得到的二进制值就是哈希值。</p><h2 id="优秀哈希算法的要求"><a href="#优秀哈希算法的要求" class="headerlink" title="优秀哈希算法的要求"></a>优秀哈希算法的要求</h2><ul><li>从哈希值不能反向推导出原始数据（哈希算法也叫<strong>单向哈希算法</strong>）</li><li>对输入数据非常敏感，哪怕原始数据只<strong>修改了一个Bit</strong>,最后<strong>得到的哈希也大不相同</strong>；</li><li>散列<strong>冲突的概率很小</strong>，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的<strong>执行效率要尽可能高效</strong>，针对较长的文本，也能快速计算出哈希值</li></ul><a id="more"></a><h2 id="哈希算法的应用"><a href="#哈希算法的应用" class="headerlink" title="哈希算法的应用"></a>哈希算法的应用</h2><p><strong>安全加密</strong>，<strong>唯一标识</strong>，<strong>数据校验</strong>，<strong>散列函数</strong>，负载均衡，数据分片，分布式存储。</p><h2 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h2><h3 id="常用于加密的哈希算法："><a href="#常用于加密的哈希算法：" class="headerlink" title="常用于加密的哈希算法："></a>常用于加密的哈希算法：</h3><p><strong>MD5</strong>:MD5 Message-Digest Algorithm MD5消息摘要算法</p><p><strong>SHA:</strong> Secure Hash Algorithm 安全散列算法</p><p><strong>DES:</strong> Data Encryption Standard 数据加密标准</p><p><strong>AES:</strong> Advanced Encryption Standard 高级加密标准</p><p>加密哈希算法来说 “单项哈希 ”，“散列冲突小”两点很重要</p><p>单项哈希是一个加密哈希算法来说必要的一点。<strong>散列冲突是无法避免的</strong>，因为基于组合数学中一个非常基础的理论<strong>鸽巢原理(也叫抽屉原理)</strong>。也就是10个鸽巢，11个鸽子，那肯定有一个鸽巢的鸽子数量多于1个，换句话说，肯定由2只鸽子在1个鸽巢中。</p><p>所以哈希算法无<strong>法做到零冲突</strong>，MD5的例子哈希值是固定的128为二进制尾，能表示的数据有限的，最多标识2^128^个数据，而我们要哈希的数据是无穷的，基于鸽巢原理，如果我们存储2^128^+1个数据求哈希值，必然会发生哈希冲突。<strong>所以哈希值越长的哈希算法，散列冲突的概率越低</strong>。</p><p>没有绝对的安全加密，<strong>越复杂，越难破解的加密算法，需要计算的时间也就越长。实际开发过程中，也需要权衡破解难度和计算时间，来决定究竟使用那种加密算法。</strong></p><h2 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h2><p>对图片的唯一标识，可以给每个图片取一个唯一标识，或者说信息摘要。比如说可以从图片二进制代码串开头取100字节，从中间取100字节，从最后再取100字节。然后将这300字节拼到一起，通过哈希算法，的到一个哈希值，将其作为图片的唯一标识。过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p><p>还可以把图片的相应图片文件在图库中的路径信息，都存储在散列表中。<strong>提高检索效率</strong></p><p>哈希算法可以对大数据做信息摘要，通过一个较短的二进制编码来表示一个很大的数据。</p><h2 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h2><p>利用<strong>哈希算法对输入数据敏感的特点</strong>，可以对数据取哈希值，从而<strong>高效校验数据是否被篡改过。</strong>（校验文件完整性正确性）</p><p>利用哈希算法的特性改动有效特性，对下载种子文件拆分成若干文件取哈希值，当下载完成后的文件拼接成一个完成文件并分别校验之前划分文件的哈希值是否改变从而确定下载数据的完整性</p><h2 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h2><p>散列函数关注的重点是哈希算法更加关注散列后的值能<strong>不能被平均分布</strong>，以<strong>及散列函数的执行快慢</strong>。（所以，散列函数用的散列算法一般都比较简单，比较追求效率。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>1.如何防止数据库中的用户信息被脱库？你会如何存储用户密码这么重要的数据吗？<br>①使用MD5进行加密（加密存储）<br>②字典攻击：如果用户信息被“脱库”，黑客虽然拿到的是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。（字典中存储用户常用的密码）<br>③针对字典攻击，我们可以引入一个盐（salt），跟用户密码组合在一起，增加密码的复杂度。</p><p>安全和攻击是一种博弈关系，不存在结对安全，所有安全措施，只是增加攻击成本而已。</p><h2 id="区块链中使用的哈希算法"><a href="#区块链中使用的哈希算法" class="headerlink" title="区块链中使用的哈希算法"></a>区块链中使用的哈希算法</h2><p>区块链是一块块区块组成的，每个区块分为两部分：区块头和区块体。</p><p>区块头保存着 自己区块体 和 上一个区块头 的哈希值。</p><p>因为这种链式关系和哈希值的唯一性，只要区块链上任意一个区块被修改过，后面所有区块保存的哈希值就不对了。</p><p>区块链使用的是 SHA256 哈希算法，计算哈希值非常耗时，如果要篡改一个区块，就必须重新计算该区块后面所有的区块的哈希值，短时间内几乎不可能做到。  </p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;21-哈希算法-上-：如何防止数据库中的用户信息被脱库？&quot;&gt;&lt;a href=&quot;#21-哈希算法-上-：如何防止数据库中的用户信息被脱库？&quot; class=&quot;headerlink&quot; title=&quot;[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？&quot;&gt;&lt;/a&gt;[21]哈希算法(上)：如何防止数据库中的用户信息被脱库？&lt;/h1&gt;&lt;p&gt;哈希算法：将任意长度的二进制串映射成固定长度的二进制串，这个映射的规则就是哈希算法，通过原始数据映射后得到的二进制值就是哈希值。&lt;/p&gt;
&lt;h2 id=&quot;优秀哈希算法的要求&quot;&gt;&lt;a href=&quot;#优秀哈希算法的要求&quot; class=&quot;headerlink&quot; title=&quot;优秀哈希算法的要求&quot;&gt;&lt;/a&gt;优秀哈希算法的要求&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;从哈希值不能反向推导出原始数据（哈希算法也叫&lt;strong&gt;单向哈希算法&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;对输入数据非常敏感，哪怕原始数据只&lt;strong&gt;修改了一个Bit&lt;/strong&gt;,最后&lt;strong&gt;得到的哈希也大不相同&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;散列&lt;strong&gt;冲突的概率很小&lt;/strong&gt;，对于不同的原始数据，哈希值相同的概率非常小；&lt;/li&gt;
&lt;li&gt;哈希算法的&lt;strong&gt;执行效率要尽可能高效&lt;/strong&gt;，针对较长的文本，也能快速计算出哈希值&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="哈希算法" scheme="https://soyanga.github.io/tags/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>散列表(下)</title>
    <link href="https://soyanga.github.io/2019/03/28/%E6%95%A3%E5%88%97%E8%A1%A8(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/03/28/散列表(下)/</id>
    <published>2019-03-28T15:59:03.000Z</published>
    <updated>2019-03-28T16:00:10.402Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="20-散列表-下-：散列表和链表将常会一起使用"><a href="#20-散列表-下-：散列表和链表将常会一起使用" class="headerlink" title="[20]散列表(下)：散列表和链表将常会一起使用"></a>[20]散列表(下)：散列表和链表将常会一起使用</h1><h2 id="散列表和链表结合实例"><a href="#散列表和链表结合实例" class="headerlink" title="散列表和链表结合实例"></a>散列表和链表结合实例</h2><h3 id="LRU缓存淘汰算法"><a href="#LRU缓存淘汰算法" class="headerlink" title="LRU缓存淘汰算法"></a>LRU缓存淘汰算法</h3><ul><li>往缓存中添加一个数据</li><li>从缓存中删除一个数据</li><li>从缓存中查找一个数据</li></ul><p>维护一个按访问时间从大到小的有序排列的链表结构。 LRU缓存</p><blockquote><ul><li>因为缓存大小有限，当缓存空间不够用，需要淘汰一个数据的时候，我们就直接将链表头部节点删除。</li><li>当要缓存某个数据时，现在链表中查找这个数据，如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。</li></ul></blockquote><p>三个操作都需要设计查找操作，如果使用单链表则查找操作的时间复杂度就是O(n),如果我们将散列表和链表这两种数据结构组合使用，可以将三个操作的时间复杂度都降到O(1)。</p><a id="more"></a><p>我们使用双向链表+散列表存储 实现一个高效，支持LRU缓存淘汰算法的缓存系统原型。</p><p>链表中的每个节点存储数据<strong>(data</strong>),前驱节点(<strong>prev</strong>)、后继节点(<strong>next</strong>),之外还新增了一个特殊的字段(<strong>hnext</strong>)</p><p><img src="/2019/03/28/散列表(下)/婕\数据结构与算法之美\picture\散列表实现LRU.jpg" alt="散列表实现LRU"></p><blockquote><p><strong>一个链表是双向链表（prev next）将缓存中的数据链来（将节点连在双向链表中）</strong> </p><p><strong>另一个链表是单向链表(hnext) ，为了将节点连在散列表的拉链中。</strong></p></blockquote><h4 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h4><p>利用散列查找数据的时间复杂度是O(1),但是查找完后数据移动到双向链表的尾部。</p><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p>找到数据所在结点，然后将节点删除。借助散列表，我们可以在O(1)时间复杂度里找到要删除的节点。因为我们的链表是双向，O(1)时间复杂度获取到前驱节点，在双向链表中删除一个节点我们只需要O(1)的时间复杂度。</p><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>首先，在散列表中查找要添加的数据是否已经存在，存在的化将次节点移动至双向链表的对尾，反之则再判断缓存队列是否已满，如果满了，则将双向链表头部的节点删除，然后再将数据反到链表的尾部，如果缓存没有慢，则直接将数据放到链表的尾部。</p><p>整个过程涉及的查找操作都是由散列表来完成。其他操作，比如删除头节点，链表尾部插入数据等，都可以在O(1)的时间复杂度内来完成。所以三个操作的时间复杂度都是O(1)。</p><h2 id="Redis有序集合"><a href="#Redis有序集合" class="headerlink" title="Redis有序集合"></a>Redis有序集合</h2><p>redis有序集合中实际上还有两个重要的属性，key（键值）和score (分值)。我们不仅通过Score来查找数据，还会用过key来查找数据。</p><p>比如，用户ID(key) 和用户的积分(score)，我们可以通过ID来查找，也可以同样积分区间来查找用户。</p><h4 id="细化Redis有序集合的操作"><a href="#细化Redis有序集合的操作" class="headerlink" title="细化Redis有序集合的操作"></a>细化Redis有序集合的操作</h4><ul><li>添加一个成员对象；</li><li>按照键值来删除一个成员对象；</li><li>按照键值来查找一个成员对象；</li><li>按照分值区间查找数据，比如查找积分在[100,365]之间的成员对象；</li><li>按照分值从小到大排序成员变量；</li></ul><p>我们可以利用两种数据结构来进行存储且满足有序集合的操作，我们按照分值将成员组织成跳表结构，那按照键值来删除、查询成员对象就会很慢。所以我们在用按照键值构建一个散列表，这样按照key的操作就得以实现O(1)。</p><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>LinkedHashMap是一个传统拉链法构建的容器</p><p>这里的Linked指的是一个双向链表，默认支持按照插入顺序遍历数据，还支持按照顺序来遍历数据</p><p><strong>Java原生的LRU缓存淘汰</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>散列表虽然支持高效的数据插入，删除，查找操作，但是散列表中数据都是通过散列函数打乱后无规律存储的，无法支持按照某种顺序快速的遍历数据。如果希望按照顺序遍历散列表中数据，我们需要将散列表中数据拷贝到数组中，然后排序，再遍历。</p><p>因为散列表是动态数据结构，不停地有数据插入，删除，所以每当我们希望按照顺序遍历散列表中数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表(或跳表)结合使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;



&lt;h1 id=&quot;20-散列表-下-：散列表和链表将常会一起使用&quot;&gt;&lt;a href=&quot;#20-散列表-下-：散列表和链表将常会一起使用&quot; class=&quot;headerlink&quot; title=&quot;[20]散列表(下)：散列表和链表将常会一起使用&quot;&gt;&lt;/a&gt;[20]散列表(下)：散列表和链表将常会一起使用&lt;/h1&gt;&lt;h2 id=&quot;散列表和链表结合实例&quot;&gt;&lt;a href=&quot;#散列表和链表结合实例&quot; class=&quot;headerlink&quot; title=&quot;散列表和链表结合实例&quot;&gt;&lt;/a&gt;散列表和链表结合实例&lt;/h2&gt;&lt;h3 id=&quot;LRU缓存淘汰算法&quot;&gt;&lt;a href=&quot;#LRU缓存淘汰算法&quot; class=&quot;headerlink&quot; title=&quot;LRU缓存淘汰算法&quot;&gt;&lt;/a&gt;LRU缓存淘汰算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;往缓存中添加一个数据&lt;/li&gt;
&lt;li&gt;从缓存中删除一个数据&lt;/li&gt;
&lt;li&gt;从缓存中查找一个数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;维护一个按访问时间从大到小的有序排列的链表结构。 LRU缓存&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;因为缓存大小有限，当缓存空间不够用，需要淘汰一个数据的时候，我们就直接将链表头部节点删除。&lt;/li&gt;
&lt;li&gt;当要缓存某个数据时，现在链表中查找这个数据，如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;三个操作都需要设计查找操作，如果使用单链表则查找操作的时间复杂度就是O(n),如果我们将散列表和链表这两种数据结构组合使用，可以将三个操作的时间复杂度都降到O(1)。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="散列表" scheme="https://soyanga.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>散列表(中)</title>
    <link href="https://soyanga.github.io/2019/03/19/%E6%95%A3%E5%88%97%E8%A1%A8(%E4%B8%AD)/"/>
    <id>https://soyanga.github.io/2019/03/19/散列表(中)/</id>
    <published>2019-03-19T15:55:31.000Z</published>
    <updated>2019-03-19T15:56:34.490Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="19-散列表-中-如何打造一个工业级水平的散列表"><a href="#19-散列表-中-如何打造一个工业级水平的散列表" class="headerlink" title="[19]散列表(中) 如何打造一个工业级水平的散列表"></a>[19]散列表(中) 如何打造一个工业级水平的散列表</h1><p>不能笼统地说散列表的查询效率是O(1),影响散列表查询效率的因素：</p><blockquote><ul><li>散列函数的设计</li><li>装载因子的选取</li><li>扩容策略的选取</li><li>散列冲突的处理</li></ul></blockquote><a id="more"></a><p>在极端情况下，一个并不能达到工业级水平的散列表，会被恶意的攻击者利用。通过一些精心构造的数据，使得所有数据经过散列函数，都能够散列到同一个槽中。如果我们使用的是基于链表的冲突解决方法，那这是，<strong>散列表的这个槽就会退化成一个链表，查询在这个槽对应的时间复杂度就会从O(1)退化为O(n)。</strong></p><p>这个O(n)中的n是恶意攻击者构造的数据的总数，假如其中有10万个数据，则退化后的散列表效率就下降了10万倍。更直接点说，假如我们查询100个数据花费0.1秒，但是退化后的散列表中，在这个槽中查找一个数据就需要1万秒。这样就有可能<strong>查询操作消耗大量的CPU资源或者线程资源</strong>，导致<strong>系统无法响应其他请求</strong>，从而<strong>达到拒绝服务攻击(Dos)的目的</strong>，攻击者也就是利用了<strong>散列表碰撞攻击的基本原理</strong>。</p><p>所以我们需要设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突情况下，散列表性能急剧下降，并且能够抵抗散列碰撞攻击。</p><h2 id="散列函数的设计"><a href="#散列函数的设计" class="headerlink" title="散列函数的设计"></a>散列函数的设计</h2><p>在实际应用，如果我们已知我们在散列表存储的数据，我们需要考虑的是存储的关键字的长度，特点，分布，散列表的大小来设计<strong>散列函数</strong>。</p><h3 id="数据分析法"><a href="#数据分析法" class="headerlink" title="数据分析法"></a>数据分析法</h3><p>1.比如存储手机号，根据手机号的特点，前几位重复的几率很大，后几位重复的几率较小，我们选取后4位作为散列值。</p><p>2.散列表中存储的是单词时，我们可以利用字母的ASCII值“进位”相加，然后再跟散列表的大小求余、取模、作为散列值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">"nice"</span>)=((<span class="string">"n"</span> - <span class="string">"a"</span>) * <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">"i"</span> - <span class="string">"a"</span>)*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">"c"</span> - <span class="string">"a"</span>)*<span class="number">26</span>+ (<span class="string">"e"</span>-<span class="string">"a"</span>)) <span class="comment">//78978</span></span><br></pre></td></tr></table></figure><p>实际上散列函数的设计还有，直接寻址发法，平方取中法，折叠法，随机数法等。</p><h2 id="装载因子的选取与动态扩容策略"><a href="#装载因子的选取与动态扩容策略" class="headerlink" title="装载因子的选取与动态扩容策略"></a>装载因子的选取与动态扩容策略</h2><p><em>装载因子是我们衡量散列表中存储元素个数，和发生散了冲突概率的一个数值。</em></p><p>装载因子越大：说明散列表中元素越多，空闲位置越少，散列表冲突概率就越大。不仅插入数据的过程要多次寻址，或者拉链增长，查找的过程也会因此变慢。</p><h3 id="对于静态数据"><a href="#对于静态数据" class="headerlink" title="对于静态数据"></a>对于静态数据</h3><p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点，分布等，设计出一个冲突很少的散列函数。</p><h3 id="对于动态数据"><a href="#对于动态数据" class="headerlink" title="对于动态数据"></a>对于动态数据</h3><p>数据集合是频繁变动的，我么事先无法预知要加入的数据个数。所以我们无法一次性申请一个足够大的散列表。随着数据慢慢的加入，装载因子就会变大。当装载因子大到一定程度后，散列冲突就会变很频繁，严重影响性能。</p><h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>我们可以使用动态扩容的策略，当装载因子达到某一个阈值后，我们可以进行动态扩容，重新申请了一个更大的散列表，将数据搬移到这个新的散列表中。</p><p>散列表的扩容，并不是像数组那样只是数据搬移。因为散列表的大小变了，数据存储位置也变了，所以我们需要通过散列函数重新计算每个数据存储位置。</p><p><img src="/2019/03/19/散列表(中)/婕\数据结构与算法之美\picture\rehash.png" alt="rehash"></p><p>对于支持动态扩容的散列表，插入操作时间复杂度需要进行摊还分析法。</p><table><thead><tr><th>最好情况（没有进行扩容）插入时间复杂度</th><th>最坏情况(进行扩容)插入时间复杂度</th><th>均摊时间复杂度</th></tr></thead><tbody><tr><td>O(1)</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><p>如果我们对空间消耗很敏感的化，我们可以增加动态缩容功能。如果我们更加在意执行效率的化，能够容忍多消耗一点内存空间，那就可以不用那么费劲来缩容。</p><p>装载因子阈值的设置要权衡时间，空间复杂度。根据内存空间，和执行效率的要求，来进行选择。如果对执行效率不高，且内存空间紧张的情况下，我们可以增加负载因子的值，设置可以大于1。(拉链法)</p><h3 id="如何避免低效的扩容"><a href="#如何避免低效的扩容" class="headerlink" title="如何避免低效的扩容"></a>如何避免低效的扩容</h3><p>其实对用用户来说，需要每次插入数据的体验感都需要很好，所以我们对于那压死哈西表的最后一个插入数据来说，用户此次插入前需要对哈希表进行扩容，所消耗的时间就会边长。</p><p><strong>所以直接的”一次性扩容”就不是很合适，我们可以利用摊还分析法的思想，将那最坏时间复杂度所消耗的时间均摊到每次插入中。</strong></p><p>所以将<strong>扩容操作穿插到插入操作中，分批完成</strong>。<em>当装载因子触达阈值后，我们只申请新的空间，但不进行rehash，将老数据的内容搬移到新的散列表中。</em></p><p>当有新数据要<strong>插入</strong>时，我们将新数据插入到新的散列表中，并且顺带懂老散列表中拿出一个数据放入到新的散列表中。每次插入一个数据到散列表中，我们就顺带稍一点数据进新的散列表。每次我们都重复上面的过程。经过多次插入操作后，老的散列表中的数据就一点一点的全部搬移到新的散列表中了。这样就没有一次性数据搬移，插入操作就变得很快。<strong>这个也是一个空间换时间的方式</strong>。</p><p><img src="/2019/03/19/散列表(中)/婕\数据结构与算法之美\picture\分批扩容策略.png" alt="分批扩容策略"></p><p>期间的<strong>查询</strong>我们为了兼容新，老散列表的数据，<strong>我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。</strong></p><p>这样均摊的方法，讲一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这样插入一个数据的时间复杂度就是O(1)。</p><h2 id="散列冲突处理"><a href="#散列冲突处理" class="headerlink" title="散列冲突处理"></a>散列冲突处理</h2><p>在哈西表(上)中提到了的两种方法<strong>开放寻址法(ThreadLocalMap)</strong>，<strong>拉链法(LinkedHashMap)</strong>。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>数据都存储在数组中，我们可以有效的利用CPU缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。拉链法包含指针，序列化起来就没有那么容易。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>删除数据比较繁琐，需要添加标记。所有数据存储在数组中，随着负载因子的加大，发生冲突后，就会造成恶性循环，加大下一次发生冲突的概率。</p><p>所以使用开放寻址法的散列表，<strong>装载因子的上线不能太大</strong>。所以使用开放寻址法的散列表，<strong>装载因子的上线不能太大</strong>。这种方法比拉链法更加浪费内存空间。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p><strong>数据量比较小，装载因子比较小的时候，适合开放寻址法</strong>。这也是Java中的<strong>ThreadLocalMap</strong>使用开放寻址法解决散列冲突的原因。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>拉链法对内存的利用率比开放寻址法要高。因为链表节点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。<strong>(链表优于数组)</strong></p><p>链表法比开放寻址法，<strong>对于大装载因子容量更高</strong>，开放寻址法装载因子接近1时，就会有大量散列冲突，导致大量的探测，再散列等措施，性能会见降低很对。但是对于链表法来说，<strong>只要散列函数的值随机均匀，即便装载因子变成1</strong>，也就是链表长度长了一点，查找效率虽然有所下降，但是比顺序表查找还是快很多。</p><p><strong>拉链法的升级，将链表达到某一长度后变为更高效的红黑树，跳表等</strong>。这样即便出现散列冲突，极端情况下，所有数据都散列到了同一个桶里，那最终退化成的散列表的查询时间不过是<strong>O(logn)</strong>。这样也避免了DOS攻击。</p><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p><strong>链表中存储指针(next 4字节)，所以对于比较小的对象的存储，比较消耗内存，还有可能会让内存消耗翻倍</strong>，而且，因为链表中的节点零散分布在内存中，不连续，<strong>所以对CPU缓存不友好</strong>，对于<strong>执行效率也有一定影响</strong>。</p><p>如果存储的是大对象，就可以忽略上面这一点。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>基于链表的散列冲突处理方法比<strong>较适合存储大对象、大数据量的散列表</strong>，而且，比起开放寻址法，它<strong>更加灵活，支持更多的优化策略，比如用红黑树代替链表</strong>。</p><h2 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h2><p>Java  HashMap</p><h3 id="初始大小"><a href="#初始大小" class="headerlink" title="初始大小"></a>初始大小</h3><p>HashMap默认的初始化大小16，这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修默认初始大小，减少动态扩容的次数。这样会大大提高HashMap的性能。</p><h3 id="装载因子和动态扩容"><a href="#装载因子和动态扩容" class="headerlink" title="装载因子和动态扩容"></a>装载因子和动态扩容</h3><p>最大装载因子默认是0.75，当HashMap中元素个数超过0.75*capacity(capacity表示散列表容量)时候，就会启动动态扩容，每次扩容都会扩容为原来的2倍大小。</p><h3 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h3><p>HashMap底层采用拉链法来解决冲突。即使负载因子和散列函数设计的再合理，也免不了会出现拉链过程的情况，一旦出现拉链过长，则会严重影响HashMap的性能。</p><p>在JDK1.8版本中，为了对hashMap做了进一步优化，引入了红黑树。当链表长度(默认超过8)时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高HashMap新跟那个。当红黑树节点个数小于6的时候，红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数的设计并不复杂，追求的是简单高效，分布均匀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</span><br><span class="line">     int h;</span><br><span class="line">     // h = key.hashCode() 为第一步 取hashCode值</span><br><span class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>如何设计一个工业级别的Hash表，应对各种异常情况，防止在极端情况下，散列表的性能退化过于严重。</p><ul><li>如何设计散列函数</li><li>如何根据装载因子动态扩容</li><li>如何选择散列冲突解决方法。</li></ul><p>散列函数的设计：我们尽可能让经过散列函数后的值随机分布，这样会尽可能的减少散列冲突，即便冲突后，分配到每一槽的数据也比均匀。除此之外，<strong>散列函数的设计也不能太复杂，太复杂就会消耗太多时间，会影响散列表的性能。</strong></p><p>关于散列冲突解决方法的选择，根据合适的情况选择合适方法。大部分情况下链表发更为合适。而且，我们还可以将链表法中链表改造成其他动态查找数据结构，比如红黑树，来避免散列表时间复杂度退化成O(n),低于散列碰撞攻击。但是对于小规模数据，装载因子不高的散列表，比较合适用开放寻址法。</p><p>对于动态散列表来说，散列函数，<strong>散列冲突解决方法，都无法解决散列冲突问题，只是缓解。随着数据的不断增加，散列表总会出现装载因子过高的情况</strong>。这时候，我们就需要启动动态扩容。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;19-散列表-中-如何打造一个工业级水平的散列表&quot;&gt;&lt;a href=&quot;#19-散列表-中-如何打造一个工业级水平的散列表&quot; class=&quot;headerlink&quot; title=&quot;[19]散列表(中) 如何打造一个工业级水平的散列表&quot;&gt;&lt;/a&gt;[19]散列表(中) 如何打造一个工业级水平的散列表&lt;/h1&gt;&lt;p&gt;不能笼统地说散列表的查询效率是O(1),影响散列表查询效率的因素：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;散列函数的设计&lt;/li&gt;
&lt;li&gt;装载因子的选取&lt;/li&gt;
&lt;li&gt;扩容策略的选取&lt;/li&gt;
&lt;li&gt;散列冲突的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="散列表" scheme="https://soyanga.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>散列表(上)</title>
    <link href="https://soyanga.github.io/2019/03/19/%E6%95%A3%E5%88%97%E8%A1%A8(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/03/19/散列表(上)/</id>
    <published>2019-03-19T15:51:40.000Z</published>
    <updated>2019-03-19T15:54:33.153Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="18-散列表-上"><a href="#18-散列表-上" class="headerlink" title="[18]散列表(上)"></a>[18]散列表(上)</h1><p>Word 单词检查功能-Hash Table</p><p>利用数组的下标随机访问，时间复杂度O(1)这个特性，就可以实现快速查找编号对应大的选手信息。</p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p><strong>散列表键(key)或者关键字</strong>来表示一组数据的关键信息。然后利用<strong>散列函数(Hash函数)</strong>来转化为数组下标。而散列函数计算得到的值就是<strong>散列值(Hash值，哈希值)</strong>。数组下标中存储的值称为<strong>value</strong>。</p><p><img src="/2019/03/19/散列表(上)/哈希表原理.png" alt="哈希表原理"></p><p>由于<strong>散列表用的是数组支持按照下标随机访问的时候</strong>，时间复杂符是<strong>O(1)</strong>的特性。我们通散列函数把元素的建制映射为下标，然后将数据存储在数组中对应的下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将建值转化为数组下标，从对应的数组下标的位置取数据。</p><a id="more"></a><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数的表现形式有多种，其中最为常用的取模（按照基本数组的长度)。</p><p>还有其他的散列函数</p><h2 id="如何构造散列函数"><a href="#如何构造散列函数" class="headerlink" title="如何构造散列函数"></a>如何构造散列函数</h2><ul><li>散列函数计算得到的散列值是一个非负数</li><li>如果key1 = key2,那hash(key1) == hash(key2);</li><li>如果key1 != key2，那hash(key1) !=hash(key2);</li></ul><p>其中第三点的很难做到，想要找到一个不同的key对应的散列值都不一样的散列函数，几乎时不可能的。</p><p>因为数组的存储空间有限，也会加大<strong>散列冲突</strong>的概率。</p><h2 id="如何解决散列冲突问题"><a href="#如何解决散列冲突问题" class="headerlink" title="如何解决散列冲突问题"></a>如何解决散列冲突问题</h2><p> 常用解决散列冲突的方法有两类，开放寻址法和链表法。</p><h3 id="开发寻址法"><a href="#开发寻址法" class="headerlink" title="开发寻址法"></a>开发寻址法</h3><p>开放寻址法的核心思想就i是，如果出现散列冲突，我们就重新探测一个空闲的位置，将其插入。探测的方法有多种，比如<strong>线性探测</strong>，<strong>二次探测</strong>，<strong>双重散列</strong>。</p><h4 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h4><p>假如要存储的值经过hash算法计算后得到的下标已经被占用，就向后线性一个一个向后进行探测。</p><p>所谓探测，有三点要求</p><blockquote><p>哈希冲突的下标后也已经被占用则就继续向后探测，直到找到数组中没有被占用的下标将冲突的数据插入。</p></blockquote><blockquote><p>假如从发生哈希冲突的那个点开始，向后进行线性探测，探测到数组的末尾后就又从数组的头开始进行探测。</p><p>假如从在Hashtable中删除了某个元素，我们就需要将当前删除的元素做一个标记（falg）。</p></blockquote><p>只有满足探测的位置为空且探测位置没有flag标记，才进行数据的存储。</p><h4 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h4><p>在线性探测的基础上，只是改变了探测的规则，每次探测相隔的距离不同。比如说每次探测的跨度为2。</p><h4 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a>双重散列</h4><p>当插入数据的时候使用hash1(),当发生散列冲突的时候就要使用hash2()，再次发生散列冲突的时候再次使用hash3()。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>开发地址法：<strong>有一个致命的缺点，就是他只能缓解少量散列冲突，当散列冲突发生多次时，后续对Hash表的插入发生散列冲突的概率就会大大提高</strong>，<strong>散列表的性能就会下降</strong>。进而为了保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定的比例的空闲槽位。我们引入了<strong>装载因子</strong>来表示空位的多少。</p><p>装载因子的计算公式是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子 = 填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能就会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p>链表法是一种更加常用的散列冲突解决方法，相比开放寻址法，它更为有效，采用空间换时间的原理。</p><p><strong>数组+链表存储结构</strong></p><p>每当发生散列冲突时，就将发生冲突的数据存储在链表中。链表插入操作时间复杂度O(1),查找删除一个元素怒时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或者删除时间复杂度实际上跟链表长度K成正比，也就是O(k)。</p><p>对于散列表均匀的散列表来说，理论上讲，k = n/m,其中n表示表示散列中数据的个数，m表示散列表中的槽数。</p><h2 id="Word文档中单词检查拼写功能是如何实现的？"><a href="#Word文档中单词检查拼写功能是如何实现的？" class="headerlink" title="Word文档中单词检查拼写功能是如何实现的？"></a>Word文档中单词检查拼写功能是如何实现的？</h2><p>将常用单词(约20万)存放到散列表中，平均一个单词10字节的内存空间，那么20万英文单词约占2MB空间，将2MB的数据存储在内存中。</p><p>当我们输入英文单词时，我们就拿用户输入的单词去散列表中进行查找。如果查找到，说明拼写正确；如果没有查找到，则说明拼写可能有误，给予提示，借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;18-散列表-上&quot;&gt;&lt;a href=&quot;#18-散列表-上&quot; class=&quot;headerlink&quot; title=&quot;[18]散列表(上)&quot;&gt;&lt;/a&gt;[18]散列表(上)&lt;/h1&gt;&lt;p&gt;Word 单词检查功能-Hash Table&lt;/p&gt;
&lt;p&gt;利用数组的下标随机访问，时间复杂度O(1)这个特性，就可以实现快速查找编号对应大的选手信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;散列表键(key)或者关键字&lt;/strong&gt;来表示一组数据的关键信息。然后利用&lt;strong&gt;散列函数(Hash函数)&lt;/strong&gt;来转化为数组下标。而散列函数计算得到的值就是&lt;strong&gt;散列值(Hash值，哈希值)&lt;/strong&gt;。数组下标中存储的值称为&lt;strong&gt;value&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/03/19/散列表(上)/哈希表原理.png&quot; alt=&quot;哈希表原理&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;strong&gt;散列表用的是数组支持按照下标随机访问的时候&lt;/strong&gt;，时间复杂符是&lt;strong&gt;O(1)&lt;/strong&gt;的特性。我们通散列函数把元素的建制映射为下标，然后将数据存储在数组中对应的下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将建值转化为数组下标，从对应的数组下标的位置取数据。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="散列表" scheme="https://soyanga.github.io/tags/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>跳表</title>
    <link href="https://soyanga.github.io/2019/03/12/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://soyanga.github.io/2019/03/12/跳表/</id>
    <published>2019-03-12T14:47:22.000Z</published>
    <updated>2019-03-12T14:48:59.338Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="跳表-beers-–动态数据结构"><a href="#跳表-beers-–动态数据结构" class="headerlink" title="跳表:beers:–动态数据结构"></a>跳表:beers:–动态数据结构</h1><p>二分查找算法中底层是依赖数组实现的（依赖数组的随机访问的特性）。又有众多弊端，比如只能操作已排好序的数据。且拥有数组这个数据结构的弊端。比如对数据频繁的增加或者删除操作时间复杂度高，每次数据增加删除还需要保持数据的有序性（即只支持静态数据集），存储数据必须依数组所以开辟内存时，必须是需要连续的内存空间。（对空间要求比较严格)。  数据量太小也不需要使用二分查找，基本没有什么性能上的区别，但是假如一个数据集中它存储的（300字符）字符串，比较操作比较费时间，则就可以使用二分查找。</p><p>二分查找的思想其实可以用在链表中，比如：跳表</p><p>跳表的核心思想：分区，建立多级索引，“二分查找”</p><p>跳表可以支持快速插入，删除，查找操作，写起来也不复杂，代码的可读性较高（跟功能差不多的红黑树相比），Redis中的有序集合(Sort Set)就是用跳表来实现的<strong>。为什么Redis中会选取跳表作为实现有序集合而不是红黑树</strong>？</p><a id="more"></a><h2 id="跳表的数据结构详解"><a href="#跳表的数据结构详解" class="headerlink" title="跳表的数据结构详解"></a>跳表的数据结构详解</h2><p>对于一个单链表来说，即便链表中存储的数据是有序的查找链表中的某一个值得元素，也需要O(n)的时间复杂度，如何提高查找效率，一想到查找，就想到数据库中的查找（建立索引）。对于一个有序链表我们可以建立索引（分成区间），缩短从链表头部向目标元素的遍历的节点个数，从而达到提高查找效率。</p><h3 id="索引建立（多级索引）"><a href="#索引建立（多级索引）" class="headerlink" title="索引建立（多级索引）"></a>索引建立（多级索引）</h3><p>在原始链表上建立索引或者称为(索引层)。其中索引层节点中存储的是索引值和指向索引值的对应下一级节点的指针(down指针)。</p><blockquote><p>单级索引是提高了不少查找的效率但是多级索引更能提升性能。</p></blockquote><p>这种链表+多级索引的数据结构，就是跳表。如下图：</p><p><img src="/2019/03/12/跳表/婕\数据结构与算法之美\picture\跳表图解.jpg" alt="跳表图解"></p><h2 id="跳表的查找删除的时间复杂度分析"><a href="#跳表的查找删除的时间复杂度分析" class="headerlink" title="跳表的查找删除的时间复杂度分析"></a>跳表的查找删除的时间复杂度分析</h2><h3 id="跳表查询时间复杂度分析"><a href="#跳表查询时间复杂度分析" class="headerlink" title="跳表查询时间复杂度分析"></a>跳表查询时间复杂度分析</h3><p>假如我们如上图定义的每隔一个节点就建立一个索引，那么假设原始数据有n个节点，则建立得到第一级节点大约就有n/2个节点，再往上建立索引则就有n/4、n/8、n/16…即第k层建立的索引是K-1层建立索引的1/2，那么第k级索引节点个数就是n/(2^k^)。</p><p><img src="/2019/03/12/跳表/婕\数据结构与算法之美\picture\多层跳表解析.jpg" alt="多层跳表解析"></p><p>假设我们的原始数据建立的索引有h层，最高层的索引有两个节点。则 <strong>n/(2^h^) = 2</strong> ,从而求得 <strong>h = log~2~(n-1)</strong></p><p>我们求得整个跳表得高度就是<strong>log2^(n-1)</strong>^,假设每层跳表我们遍历m个节点则从跳表中查询一个元素的时间复杂度就是<strong>O(m*logn)</strong>。</p><p>由于我们跳表是每隔一个节点就建立一个上层索引，最上层索引的节点的数量最大不超过3。从最上层节点确定区间后再往down指针下寻找更细的的区间划分在此层也只需按照上层一样最多遍历3个节点，依次类推。<strong>m的值就是一个常数3</strong>。</p><p>所以在跳表中查找人一个数据的<strong>时间复杂度就是O(logn)</strong>,这个查找的时间复杂度跟二分查找的时间复杂度相同，所以近似上我们是纵向的划分索引，然后横向利用二分查找，找符合区间的思想一层一层向下遍历，直到找到目标元素。</p><p><img src="/2019/03/12/跳表/婕\数据结构与算法之美\picture\跳表时间复杂度分析.jpg" alt="跳表时间复杂度分析"></p><h2 id="跳表的空间复杂度"><a href="#跳表的空间复杂度" class="headerlink" title="跳表的空间复杂度"></a>跳表的空间复杂度</h2><p>跳表的思想就是典型的用空间换时间的思想，几乎所有查找高效的数据结构都是用这样的思想。</p><p>假设原始链表大小为n，那第一级索引大约有n/2个节点，第二级索引大约有n/4个节点，依次类推，每上升一级就减少一半，直到剩下2个节点。所以跳表的索引节点总数为:n/2+n/4+n/8+…+8+4+2=n-2。是一个等比数列所以跳表的时间复杂度是O(n)。</p><h3 id="减少跳表的占用的内存空间"><a href="#减少跳表的占用的内存空间" class="headerlink" title="减少跳表的占用的内存空间"></a>减少跳表的占用的内存空间</h3><p>我们可以通过每隔多层节点建立索引，比如每隔2个结点或者每隔3个节点建立索引。那么就可以减少每层索引的节点数目。</p><p>当每隔2个节点就建立索引的化，我们建立索引的节点数=n/3+n/9+n/27+9+3+1=n/2。尽管空间复杂度还是O(n),但是比上面的每两个节点抽出一个节点的索引构建的方法，要减少一半的索引节点存储空间。</p><h3 id="实际开发中看待索引节点占用的空间"><a href="#实际开发中看待索引节点占用的空间" class="headerlink" title="实际开发中看待索引节点占用的空间"></a>实际开发中看待索引节点占用的空间</h3><p>实际开发中索引节点中存储的是要查找的对象属性和一个down指针，原始数据存储的则是大的对象，相比于原始数据的大小，索引所占用的额外的空间就可以忽略了。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>因为数据的插入和删除都需要保证原始数据的有序，所以跳表的插入也需要用到插找的思想，找到适合插入的前一个节点后面，利用链表插入操作对原始数据进行插入。</p><p>删除跟插入类似，但是删除必须利用查找找到要删除节点的前驱节点，进行链表是删除操作。</p><h2 id="跳表的索引更新"><a href="#跳表的索引更新" class="headerlink" title="跳表的索引更新"></a>跳表的索引更新</h2><p>假如在原始数据的基础上跳表中的元素增加删除会导致某一个区间里面的元素众多，导致查找效率变低，甚至跟单链表查找效率类似。作为一个动态结构，我们需要某种手段来维护索引与原始链表大小的之间的平衡，如果某个区间内节点过多就需要多建立索引，某个区间内节点过少就要适当删减索引。</p><h3 id="跳表维护平衡性"><a href="#跳表维护平衡性" class="headerlink" title="跳表维护平衡性"></a>跳表维护平衡性</h3><p>通过一个随机数函数，来决这个节点插入到那几级索引中，随机函数生成了k就将这个节点添加到第一级到第k级这k级索引中。</p><h2 id="为什么Redis中的有序集合是通过跳表来实现的"><a href="#为什么Redis中的有序集合是通过跳表来实现的" class="headerlink" title="为什么Redis中的有序集合是通过跳表来实现的"></a>为什么Redis中的有序集合是通过跳表来实现的</h2><p>严格上来讲，起始还用到了散列表。</p><p>根据Redis开发手册，就会发现Redis中的有序结合支持的核心操作主要有下面几个:</p><ul><li>插入一个数据</li><li>删除一个数据</li><li>查找一个数据</li><li>按照区间查找数据(比如查找[0,100]之间的数据)</li><li>迭代输出有序序列</li></ul><ol><li>除了区间查找这个操作，跳表可一做到O(logn)的时间复杂度定位区间定位起点，然后在原始链表中顺序往后遍历就可以了，比红黑树来说高效，其余操作红黑树跟跳表都可以高效实现。</li><li>跳表代码相比红黑树来说易于实现，且代码可读性高，不易出错，跳表更加灵活，它可以通过该表索引构建策略，有效平衡执行效率和内存消耗。</li></ol><p>缺点：</p><p>跳表出现的时间比较晚，很多编程语言中Map类型都是红黑树来实现的。业务开发过程中，直接拿来使用就可以了，不需要费劲自己去实现一个红黑树，但是跳表并没有一个线程的实现，所以开发中，如果你想使用跳表，必须要自己实现。</p><h1 id="跳表的实现"><a href="#跳表的实现" class="headerlink" title="跳表的实现"></a>跳表的实现</h1>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;跳表-beers-–动态数据结构&quot;&gt;&lt;a href=&quot;#跳表-beers-–动态数据结构&quot; class=&quot;headerlink&quot; title=&quot;跳表:beers:–动态数据结构&quot;&gt;&lt;/a&gt;跳表:beers:–动态数据结构&lt;/h1&gt;&lt;p&gt;二分查找算法中底层是依赖数组实现的（依赖数组的随机访问的特性）。又有众多弊端，比如只能操作已排好序的数据。且拥有数组这个数据结构的弊端。比如对数据频繁的增加或者删除操作时间复杂度高，每次数据增加删除还需要保持数据的有序性（即只支持静态数据集），存储数据必须依数组所以开辟内存时，必须是需要连续的内存空间。（对空间要求比较严格)。  数据量太小也不需要使用二分查找，基本没有什么性能上的区别，但是假如一个数据集中它存储的（300字符）字符串，比较操作比较费时间，则就可以使用二分查找。&lt;/p&gt;
&lt;p&gt;二分查找的思想其实可以用在链表中，比如：跳表&lt;/p&gt;
&lt;p&gt;跳表的核心思想：分区，建立多级索引，“二分查找”&lt;/p&gt;
&lt;p&gt;跳表可以支持快速插入，删除，查找操作，写起来也不复杂，代码的可读性较高（跟功能差不多的红黑树相比），Redis中的有序集合(Sort Set)就是用跳表来实现的&lt;strong&gt;。为什么Redis中会选取跳表作为实现有序集合而不是红黑树&lt;/strong&gt;？&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="跳表" scheme="https://soyanga.github.io/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二分查找(下)</title>
    <link href="https://soyanga.github.io/2019/03/05/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/03/05/二分查找(下)/</id>
    <published>2019-03-05T14:04:49.000Z</published>
    <updated>2019-03-05T14:05:40.481Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="16-二分查找-下-：如何快速定位IP对应的省份地址"><a href="#16-二分查找-下-：如何快速定位IP对应的省份地址" class="headerlink" title="[16]二分查找(下)：如何快速定位IP对应的省份地址"></a>[16]二分查找(下)：如何快速定位IP对应的省份地址</h1><h2 id="4种常见的二分查找变形问题-four"><a href="#4种常见的二分查找变形问题-four" class="headerlink" title="4种常见的二分查找变形问题:four:"></a>4种常见的二分查找变形问题:four:</h2><blockquote><ul><li>查找第一个值等于给定值的元素</li><li>查找对后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值的元素</li></ul></blockquote><a id="more"></a><h3 id="查找第一个值等于给定值的元素"><a href="#查找第一个值等于给定值的元素" class="headerlink" title="查找第一个值等于给定值的元素"></a>查找第一个值等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low &lt; n &amp;&amp; a[low]==value)&#123;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)&#123;</span><br><span class="line">            high = mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid] &lt;value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid == <span class="number">0</span>)||(a[mid-<span class="number">1</span>]!=value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="稍加解释："><a href="#稍加解释：" class="headerlink" title="稍加解释："></a>稍加解释：</h4><p>区间mid值判断只有三种情况</p><ul><li>mid值大于value值<ul><li>high = mid -1;</li></ul></li><li>mid值小于value值<ul><li>low = mid+1;</li></ul></li><li>mid值等于value值<ul><li>mid值==0    说明value对应的值已经是数组第一个元素前面没有相同的元素</li><li>a[mid-1]对应的不是value值  说明value对应的值已经是肯定是查找到的第一个元素</li><li>不符合以上两种的  说明当前下标对应的元素不是找到的第一个元素，前面还有相同的值<ul><li>high = mid - 1;</li></ul></li></ul></li></ul><h3 id="查找对后一个值等于给定值的元素"><a href="#查找对后一个值等于给定值的元素" class="headerlink" title="查找对后一个值等于给定值的元素"></a>查找对后一个值等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; value)&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt; value)&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid==n-<span class="number">1</span>) || (a[mid+<span class="number">1</span>]!=value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟第一种思路差不多</p><h3 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>); </span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt;= value)&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid == <span class="number">0</span>)|| (a[mid -<span class="number">1</span>] &lt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍加解释；</p><ul><li>如果a[mid]小于要查找的值value,那么查找的值肯定在[mid+1,high]之间，更新 low = mid+1;</li><li>如果a[mid]大于要查找的值value，那么我们先看一下这个a[mid]是不是我们要找的第一个值大于等于给定值得元素。如果a[mid]前面已经没有元素，或者前面一个元素小于要查找的值value,那么a[mid]就是我们要查找的元素。</li><li>如果a[mid - 1]也大于等于要查找的值value,那么说明要查找的元素在[low,mid-1]之间，更新high = mid-1;</li></ul><h3 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span> <span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; value)&#123;</span><br><span class="line">            high = mid -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>((mid == n-<span class="number">1</span>)|| (a[mid+<span class="number">1</span>] &gt; value))&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决思考题：查找12万条IP归属地中目标IP归属地</p><p>假设IP地址与归属地的对应关系不经常更新，我们可以预先处理12万条数据，让其按照IP从小到大排序。ip地址可以转化为12万条数据，让其按其实IP从小到大排序。</p><p>然后查找在有序数组中，最后一个小于等于某个给定值的元素。</p><p>找到最后一个其实Ip小于等于这个IP的IP区间，检查这个IP是否在这个IP区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。-1</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>二分查找的表中容易出错</p><p>处理<strong>好终止条件 ，区间上下界更新的方法，返回值的选择。</strong></p><p>LeetCode 33题</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;16-二分查找-下-：如何快速定位IP对应的省份地址&quot;&gt;&lt;a href=&quot;#16-二分查找-下-：如何快速定位IP对应的省份地址&quot; class=&quot;headerlink&quot; title=&quot;[16]二分查找(下)：如何快速定位IP对应的省份地址&quot;&gt;&lt;/a&gt;[16]二分查找(下)：如何快速定位IP对应的省份地址&lt;/h1&gt;&lt;h2 id=&quot;4种常见的二分查找变形问题-four&quot;&gt;&lt;a href=&quot;#4种常见的二分查找变形问题-four&quot; class=&quot;headerlink&quot; title=&quot;4种常见的二分查找变形问题:four:&quot;&gt;&lt;/a&gt;4种常见的二分查找变形问题:four:&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查找第一个值等于给定值的元素&lt;/li&gt;
&lt;li&gt;查找对后一个值等于给定值的元素&lt;/li&gt;
&lt;li&gt;查找第一个大于等于给定值的元素&lt;/li&gt;
&lt;li&gt;查找最后一个小于等于给定值的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="二分查找" scheme="https://soyanga.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>二分查找(上)</title>
    <link href="https://soyanga.github.io/2019/03/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/03/03/二分查找(上)/</id>
    <published>2019-03-03T15:18:53.000Z</published>
    <updated>2019-03-03T15:20:44.750Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="15-二分查找-上-：如何用最省内存的方式实现快速查找功能"><a href="#15-二分查找-上-：如何用最省内存的方式实现快速查找功能" class="headerlink" title="[15]二分查找(上)：如何用最省内存的方式实现快速查找功能"></a>[15]二分查找(上)：如何用最省内存的方式实现快速查找功能</h1><h2 id="二分查找-Binary-Search-open-book"><a href="#二分查找-Binary-Search-open-book" class="headerlink" title="二分查找(Binary Search) :open_book:"></a>二分查找(Binary Search) :open_book:</h2><p>Binary Search 算法，也称折半查找。二分查找的思想很简单-类似与小时候玩的猜数字游戏。</p><p>一个人先确定一个数组，另一个随便猜一个数字(中间数)。确定数字的那个人只需要说大了还是小了就行。每说一次就能让可能存在这个数的区间减小一半，知道区间减小到只有一个数字即猜对了这个数。(最坏情况)</p><a id="more"></a><p><img src="/2019/03/03/二分查找(上)/婕\数据结构与算法之美\picture\二分查找猜数字游戏.png" alt="二分查找猜数字游戏"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><strong>二分查找针对的是一个==有序的数据结合==，查找思想有点类似分治思想，每次都通过跟区间的==中间元素==对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0</strong></p><p>二分查找的时间复杂度：O(logn)</p><blockquote><p>被查找期间的大小变化</p><p>n ，n/2 , n/4 , n/8 , n/2^k…</p></blockquote><p>可以看出，这是一个等比数列。其中n/2^k=1时，k的值就是总共缩小的次数，而每次缩小操作只涉及两个数据的大小比较，所以，经过k次区间缩小操作，时间复杂度就时O(k)。又因为n/2^k=1,我们可以求出k=log2n，所以时间复杂度就是O(logn)。</p><p>O(logn) 的时间复杂度比一定比O(1)时间复杂度的算法执行效率高。大O标记法表示时间复杂度得到时候，会忽略掉低阶，常数，系数。对于常量级的时间复杂度算法来说。O(1)可能表示的是一个非常大的常量值,比如O(1000),O(10000).所以常量级时间复杂度算法有时候可能还没有O(logn)的算法执行效率高。</p><h2 id="简单版本二分查找的递归与非递归实现"><a href="#简单版本二分查找的递归与非递归实现" class="headerlink" title="简单版本二分查找的递归与非递归实现"></a>简单版本二分查找的递归与非递归实现</h2><p>最简单的情况就是有序数组中不存在重复元素。</p><h3 id="非递归版"><a href="#非递归版" class="headerlink" title="非递归版"></a>非递归版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = low + ((high-low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(a[mid] == vaule)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;value)&#123;</span><br><span class="line">            low= mid - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><h5 id="循环的条件"><a href="#循环的条件" class="headerlink" title="循环的条件"></a>循环的条件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">low&lt;=high</span><br></pre></td></tr></table></figure><h5 id="mid的取值"><a href="#mid的取值" class="headerlink" title="mid的取值"></a>mid的取值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果使用mid = (low+high)/2，可能会导致数据的溢出。改进方法有三种</span><br><span class="line">1.mid = low +(high-low)/2;</span><br><span class="line">2.mid = low+((high-low)&gt;&gt;1);</span><br><span class="line">3.mid = (low&amp;high)+((low^high)&gt;&gt;1);</span><br></pre></td></tr></table></figure><h5 id="low和high值的更新"><a href="#low和high值的更新" class="headerlink" title="low和high值的更新"></a>low和high值的更新</h5><p>low=mid+1,high=mid-1。注意这里的+1和-1.如果直接写成low=mid或者high=mid，就可能造成死循环，因为当low=3,high=3时但是a[3]不能与value,本应该就跳出循环，但是如果low和high的更新值错误导致死循环。</p><h3 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二分查找递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> n,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> brearchInternally(a,<span class="number">0</span>,n-<span class="number">1</span>,val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">brearchInternally</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> low,<span class="keyword">int</span> high,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)&#123;</span><br><span class="line">        reutrn value;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[mid]&lt;vlaue)&#123;</span><br><span class="line">    <span class="keyword">return</span> brearchInternally(a,mid+<span class="number">1</span>,high,value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> brearchInternally(a,low,mid-<span class="number">1</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找的应用场景的局限性"><a href="#二分查找的应用场景的局限性" class="headerlink" title="二分查找的应用场景的局限性"></a>二分查找的应用场景的局限性</h2><table><thead><tr><th>时间复杂度</th><th>使用特定数据结构存储数据</th><th>数据必须达到的特殊要求</th></tr></thead><tbody><tr><td>O(logn)</td><td>二分查找依赖舒顺序表(数组)，按下标随机访问数据时间复杂度O(1)</td><td>二分查找针对的有序数据，且不能频繁的删除，插入。一次排序，多次二分查找</td></tr></tbody></table><h3 id="特定的数据结构顺序表-数组"><a href="#特定的数据结构顺序表-数组" class="headerlink" title="特定的数据结构顺序表-数组"></a>特定的数据结构顺序表-数组</h3><p>二分查找需要按照下标随机访问。数组按照下标随机访问数据时间复杂度是O(1),而链表随机访问时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂度就会变得很高。</p><h3 id="针对的数据必须是有序的"><a href="#针对的数据必须是有序的" class="headerlink" title="针对的数据必须是有序的"></a>针对的数据必须是有序的</h3><p>要想使用二分查找时，数据必须是有序的。如果数据没有序，我们需要先排序。排序最低的时间复杂度是O(nlogn)。如果我们针对的是一个静态的数据，没有频繁的插入，删除，我们可以进行一次排序，多次二分查找。这样排序成本被均摊了，二分查找的边际成本就会比较低。</p><p>但是针对动态的数据，一直有数据的频繁的插入和删除操作，要想使用二分查找，要么每次插入，删除操作后保证数据仍有序，要么在每次二分查找前必须进行排序。这种动态数据集合，无论那种方法，维护有序的成本都很高。</p><p>二分查找只能应用在插入和删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找不再适用。我们将适用二叉树。</p><h3 id="数据量太小不适合二分查找"><a href="#数据量太小不适合二分查找" class="headerlink" title="数据量太小不适合二分查找"></a>数据量太小不适合二分查找</h3><p>如果要处理的是数据量很小的数据，没有必要适用二分插找，直接使用顺序遍历就可以了。只有数据量比较大时，二分查找的优势才会比较明显。</p><p>但是有一个特例：</p><p>比如数据之间的比较操作比较耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间对比就会非常耗时。我们需要尽可能的减少比较次数，而比较次数的减少会大大提高性能，此时使用二分查找效果更好。</p><h3 id="数据量太大也不适合二分查找"><a href="#数据量太大也不适合二分查找" class="headerlink" title="数据量太大也不适合二分查找"></a>数据量太大也不适合二分查找</h3><p>原因二分查找依赖的数据结构，数组为了支持随机访问的特性，要求内存空间连续，对没存的要求比较严格。我们有1GB大小的数据，如果希望用数组来存储，那就需要1GB的连续内存空间。</p><p>“连续”的意思就是，即便有2GB的内存空间剩余但是，如果剩余的2GB的内存空间时不连续的，没有一块连续的1GB内存空间，那样照样无法申请一个1GB大小的数组。因为基于数组数据结构的原因，所以太大的数据用数组存储就比较吃力了，所以就不能使用二分查找了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>二分查找的核心思想理解起来非常简单，有点类似分治思想。即每次都通过跟区间中的中间元素对比，将待查找区间缩小为一半，直到找到要查找的元素，或者区间被缩小为0。但是二分查找的代码实现比较容易写错。你需要着重掌握它的三个容易错的地方：</p><ul><li>循环退出条件</li><li>mid取值（求了两个数的平均值）</li><li>low和high的更新</li></ul><p>二分查找虽然性能优秀，但是应用场景也比较有限。底层必须依赖数组，并且还要求数据时有序的。对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显。二分查找更适合处理静态数据，也就是没有频繁的数据的插入，删除操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;15-二分查找-上-：如何用最省内存的方式实现快速查找功能&quot;&gt;&lt;a href=&quot;#15-二分查找-上-：如何用最省内存的方式实现快速查找功能&quot; class=&quot;headerlink&quot; title=&quot;[15]二分查找(上)：如何用最省内存的方式实现快速查找功能&quot;&gt;&lt;/a&gt;[15]二分查找(上)：如何用最省内存的方式实现快速查找功能&lt;/h1&gt;&lt;h2 id=&quot;二分查找-Binary-Search-open-book&quot;&gt;&lt;a href=&quot;#二分查找-Binary-Search-open-book&quot; class=&quot;headerlink&quot; title=&quot;二分查找(Binary Search) :open_book:&quot;&gt;&lt;/a&gt;二分查找(Binary Search) :open_book:&lt;/h2&gt;&lt;p&gt;Binary Search 算法，也称折半查找。二分查找的思想很简单-类似与小时候玩的猜数字游戏。&lt;/p&gt;
&lt;p&gt;一个人先确定一个数组，另一个随便猜一个数字(中间数)。确定数字的那个人只需要说大了还是小了就行。每说一次就能让可能存在这个数的区间减小一半，知道区间减小到只有一个数字即猜对了这个数。(最坏情况)&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="二分查找" scheme="https://soyanga.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>排序(下)</title>
    <link href="https://soyanga.github.io/2019/03/02/%E6%8E%92%E5%BA%8F(%E4%B8%8B)/"/>
    <id>https://soyanga.github.io/2019/03/02/排序(下)/</id>
    <published>2019-03-02T15:54:52.000Z</published>
    <updated>2019-03-17T08:39:56.073Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="13-排序-下-线性排序-strawberry"><a href="#13-排序-下-线性排序-strawberry" class="headerlink" title="[13]排序(下)-线性排序:strawberry:"></a>[13]排序(下)-线性排序:strawberry:</h1><table><thead><tr><th>非基于比较的 线性排序</th><th>时间复杂度</th><th>适用场合</th></tr></thead><tbody><tr><td>桶排序</td><td>O(n)</td><td><strong>数据量大，数据存储在磁盘上，内存有限（数据范围不大）</strong></td></tr><tr><td>计数排序</td><td>O(n)</td><td><strong>计数排序只能用在数据范围不大的场景中</strong></td></tr><tr><td>基数排序</td><td>O(n)</td><td><strong>数据可以划分高低位，且每一位之间后递进关系，每一位范围不能大，因为每一位的稳定排序依赖桶排或者计数排序</strong></td></tr></tbody></table><a id="more"></a><p>桶排序，计数排序，基数排序都是线程排序。之所以可以做到线程的时间复杂度，主要原因是，这三个算法是基于<strong>非比较</strong> 的排序算法，都不设计元素之间的比较操作。</p><p><strong>这几种排序对要排序的数据要求很苛刻，我们重点要学习的是这三种排序的适用场景。</strong> </p><h1 id="思考题-thinking"><a href="#思考题-thinking" class="headerlink" title="思考题:thinking:"></a>思考题:thinking:</h1><p>如何根据年龄给100万用户排序？O(n)</p><h1 id="桶排序-Bucket-Sort-package"><a href="#桶排序-Bucket-Sort-package" class="headerlink" title="桶排序(Bucket Sort):package:"></a>桶排序(Bucket Sort):package:</h1><h2 id="核心思想-collision"><a href="#核心思想-collision" class="headerlink" title="核心思想:collision:"></a><strong>核心思想:collision:</strong></h2><p>将要排序的数据分到几个有序桶中，每个桶里的数据再单独进行排序<strong>。桶内排完序后，再把</strong>每个桶里的数据按照顺序依次取出**，组成的序列就是有序的了。</p><ul><li>将要排序数据分到<strong>有序桶中</strong> </li><li><strong>每个桶中数据进行排序</strong></li><li>桶内排完序后，再把<strong>每个桶里的数据按照顺序依次取出</strong>。</li></ul><h3 id="桶排序为什么是O-n-时间复杂度"><a href="#桶排序为什么是O-n-时间复杂度" class="headerlink" title="桶排序为什么是O(n)时间复杂度"></a><strong>桶排序为什么是O(n)时间复杂度</strong></h3><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\桶排序示例.png" alt="桶排序示例"></p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h3><p>排序的数据有n个，我们把他们均匀的划分到m个桶内，每个桶就有k=n/m个元素。每个桶内部使用快排，时间复杂度O(K<em>logk)。m个桶排序的时间复杂度就是O(m\</em>klogk),因为k = n/m,所以整个桶排序的时间复杂度就是O(n*log(n/m))。<strong>当桶的个数接近与数据个数n时，log(n/m)就是一个非常小的常量，这时候桶排序的时间复杂度接近O(n)。</strong></p><p><strong>但是</strong>以上能实现O(n)时间复杂度的<strong>前提是</strong></p><p><strong>一是：</strong> </p><blockquote><ul><li><strong>能将数据很容易的划分成n个桶，</strong></li><li><strong>桶与桶之间有着天然的大小顺序。</strong></li></ul></blockquote><p><strong>这样每个桶内的数据都排完序后，桶与桶之间的数据就不需要再进行排序了。</strong></p><p><strong>二是：</strong> </p><blockquote><ul><li><strong>数据再各个桶之间的分布是比较平均的。</strong></li></ul></blockquote><p>如果数据经过桶的划分之后，有些桶里的数据非常多，有些桶里的数据非常的少，很不平均，那通内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为O(nlogn)排序算法了。</p><h2 id="适应场景-sun-with-face"><a href="#适应场景-sun-with-face" class="headerlink" title="适应场景:sun_with_face:"></a>适应场景:sun_with_face:</h2><p><strong>桶排序比较适合用在外部排序中。</strong> <strong><em>所谓的外部排序就是数据存储啊在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</em></strong> </p><h2 id="借助桶排序来处理问题：10G订单数据按照订单金额进行排序"><a href="#借助桶排序来处理问题：10G订单数据按照订单金额进行排序" class="headerlink" title="借助桶排序来处理问题：10G订单数据按照订单金额进行排序"></a>借助桶排序来处理问题：10G订单数据按照订单金额进行排序</h2><p>我们只有几百MB，没办法一次性把10G数据都加载到内存中。这时我们可以利用桶排序的思想来处理这个问题。</p><ol><li><p>我们可以先扫描一遍晚间，看订单金额所处于在金额范围，将订单分到固定个数的桶中</p><blockquote><p>假设我们得到订单金额的范围是<strong>最小是1元到最多是10多万元</strong>，我们根据订单金额将订单分到<strong>100个桶中</strong>去，第一个通我们存储1元~1000之内的定单，第二个桶中存储1001~2000元之内的订单以此类推。</p></blockquote></li><li><p>每个桶对应一个文件（文件有序号），并且按照金额范围大小顺序编号命名(00,01,02…,99).</p><blockquote><p>在理想情况下，如果订单金额从1到10万元之间均匀分布，那么订单会被均匀划分到100个文件中，每个小文件中存储大约100MB的订单数据，我们就可以将100个小文件依次存放到内存中用快排来进行排序，等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个文件中的订单数据，并将其写入一个大文件中，那么这个文件中存储的就是按照金额从小到达的订单数据了</p></blockquote></li></ol><h3 id="问题：订单金额很有可能并不是均匀分布在1-10万元的内"><a href="#问题：订单金额很有可能并不是均匀分布在1-10万元的内" class="headerlink" title="问题：订单金额很有可能并不是均匀分布在1~10万元的内"></a>问题：订单金额很有可能并不是均匀分布在1~10万元的内</h3><p><strong>递归式划分大文件，直到所有文件都可以被读取到内存中进行快排。</strong></p><p>所以10G订单数据是无法均匀地被划分到100个文件中的。有可能某个金额区间的数据特别多，划分之后对用的文件就会很大，没法一次性读取到内存中。</p><p>此时我们需要针对比较大的文件，继续对其进行划分，比如，订单金额咋子1元到1000元之间的比较多，我们就将这个区间继续划分你为10个区间，1元到100元，101到200元…</p><p>假如谋个区间内订单还是太多了，无法一次性读入到内存中，我们就继续划分，直到所有文件都能读入到内存中进行快排。</p><h1 id="计数排序-Counting-Sort-desktop-computer"><a href="#计数排序-Counting-Sort-desktop-computer" class="headerlink" title="计数排序(Counting Sort):desktop_computer:"></a>计数排序(Counting Sort):desktop_computer:</h1><h2 id="适用场景-sunny"><a href="#适用场景-sunny" class="headerlink" title="适用场景:sunny:"></a>适用场景:sunny:</h2><p>计数排序是桶排的一种特殊情况。<strong><em>当要排序的n个数据，所处的范围并不大的时候</em>，比如最大值是k,此时我们就可以把数据划分成k个桶，每个桶内的数据值都是相同的，省略到了桶内排序的时间。</strong> </p><h2 id="高考考生50万排名问题："><a href="#高考考生50万排名问题：" class="headerlink" title="高考考生50万排名问题："></a>高考考生50万排名问题：</h2><p>高考总成绩是900分，最小是0分，这个数据的范围很小，所以我们可以分成901个桶，桶中存储的是对哟个分数的人数。桶内考生的分数相同所以的并不需要再进行排序。我们只需要依次扫描完每个桶，将桶内的考生依次输出到一个数组中，就实现了50万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是O(n)。</p><h2 id="如何实现计数排序？"><a href="#如何实现计数排序？" class="headerlink" title="如何实现计数排序？"></a>如何实现计数排序？</h2><p>我们要实现稳定的计数排序不能单从某个数据对应个数进行对数据的分组。因为那样不能保证相等数据排序前后的相对前后位置不变，所以我们需要两个辅助数组。</p><h3 id="辅助数组C-的创建"><a href="#辅助数组C-的创建" class="headerlink" title="辅助数组C[]的创建"></a>辅助数组C[]的创建</h3><p>一个辅助数组下标表示的是分数，数组内容是小于等于当前下标（分数）的数据个数。</p><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\计数排序辅助数组C.jpg" alt="计数排序辅助数组C"></p><ul><li>排序细节</li></ul><p>我们从后到前依次扫描数组A，为什么从后向前是因为保证计数排序的稳定性。比如我们从后扫描遇到3时，我们可以从数组C中取出下标为3的值7，也就时说，到目前为止，包括这个3在内，分数小于等于3的考生有7个，也就是说3时数组R（排好序的数组）的第7个元素（也就是数组R中下标为6的为止）。当3放入到数组R中后，小于等于3的元素就只剩下了6个，所以相应的C[3]中存储的数值要减1，变成6。</p><p>依次类推，当我们扫描到第2个分数为3的考生的时候，就会把它放入数组R中的第6个元素的位置（也就是排序数组下标为5的位置）。当我们扫描完整个数组A后，数组R内的数据就是按照分数从小到大的有序排列了。</p><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\计数排序细节.jpg" alt="计数排序细节"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计数排序，a是数组，n是数组的大小。假设数组存储的都是非负整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSorot</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//查找数组中数据的范围</span></span><br><span class="line">    <span class="keyword">int</span> max = a[o];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; a[i])&#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.创建辅助数组C[]</span></span><br><span class="line">    <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];<span class="comment">//申请一个计数数组，下标大小[0,max]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; i++)&#123;</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算每个元素的个数，放入C中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        c[a[i]]++;     <span class="comment">//拆解 c[下标为分数] 分数=a[i]  c[下标]：分数为下标数的个数++</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//依次累加  得到辅助数组C[]中存储的是小于等于该数的数据个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; i++)&#123;</span><br><span class="line">        c[i] = c[i-<span class="number">1</span>]+c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.排序数组的创建，排序之后的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">//计算排序的关键步骤！！！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n- <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;  <span class="comment">//该分数对应放在排序数组的下标位置</span></span><br><span class="line">        r[index] = a[i];</span><br><span class="line">        c[a[i]]--;<span class="comment">//小于等于该分数的数据个数-1；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将结果拷贝给a数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>； i &lt; n; i++)&#123;</span><br><span class="line">        a[i] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序详解"><a href="#计数排序详解" class="headerlink" title="计数排序详解"></a>计数排序详解</h2><p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不使用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong> </p><p>关于将数据转化为能使用计数排序的方法如下：</p><ol><li>如果是分数就将分数化为整数。*10的倍数</li><li>如果是负数就将分数化为整数。+整数</li></ol><h1 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h1><p>假设我们要对10万个手机号码进行排序，希望将这10万个手机号码从小到大进行排序？</p><h2 id="对10万个手机号码进行排序"><a href="#对10万个手机号码进行排序" class="headerlink" title="对10万个手机号码进行排序"></a>对10万个手机号码进行排序</h2><p>问题主要特点：</p><ul><li>手机号有11位，假如当作整数来处理范围太大了。我们不能使用桶排，或者计数排序。</li><li>假设我们要比较两个手机号码的a,b的大小，如果在前面几位中，a手机号码已将比b手机号大了，那么后面的几位就不用看了。</li></ul><p>借助稳定排序算法，借助[11]节中举的订单金额时间排序例子，先按照最后一位来排序手机号，然后，再按照倒数地二位重新排序，以此类推，最后按照第一位重新排序。经过11次排序之后，手机号码就有序了。</p><p><img src="/2019/03/02/排序(下)/婕\数据结构与算法之美\picture\基数排序.jpg" alt="基数排序"></p><p>我们每次进行的排序必须是稳定的，这样才不会影响后续位数的排列。</p><p>根据每一位来进行排序，我们可以用到桶排或者计数排序，他们时间复杂度是O(n)。如果要排序的数据位数有k位，那么我们就需要K次桶排序或者计数排序，总时间复杂度就是O(k*n)。当K不大时，比如手机号码的例子，k最大就是11.所以基数排序的时间复杂度就近似与O(n)。</p><h2 id="特殊例子：对字典中20万单词进行排序"><a href="#特殊例子：对字典中20万单词进行排序" class="headerlink" title="特殊例子：对字典中20万单词进行排序"></a><strong>特殊例子</strong>：对字典中20万单词进行排序</h2><ul><li>我们可以把所有单词补齐到相同长度，位数不够的可以在后面补”0”，</li><li>因为根据ASCII值，所有字母大于”0”,所以补”0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</li></ul><h2 id="适用场景-cat2"><a href="#适用场景-cat2" class="headerlink" title="适用场景:cat2:"></a>适用场景:cat2:</h2><p>基数排序对排序数据又要求<strong>，</strong></p><ul><li><strong>需要分隔出独立的”位”来进行比较，而且位之间有递进的关系</strong>，</li><li><em>如果a数据的高位比b数据大，那剩下的低位就不用比较了</em>。</li><li>除此之外<em>，每一位的数据范围不能太大了</em>，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。</li></ul><h1 id="解答-key"><a href="#解答-key" class="headerlink" title="解答:key:"></a>解答:key:</h1><p>给根据年龄100万用户排序</p><p>类似给50万考生排序，先找到数据的范围,例如最小1岁最大120岁。我们可以遍历100万用户，根据年龄将其划分到这120个桶里，然后依次顺序遍历这个120个桶中的元素。这样就可以得到按照年龄排序100万用户的数据了。</p><h1 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h1><p>桶排序，计数排序，基数排序3种排序对要排序的数据都有比较严苛的要求，应用的不是非常广泛。但是如果数据符合这些排序算法的要求，应用这些算法，会非常高效，线性时间复杂度可以达到O(n)。</p><p><strong>桶排序和计数排序的排序思想非常相似的，都是针对范围不大的数据，将数据划分为不同的桶来实现排序。</strong></p><p>基数排序要求数据可以划分成<strong>高低位</strong>，<strong>位于位之间有递进关系</strong>。比较两个数，我们只需要比较高位，高位相同的再比较低位。且<strong>每一位得到数据范围不能太大</strong>，因为基数排序算法<strong>需要借助桶排序或者计数排序来完成每一位的排序工作。</strong></p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p><strong>对大小写字母进行排序，要求大写在前，小写在后。大小写字母内部不要求有序。</strong></p><p>==双指针法（前后指针)==  </p><blockquote><p>前指针从前向后找找到大写字母，后指针从后向前找找到小写字母。然后进行交换，直到两个指针相遇就停止，完成排序。</p></blockquote><p><strong>进阶其中在添加数字，要求数字在中间。</strong></p><p>==分类，两次双指针（前后指针）==</p><blockquote><p>先将数据非为小写字母和非小写字母进行排序，然后再对非小写字母进行数字和大写字母的双指针算法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;13-排序-下-线性排序-strawberry&quot;&gt;&lt;a href=&quot;#13-排序-下-线性排序-strawberry&quot; class=&quot;headerlink&quot; title=&quot;[13]排序(下)-线性排序:strawberry:&quot;&gt;&lt;/a&gt;[13]排序(下)-线性排序:strawberry:&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;非基于比较的 线性排序&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;适用场合&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;桶排序&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数据量大，数据存储在磁盘上，内存有限（数据范围不大）&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计数排序&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;计数排序只能用在数据范围不大的场景中&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基数排序&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数据可以划分高低位，且每一位之间后递进关系，每一位范围不能大，因为每一位的稳定排序依赖桶排或者计数排序&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="排序" scheme="https://soyanga.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序(中)</title>
    <link href="https://soyanga.github.io/2019/03/02/%E6%8E%92%E5%BA%8F(%E4%B8%AD)/"/>
    <id>https://soyanga.github.io/2019/03/02/排序(中)/</id>
    <published>2019-03-02T15:54:52.000Z</published>
    <updated>2019-03-17T08:55:30.627Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="12-排序-中-数据结构与算法之美-arrow-down-small"><a href="#12-排序-中-数据结构与算法之美-arrow-down-small" class="headerlink" title="[12]排序(中) -数据结构与算法之美:arrow_down_small:"></a>[12]排序(中) -数据结构与算法之美:arrow_down_small:</h1><table><thead><tr><th style="text-align:left">排序算法</th><th>时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">归并</td><td>O(nlogn)</td></tr><tr><td style="text-align:left">快排</td><td>O(nlogn)</td></tr></tbody></table><p><strong>快排，归并排序</strong>：大规模的数据排序，比冒泡，插入，选择更加常用。—分治思想</p><a id="more"></a><h1 id="带着问题-grey-question"><a href="#带着问题-grey-question" class="headerlink" title="带着问题:grey_question:"></a>带着问题:grey_question:</h1><p>如何在O(n)的时间复杂度内查找一个无序数组中的第K大元素？</p><h2 id="归并排序-Merge-Sort-dog2"><a href="#归并排序-Merge-Sort-dog2" class="headerlink" title="归并排序(Merge Sort):dog2:"></a>归并排序(Merge Sort):dog2:</h2><p>归并排序核心思想：</p><ul><li>先把数组从中间<strong>分成前后两部分</strong></li><li>然后对前后两部分，<strong>分别排序</strong> </li><li>再将排好的两个部分<strong>合并</strong>在一起。</li></ul><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\归并排序算法图.png" alt="归并排序算法图"></p><p>利用的是<strong>分治思想</strong> ，大问题分解为小的子问题来解决。小的解决了，大的问题也就解决了。</p><p>分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong></p><ul><li><p><strong>递归实现拆分目标数组</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">mergr_sort(p...r) = merge(merge_sort(p..q),merge_sort(q_1...r))</span><br><span class="line">按照目标数组的中间节点差分整个数组，进行分别排序</span><br><span class="line"></span><br><span class="line">终止条件</span><br><span class="line">p &gt;= r 不用再继续分解   即拆解成的目标数组只剩一个元素</span><br></pre></td></tr></table></figure></li><li><p><strong>合并拆分并完成排序的数组—类似合并两个有序数组</strong> (<em>利用哨兵简化代码)</em></p><ul><li>开辟一个和合并完成后数组一样大的数组 —临时数组</li><li>比较有序数组首元素的大小，谁小就放到临时数组中，依次比较放入，直到其中有一个数组已经没有元素可以比较</li><li>然后将有元素的数组直接放到到临时数组后面</li><li>最后将临是数组中的元素考回需要合并的数组中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin1, <span class="keyword">int</span> end1, <span class="keyword">int</span> begin2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">//临时数组的其实位置</span></span><br><span class="line">    <span class="keyword">int</span> begin = begin1;  <span class="comment">//记住数组起始位置</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end2 - begin1 + <span class="number">1</span>]; <span class="comment">//开辟和合并后数组大小一样大的数组</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//以下操作类似合并两个有序数组</span></span><br><span class="line">    <span class="comment">//谁小就将谁放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt; a[begin2]) &#123;</span><br><span class="line">            temp[start++] = a[begin1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[start++] = a[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数组直接拷贝回临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">        temp[start++] = a[begin1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">        temp[start++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp数组中的元素拷贝回合并后的数组中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        a[begin + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>归并排序的整体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin1, <span class="keyword">int</span> end1, <span class="keyword">int</span> begin2, <span class="keyword">int</span> end2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>; <span class="comment">//临时数组的其实位置</span></span><br><span class="line">    <span class="keyword">int</span> begin = begin1;  <span class="comment">//记住数组起始位置</span></span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end2 - begin1 + <span class="number">1</span>]; <span class="comment">//开辟和合并后数组大小一样大的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下操作类似合并两个有序数组</span></span><br><span class="line">    <span class="comment">//谁小就将谁放入临时数组中</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[begin1] &lt; a[begin2]) &#123;</span><br><span class="line">            temp[start++] = a[begin1++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[start++] = a[begin2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数组直接拷贝回临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) &#123;</span><br><span class="line">        temp[start++] = a[begin1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) &#123;</span><br><span class="line">        temp[start++] = a[begin2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp数组中的元素拷贝回合并后的数组中。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        a[begin + i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序性能分析："><a href="#归并排序性能分析：" class="headerlink" title="归并排序性能分析："></a>归并排序性能分析：</h3><h4 id="归并排序是一个稳定排序"><a href="#归并排序是一个稳定排序" class="headerlink" title="归并排序是一个稳定排序"></a>归并排序是一个稳定排序</h4><p>归并排序是一个稳定排序，<strong>稳定与否关键是在看merge()函数</strong>，也就是有两个有序子数组合并成一个有序数组那部分 。合并过程中，<em>把差分后要合并的两个数组中值相等的元素，先将拆分前下标靠前的元素先放入合并用的temp数组内即可</em>。这样就保证了值相同的元素。在合并前后的先后顺序不变，所以，<strong>归并排序是一个稳定的排序算法</strong>。                    </p><h4 id="归并排序的时间复杂度"><a href="#归并排序的时间复杂度" class="headerlink" title="归并排序的时间复杂度"></a>归并排序的时间复杂度</h4><p>我们可以从分治思想中的到启发，求解大问题，解决子问题即可。则我们定义求解问题时间是T(a),求解问题b、c的时间分别是T(b)和T(c)，那么我们就可以得到如下的递推关系</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T(a) = T(b)+T(c)+k</span><br></pre></td></tr></table></figure><p>其中K等于将两个子问题b,c的结果合并成问题a的解果所消耗的时间。</p><p><strong>不仅递归求解问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong> </p><p>现在我们来求解归并排序的时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并两个有序子数组的时间复杂度是O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</span></span><br><span class="line">T(<span class="number">1</span>) = c ;n=<span class="number">1</span>时，即数组只剩下一个元素，只需要常量级的执行时间，所以表示为c。</span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n;  n&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>分解计算过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n</span><br><span class="line"> = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>)+n/<span class="number">2</span>) +n        = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n</span><br><span class="line">     = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n   = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n</span><br><span class="line">     = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n  = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n</span><br><span class="line">     ......</span><br><span class="line">     = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure><p>我们可以得出T(n) = 2^kT(n/2^k)+kn,当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并并排序的时间复杂度是 O(nlogn)。</p><p>归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的。</p><table><thead><tr><th>时间复杂度</th><th>大O标记法</th></tr></thead><tbody><tr><td>最好时间复杂度</td><td>O(nlogn)</td></tr><tr><td>平均时间复杂度</td><td>O(nlogn)</td></tr><tr><td>最坏时间复杂度</td><td>O(nlogn)</td></tr></tbody></table><h4 id="归并排序的空间复杂度"><a href="#归并排序的空间复杂度" class="headerlink" title="归并排序的空间复杂度"></a>归并排序的空间复杂度</h4><p><strong>归并排序是一个非原地排序！</strong>这是因为归并排序的合并函数。在合并两个有序数组为一个有序数组时，需要借助额外的储存空间。<strong>O（n）</strong></p><p>递归代码的空间复杂不能像时间复杂度那样累加。尽管每次合并操作都需要申请额外的内存空间，但是在合并完成后，临时开辟的内存空间被释放掉了，<strong>在任意时刻，CPU只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过n个数据的大小，所以空间复杂度是O(n).</strong></p><h2 id="快速排序-QuickSort-arrow-heading-up"><a href="#快速排序-QuickSort-arrow-heading-up" class="headerlink" title="快速排序(QuickSort):arrow_heading_up:"></a>快速排序(QuickSort):arrow_heading_up:</h2><p>快排核心思想：</p><ul><li>先从区间数组中选择一个数据作为分区点</li><li>遍历区间数组中的元素，将小于分区点的元素放在分区点左边，大于分区点的元素放在分区点右边。经过这一个步骤后，数组就被发分为了3部分，左边 p 到 q-1 之间都是小于 pivot的 ，中间 pivot，后面q+1到r之间是大于 pivot 的（排序并分区）</li><li>根据分治，递归的处理思想，我们可以用递归排序下标从p到q-1之间的数据和小标从q+1到r之间的数据，直到区间缩小为1，就说明所有的数据都有序了。</li></ul><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\快排分区.png" alt="快排分区"></p><p>递归过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-<span class="number">1</span>) + quick_sort(q+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure><p>递归公式-&gt;递归代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快排递归函数，begin,end为下标 div为分区节点，下一次分区就不包含此分区节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> div = partition(a, begin, end);</span><br><span class="line">    quickSortInternally(a, begin, div - <span class="number">1</span>);</span><br><span class="line">    quickSortInternally(a, div + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序中有一个merge()合并方法，我们这里有一个partition()分区函数。对数组进行顺序调整且对数组进行进一步分区处理,代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[end];</span><br><span class="line">    <span class="keyword">int</span> i = begin;      <span class="comment">//i当作“已排好序节点”</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[j] &lt; pivot) &#123; <span class="comment">//比分区节点小的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;   <span class="comment">//有序性区无元素，或者已经有序</span></span><br><span class="line">                ++i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap(a, i, j); <span class="comment">//将无序区的元素交换到有序区后面，有序区+1，无序区-1</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, i, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理有点类似选择排序。[p-r-1]我们通过下标 i把区间分为两个部分，[p-i]都小于pivot 我们将它取名为”已处理区间”。[i~r-1]都是”未处理区间“。我们每次都从未处理区间中取出一个元素A[j]，与pivot比较，如果小于pivot，则将加入到已处理区间的尾部，也就是A[i]位置，j++,i++。反之则只有j++。</p><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\快排分区排序原理图.png" alt="快排分区排序原理图"></p><p>因为分区过程涉及交换操作，交换过程中只对比大小，无法保证相同元素的先后顺序。所以快速🥧排序是一个不稳定算法。</p><h3 id="快排性能分析"><a href="#快排性能分析" class="headerlink" title="快排性能分析"></a>快排性能分析</h3><h4 id="快排稳定性"><a href="#快排稳定性" class="headerlink" title="快排稳定性"></a>快排稳定性</h4><p>快拍是一个不稳定算法</p><h4 id="快排的空间复杂度"><a href="#快排的空间复杂度" class="headerlink" title="快排的空间复杂度"></a>快排的空间复杂度</h4><p>快排是一个原地排序，在原数组内进行简单交换。</p><h4 id="快排时间复杂度"><a href="#快排时间复杂度" class="headerlink" title="快排时间复杂度"></a>快排时间复杂度</h4><p>快排也是使用递归实现的分治思想，对于递归代码的时间复杂度，我们之前总结的公式在这里依旧适用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(<span class="number">1</span>) = C；   n=<span class="number">1</span> 时，只需要常量级的执行时间，所以表示为 C。</span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n； n&gt;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>但是归并排序是从中间开始划分区间，而快排划分区间的是利用选取一个值，假如选取的值是目标数组中最大元素，或者最小元素。则会导致每次划分的区间言严重不均等。假如每次划分区间都取到了这种极端值，则我们要进行大约n次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约n/2个元素。这种情况下，快排的时间复杂度就从O(nlogn)退化成了O(n^2)。</p><p>利用递归树对快排的时间复杂度进行分析</p><p>在大部分情况下时间复杂度都是O(nlogn)，只有在极端情况下，才会退化到 O(n2)。</p><table><thead><tr><th>时间复杂度</th><th>对应的原始数组</th></tr></thead><tbody><tr><td>最好时间复杂度O(nlogn)</td><td>每次挑选的分区值都是大小最中间的那个值</td></tr><tr><td>平均时间复杂度O(nlogn)</td><td></td></tr><tr><td>最坏时间复杂度O(n^2)</td><td>每次挑选的分区值都是极端值-最大或最小值</td></tr></tbody></table><p>合理选择区间值可以避免出现最坏情况。</p><h1 id="解答开始问题-key"><a href="#解答开始问题-key" class="headerlink" title="解答开始问题:key:"></a>解答开始问题:key:</h1><p>快排的核心思想就是<strong>分治</strong>和<strong>分区</strong>.我们可以利用分区的思想；来解答开始的问题：O(n)时间复杂度内来求无序数组中的第K大元素。比如，4,2,5,12,3这样一组数据，第3大元素就是4。</p><p>我们区间选择完后就分为3部分。</p><p>如果p+1=k，那么A[p]就是要求解的元素，如果k&gt;p+1,说明第K大元素出现A[p+1…n-1]区间，我们再按照递归思路在A[p+1…n-1]这个区间内进行查找。同理，如果k&lt;p+1,那我们就在A[0…p-1]区间查找。</p><p><img src="/2019/03/02/排序(中)/婕\数据结构与算法之美\picture\O(n" alt="O(n)求解第K大元素">求解第K大元素.png)</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>第一次分区查找，我们需要对大小为n的数组执行分区操作，需要遍历n个元素。第二次分区查找，我们只需要对n/2的数组执行分区操作，需要遍历n/2个元素。依次类推，分区遍历元素的个数为，n/2,n/4,n/8,n/16……直到区间缩小为1。</p><p>如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于2n-1。所以，上述的解题思路的时间复杂度就是O(n)。</p><h1 id="思考：-thinking"><a href="#思考：-thinking" class="headerlink" title="思考：:thinking:"></a>思考：:thinking:</h1><p>现在你有 10 个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？</p><h2 id="快排的优化"><a href="#快排的优化" class="headerlink" title="快排的优化"></a>快排的优化</h2><ul><li><p>分组不平衡–导致快排递归深度增加</p><ul><li><p>排序接近有序（基准值划分的两个子数组严重不均衡，此分层下来的结果近乎于n层，此时快排退化为复杂度为O(n^2）排序算法</p><blockquote><p>解决：随机数/三数取中法，让这种出现极端值情况降低</p></blockquote></li><li><p>当待排序集合包含大量的重复元素，由于与基准值相等的元素个数过多，导致数组长度不均衡，此时分层下来的结果几乎n层，快排退化为O(n^2)。  </p><blockquote><p>解决：二路快排    基准值-v    将待排序数组分为2部分  大于或或者小于</p><p>​    将大于和小于v的元素放在数组的两端,i索引不断向后扫描，当i的元素小于v时，i++;j索引不断向前扫描，当j的元素大于v时，j–;当i碰到一个&gt;=v的元素时以及当j碰到一个&lt;=v的元素时，交换i和j的元素，i++,j— 。  </p><p>即保证等于基准值的重复元素被均分到两边 一定程度上使得分组平均，递归深度降低</p></blockquote></li></ul></li></ul><p>  ​    二路快排图解</p><p>  <img src="/2019/03/02/排序(中)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552803918895.png" alt="1552803918895"></p><p>  ​    保证等于基准值的重复元素被均分到两边 一定程度上使得分组平均，递归深度降低</p><p>  <img src="/2019/03/02/排序(中)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552811349512.png" alt="1552811349512"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决：数据重复的快排---二路归并快排</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a     数组a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  左下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 基准值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>) ((Math.random() * (right - left + <span class="number">1</span>)) + left);</span><br><span class="line">    swap(a, right, randomIndex);</span><br><span class="line">    <span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">int</span> v = a[right];</span><br><span class="line">    <span class="comment">//a[left,i-1]   &lt; v</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="comment">//a[j+1,right] &gt;v</span></span><br><span class="line">    <span class="keyword">int</span> j = right - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//双指针前指针向后扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right &amp;&amp; a[i] &lt; v) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left &amp;&amp; a[j] &gt; v) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, i, right);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>二路快排优化- - - - -三路快排  &lt;  =  &gt;</strong></p></li><li><p><strong>三路快排图解</strong></p><p><img src="/2019/03/02/排序(中)/Users\32183\AppData\Roaming\Typora\typora-user-images\1552804075550.png" alt="1552804075550"></p><p>将大量等于基准值的部分取出来，放到排序数组的中间，下一次进行排序时只需要排序不等于基准值的区域即可</p><p>大大减少排序次数，减少树的深度，又保持了数组的平衡。</p><p><strong>代码实现：</strong></p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//*********************快排优化之中级重复数据优化--三路快排</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortOP3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">&gt;  quickSortInternallyOP3(a, begin, end);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortInternallyOP3</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">&gt;  <span class="keyword">if</span> (end - begin &lt; <span class="number">15</span>) &#123;   <span class="comment">//少量数据使用插排</span></span><br><span class="line">&gt;      insertSort(a, begin, end);</span><br><span class="line">&gt;      <span class="keyword">return</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  <span class="keyword">int</span>[] divs = partition3(a, begin, end);</span><br><span class="line">&gt;  <span class="keyword">int</span> div1 = divs[<span class="number">0</span>];</span><br><span class="line">&gt;  <span class="keyword">int</span> div2 = divs[<span class="number">1</span>];</span><br><span class="line">&gt;  quickSortInternallyOP3(a, begin, div1 - <span class="number">1</span>);</span><br><span class="line">&gt;  quickSortInternallyOP3(a, div2 + <span class="number">1</span>, end);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition3(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right) &#123;</span><br><span class="line">&gt;  <span class="keyword">int</span> randomIndex = (<span class="keyword">int</span>) (Math.random() * (right - left + <span class="number">1</span>) + left);</span><br><span class="line">&gt;  swap(a, randomIndex, left);</span><br><span class="line">&gt;  <span class="keyword">int</span> v = a[left];</span><br><span class="line">&gt;  <span class="keyword">int</span>[] divs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">&gt;  <span class="comment">//a[left+1....lt] &lt; v</span></span><br><span class="line">&gt;  <span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">&gt;  <span class="keyword">int</span> lt = left;</span><br><span class="line">&gt;  <span class="comment">//a[gt...right]  &lt; v</span></span><br><span class="line">&gt;  <span class="keyword">int</span> gt = right + <span class="number">1</span>;   <span class="comment">// &lt; v的区间</span></span><br><span class="line">&gt;  <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">&gt;      <span class="keyword">if</span> (a[i] &lt; v) &#123;</span><br><span class="line">&gt;          swap(a, lt + <span class="number">1</span>, i);</span><br><span class="line">&gt;          lt++;</span><br><span class="line">&gt;          i++;</span><br><span class="line">&gt;      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; v) &#123;</span><br><span class="line">&gt;          swap(a, gt - <span class="number">1</span>, i);</span><br><span class="line">&gt;          gt--;</span><br><span class="line">&gt;      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&gt;          i++;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  swap(a, left, lt);</span><br><span class="line">&gt;  divs[<span class="number">0</span>] = lt;</span><br><span class="line">&gt;  divs[<span class="number">1</span>] = gt;</span><br><span class="line">&gt;  <span class="keyword">return</span> divs;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote></li></ul><ul><li><p>影响快排的性能的另一个原因是快排的递归深度，当元素递归区间内的元素数目不大时，利用快排排序则会增加递归深度，增加排序的时间复杂度，何不选用一种处理少量数据比较快速的排序算法–––-插排</p><blockquote><p>当递归区间比较小时，直接引入插排进行排序，减少递归深度</p></blockquote></li></ul><p>​    <strong>快排优化插排</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((end - begin + <span class="number">1</span>) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = a[i];  <span class="comment">//要插入适当位置的值</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>; <span class="comment">//有序区</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">                a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j + <span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;12-排序-中-数据结构与算法之美-arrow-down-small&quot;&gt;&lt;a href=&quot;#12-排序-中-数据结构与算法之美-arrow-down-small&quot; class=&quot;headerlink&quot; title=&quot;[12]排序(中) -数据结构与算法之美:arrow_down_small:&quot;&gt;&lt;/a&gt;[12]排序(中) -数据结构与算法之美:arrow_down_small:&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;排序算法&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;归并&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;快排&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;快排，归并排序&lt;/strong&gt;：大规模的数据排序，比冒泡，插入，选择更加常用。—分治思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="排序" scheme="https://soyanga.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>排序(上)</title>
    <link href="https://soyanga.github.io/2019/02/27/%E6%8E%92%E5%BA%8F(%E4%B8%8A)/"/>
    <id>https://soyanga.github.io/2019/02/27/排序(上)/</id>
    <published>2019-02-27T14:42:18.000Z</published>
    <updated>2019-02-27T14:44:54.124Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="排序章节学习总规划"><a href="#排序章节学习总规划" class="headerlink" title="排序章节学习总规划"></a>排序章节学习总规划</h1><table><thead><tr><th>章节</th><th>排序算法</th><th>时间复杂度</th><th>是否基于比较</th></tr></thead><tbody><tr><td>11</td><td>冒泡，插入，选择</td><td>O(n^2)</td><td>:heavy_check_mark:</td></tr><tr><td>12</td><td>快排，归并</td><td>O(nlogn)</td><td>:heavy_check_mark:</td></tr><tr><td>13</td><td>桶，计数，基数</td><td>O(n)</td><td>:heavy_multiplication_x:</td></tr></tbody></table><a id="more"></a><h1 id="带着问题​-grey-question"><a href="#带着问题​-grey-question" class="headerlink" title="带着问题​ :grey_question:"></a>带着问题​ :grey_question:</h1><p>插排和冒泡排序时间复杂度都是O(n^2)，在实际开发中，为什么更倾向于使用插入排序算法而不是冒泡排序算法？</p><h1 id="11-排序-上-数据结构算法之美-happy"><a href="#11-排序-上-数据结构算法之美-happy" class="headerlink" title="[11] 排序(上) -数据结构算法之美 :happy:"></a>[11] 排序(上) -数据结构算法之美 :happy:</h1><h2 id="分析排序算法的三个方面-thumbsup"><a href="#分析排序算法的三个方面-thumbsup" class="headerlink" title="分析排序算法的三个方面 :thumbsup:"></a>分析排序算法的三个方面 :thumbsup:</h2><h3 id="排序算法的执行效率-1-one"><a href="#排序算法的执行效率-1-one" class="headerlink" title="排序算法的执行效率-1:one:"></a>排序算法的执行效率-1:one:</h3><h4 id="1-最好情况，最坏情况，平均时间复杂度"><a href="#1-最好情况，最坏情况，平均时间复杂度" class="headerlink" title="1.最好情况，最坏情况，平均时间复杂度"></a>1.最好情况，最坏情况，平均时间复杂度</h4><p>我们分析排序算法的时间复杂度的同时也要分析==<strong>最好，最坏时间复杂度对应的要排序的原始数据</strong>==  是什么样的。<strong>（数据已经有序，数据接近有序，数据完全无序，数据逆序）</strong></p><h4 id="2-时间复杂度的系数，常数，低阶"><a href="#2-时间复杂度的系数，常数，低阶" class="headerlink" title="2.时间复杂度的系数，常数，低阶"></a>2.时间复杂度的系数，常数，低阶</h4><p>时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势往往会忽略系数，常数，低阶项。但是实际开发中可能排序数据规模上不一定会规模很大。所以对于同一阶次时间复杂度算法性能对比的时候，我们就要把系数，常数，低阶考虑进来。</p><h4 id="3-比较次数-和-交换-或移动-次数"><a href="#3-比较次数-和-交换-或移动-次数" class="headerlink" title="3.比较次数 和 交换(或移动)次数"></a>3.比较次数 和 交换(或移动)次数</h4><p>基于比较的排序算法，会涉及两种操作，一种是元素比较大小，另一种是元素交换或者移动。所以，我们分析排序算法执行效率的时候，应该把比较次数和交换（或者移动）次数也考虑进去。</p><h3 id="排序算法的内存消耗-2-two"><a href="#排序算法的内存消耗-2-two" class="headerlink" title="排序算法的内存消耗-2:two:"></a>排序算法的内存消耗-2:two:</h3><p>算法的内存消耗：可以通过空间复杂度来衡量。</p><p>针对排序算法的空间复杂度，我们还引入一个新概念，<strong>原地排序（Sorted in place）</strong>:特指空间复杂度是O(1)的排序算法。</p><p><strong>冒泡，插排，选择排序都是原地排序</strong>。</p><h3 id="排序算法的稳定性-3-three"><a href="#排序算法的稳定性-3-three" class="headerlink" title="排序算法的稳定性-3:three:"></a>排序算法的稳定性-3:three:</h3><p>==<strong>稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</strong>==</p><p><strong>例1： </strong> </p><p>一组数据 2，9，3，4，8，3按照升序排列，则排完是2，3，3，4，8，9。排序后两个3的先后次序不变。</p><p><strong>例2：</strong> </p><p>交易订单中”订单”排序。订单中有两个属性，一个下单时间，另一个是订单金额。如果说我们现在有10万条订单数据·。我们希望</p><ul><li>按照订单金额从小到大对订单数据进行排序</li><li>对于相同的订单，我们希望按照下单时间从早到晚有序</li></ul><p>对于这样一个排序需求我们应该如何去做呢？</p><p>先对整个<strong>订单数据按照下单时间进行升序排列(可以不是使用稳定排序)</strong>，然后再整体使用<strong>稳定排序算法，按订单金额重新排序</strong>即可。</p><p><strong>分析：</strong> 稳定排序算法可以保持金额相同的对象，在排序之后前后顺序不变。第一次排序之后，所有订单按照下单时间从早到晚就有序了。<strong>第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</strong> </p><h2 id="冒泡排序-Bubble-Sort-right-anger-bubble"><a href="#冒泡排序-Bubble-Sort-right-anger-bubble" class="headerlink" title="冒泡排序(Bubble Sort) :right_anger_bubble:"></a>冒泡排序(Bubble Sort) :right_anger_bubble:</h2><p>冒泡排序只会操作<em>相邻的两个数据</em>。每次冒泡都会对相邻的两个元素进行比较，看是否满足大小关系的要求。如果不满足就让他俩互换。<strong>一次冒泡会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作</strong> </p><p><strong>优化：</strong>当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后面的冒泡操作了。</p><p><strong>优化前：</strong> </p><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\冒泡排序算法图.jpg" alt="冒泡排序算法图"></p><p><strong>优化后：</strong> </p><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\冒泡排序算法图优化.jpg" alt="冒泡排序算法图优化"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[]a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123; <span class="comment">//如果只有元素，不需要排序</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">//提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ;j &lt; n-i-<span class="number">1</span>; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = temp;</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">//表示有数据交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//没有数据交换，提前退出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序算法分析"><a href="#冒泡排序算法分析" class="headerlink" title="冒泡排序算法分析"></a>冒泡排序算法分析</h3><ul><li><p><strong>冒泡排序是原地排序算法</strong></p><p>冒泡排序冒泡过程<strong>只涉及相邻的数据交换操作</strong>，是原地排序算法，只需要常量级临时空间。空间复杂度是O(1)，是一个原地排序算法。</p></li><li><p><strong>冒泡排序是稳定排序算法</strong></p><p>交换时值改变了两个元素的前后顺序。为了保证冒泡排序算法的稳定性<em>，我们在比较时规定当有相邻元素大小相同时，我们不做交换</em>，<strong>相同大小的数据在排序前后不会改变顺序</strong>，所以冒泡排序是稳定的排序算法。</p></li><li><p>冒泡排序时间复杂度。最好，最坏，平均</p><p>| 时间复杂度             | 对应原始数据                     |<br>| ———————- | ——————————– |<br>| 最好时间复杂度：O(n)   | 1,2,3,4,5,6 从头到尾遍历一遍数组 |<br>| 最坏时间复杂度：O(n^2) | 6,5,4,3,2,1                      |<br>| 平均时间复杂度：O(n^2) | 数据的有序度的平均水平           |</p><p>平均时间复杂度运用概率论的方法难以计算，引入一个<strong>有序度</strong>的概念</p></li></ul><p>​    <strong>有序度：</strong> 是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表式就是</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 有序元素对：a[i] &lt;= a[j],如果i&lt;j</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​    <strong>满序度：</strong>完全有序的序列，的有序对数</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 满序度:排序完成后终态有序度为   n*(n-<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​    <strong>逆序度：数组中无序逆序关系得元素对的个数。</strong> </p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 逆序度对：a[i] &gt; a[j],如果i&lt;j</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>​                                                    <strong>逆序度 = 满序度-有序度</strong> </p><p>​    拿之前的那个例子来说，数组初始状态是4，5，6，3，2，1。其中有序对有(4,5)(4,6)(5,6)</p><p>​    所以有序度是3。n=6,所以排序完成之后终态满有序度为n*(n-1)/2=15。</p><p>​    <img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\有序度规律.jpg" alt="有序度规律"></p><p>冒泡排序包含的<strong>两个原子操作，比较</strong>和<strong>交换</strong>。每冒泡（交换）一次，有序度就加1，不管算法怎么改进交换次数总是确定的。即为<strong>逆序度，也就是n*(n-1)/2-初始有序度。</strong>在这个例子中15-3 = 12则要进行12次交换操作。</p><p>对于包含n个数据的冒泡排序平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所所以要进行 n<em>(n-1)/2 次交换。最好情况下，初始状态的有序度是 n</em>(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，<strong>比较操作肯定要比交换操作多，而复杂度的上限是 O(n2)，所以平均情况下的时间复杂度就是 O(n2)。</strong> </p><h2 id="插入排序-Insertion-Sort-diamond-shape-with-a-dot-inside"><a href="#插入排序-Insertion-Sort-diamond-shape-with-a-dot-inside" class="headerlink" title="插入排序(Insertion Sort):diamond_shape_with_a_dot_inside:"></a>插入排序(Insertion Sort):diamond_shape_with_a_dot_inside:</h2><p>将数组中的数据分为两个区间，已<strong>排序区间和未排序区间</strong>。<strong>初始已排序区间只有一个元素，就是数组的第一个元素。</strong>==插入算法的核心思想是<strong>取未排序区间中的元素。在已排序区间中找到合适的插入位置将其插入，并确保已排序区间数据一直有序</strong>。== 重复这个过程，<strong>直到未排序区间中元素为空，则排序就完成了。</strong> </p><p>插入排序也包含<strong>两种操作，元素的比较，元素的移动</strong>。当我们需要将一个数据a插入到已排序区间时，需要拿<strong>a与已排序区间的元素依次比较大小</strong>，<strong>找到合适的插入位置</strong>。找到合适的插入位置后，我们还需要将<strong>插入点之后的元素统一往后移动一位，腾出空间给元素插入</strong>。</p><p>对于不同的查找插入点方法（从头到尾，从尾到头）,元素的<strong>比较次数是有区别的</strong> 。但是对于一个给定的初始序列，<strong>移动操作的次数总是固定的，就等于逆序度</strong>。</p><blockquote><p>初始有序度为5，满序度为n*(n-1)/2=15,逆序度为10，插入排序一定数据总和也等于10 =3+3+4</p></blockquote><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\插排算法图.jpg" alt="插排排序图"></p><p><strong>代码入下：</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> value = a[i]; <span class="comment">//记录要插入的元素</span></span><br><span class="line">        <span class="keyword">int</span> j = i-<span class="number">1</span>; <span class="comment">//已排序区</span></span><br><span class="line">        <span class="comment">//查找插入位置</span></span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span>; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &gt; value)&#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j];<span class="comment">//数据移动</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = value; <span class="comment">//将要插入的位置插入合适的位置，有序区数量+1，无序区数量-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序算法分析"><a href="#插入排序算法分析" class="headerlink" title="插入排序算法分析"></a>插入排序算法分析</h3><ul><li><p><strong>插入排序是原地排序</strong></p><p>不需要额外的空间，空间复杂度O(1)</p></li><li><p><strong>插入排序是稳定排序</strong> </p><p>在插入排序中，对于值相同的元素，我们规定<strong>将后面的出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</strong></p></li><li><p><strong>插入排序的时间复杂度</strong></p><p>| 时间复杂度             | 对应原始数据                          |<br>| ———————- | ————————————- |<br>| 最好时间复杂度：O(n)   | 1,2,3,4,5,6 从头到尾遍历一遍数组      |<br>| 最坏时间复杂度：O(n^2) | 6,5,4,3,2,1                           |<br>| 平均时间复杂度：O(n^2) | 在数组中插入一个数据O(n)，循环执行n次 |</p></li></ul><p>数组中插入一个元素时间复杂度O(n):（1+2+3+4+…n)/n = O(n)</p><h2 id="选择排序-Selection-Sort-aquarius"><a href="#选择排序-Selection-Sort-aquarius" class="headerlink" title="选择排序(Selection Sort):aquarius:"></a>选择排序(Selection Sort):aquarius:</h2><p>选择排序与插排类似，也分为<strong>排序区和未排序区</strong>。但是选择排序每次会==<strong>从未排序区间中找到最小的元素，将其放到已经排好序的末尾。</strong>== </p><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\选择排序算法图.jpg" alt="选择排序算法图"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fot(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> minindex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[minindex])&#123;</span><br><span class="line">                 minindex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[i];</span><br><span class="line">            a[i] = a[minindex];</span><br><span class="line">            a[minindex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序算法分析"><a href="#选择排序算法分析" class="headerlink" title="选择排序算法分析"></a>选择排序算法分析</h3><ul><li><p><strong>选择排序是原地排序</strong></p><p>不需要额外的空间，空间复杂度O(1)</p></li><li><p><strong>选择排序==不== 是一种稳定排序</strong></p><p>从图中可以看出，排序过程中将最小元素和最后一位交换位置，则会导致最后一位元素可能会移动到和它值相同的元素的前面，波坏了稳定性</p></li><li><p><strong>选择排序时间复杂度</strong></p><p>| 时间复杂度             | 对应原始数据                                   |<br>| ———————- | ———————————————- |<br>| 最好时间复杂度：O(n^2) | 无论原始数据如何，时间复杂度都是O(n^2)         |<br>| 最坏时间复杂度：O(n^2) | 原因是：查找无序区间的最小值总得遍历一遍无序区 |<br>| 平均时间复杂度：O(n^2) |                                                |</p></li></ul><p>逊色冒泡，插入排序。</p><h1 id="解答开始的问题-key"><a href="#解答开始的问题-key" class="headerlink" title="解答开始的问题:key:"></a>解答开始的问题:key:</h1><p>我们来看开篇的问题：插排和冒泡排序时间复杂度都是O(n^2)，在实际开发中，为什么更倾向于使用插入排序算法而不是冒泡排序算法？</p><p><strong>我们分析了冒泡排序和插入排序，不管如何优化，元素交换次数是一个都定值，即原始数据的无序度</strong></p><p>但是从代码实现上来看，==<strong>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序有要3个赋值操作，而插入排序只需要1个赋值操作。</strong>==</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>我们把执行一个赋值语句的时间粗略记为单位时间（unit_time）,然后分别用冒泡排序和插入排序对同一个逆序度为k的数组进行排序，需要进行k次交换操作。冒泡排序，每次需要进行3条赋值语句，所以交换操作总耗时就是==3*k== 单位时间，而插入排序中数据移动操作只需要==k== 个单位时间。</strong></p><p>虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n^2),但是我们希望把性能优化到极致，所以我们首选插入排序。插入排序还可以进行进一步优化。比如==<strong>希尔排序</strong>== </p><h1 id="小结-package"><a href="#小结-package" class="headerlink" title="小结:package:"></a>小结:package:</h1><p><img src="/2019/02/27/排序(上)/婕\数据结构与算法之美\picture\小结.jpg" alt="小结"></p>]]></content>
    
    <summary type="html">
    
      &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&gt;

&lt;h1 id=&quot;排序章节学习总规划&quot;&gt;&lt;a href=&quot;#排序章节学习总规划&quot; class=&quot;headerlink&quot; title=&quot;排序章节学习总规划&quot;&gt;&lt;/a&gt;排序章节学习总规划&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;章节&lt;/th&gt;
&lt;th&gt;排序算法&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;是否基于比较&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;冒泡，插入，选择&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;:heavy_check_mark:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;快排，归并&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;:heavy_check_mark:&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;桶，计数，基数&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;:heavy_multiplication_x:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
      <category term="数据结构与算法之美" scheme="https://soyanga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
      <category term="排序" scheme="https://soyanga.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SOYANGA</title>
  
  <subtitle>Hello World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://soyanga.github.io/"/>
  <updated>2019-01-05T14:47:19.416Z</updated>
  <id>https://soyanga.github.io/</id>
  
  <author>
    <name>SOYANGA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>11-事务管理</title>
    <link href="https://soyanga.github.io/2019/01/05/11-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://soyanga.github.io/2019/01/05/11-事务管理/</id>
    <published>2019-01-05T10:20:11.000Z</published>
    <updated>2019-01-05T14:47:19.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="11-事务管理"><a href="#11-事务管理" class="headerlink" title="11-事务管理"></a>11-事务管理</h1><p>事务就是一组DML语句组成，这些语句在逻辑上存在着相关性，这一组DML语句要么成功，要么全部失败，是一个整体。MySQL提供一种机制，保证我们达到这样的效果。事务还规定不同的客户端看到的数据是不相同的。</p><p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可保证一组操作不会中途停止，他们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销操作）以恢复数据库到某个已知且安全的状态。</p><a id="more"></a><p>基本术语：</p><blockquote><ul><li><strong>事务（transaction）指一组SQL语句；</strong></li><li><strong>回退（rollback）指撤销指定SQL语句的过程</strong></li><li><strong>提交（Commit）指将未储存的SQL语句结果写入数据库表；</strong></li><li><strong>保留点（savepoint）指事处理中设置的临界占位符（place-holder），你可以对它发布退回（与回退整个事务处理不同）</strong></li></ul></blockquote><h2 id="11-2-事务处理基本操作"><a href="#11-2-事务处理基本操作" class="headerlink" title="11.2  事务处理基本操作"></a>11.2  事务处理基本操作</h2><p>案例：</p><p>银行转账的例子更需要考虑事务问题。</p><ul><li><p>创建测试表</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table account(</span><br><span class="line">    -&gt; id int primary key,</span><br><span class="line">    -&gt; name varchar(50) not null default &apos;&apos;,</span><br><span class="line">    -&gt; balance decimal(10,2) not null default 0.0</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure></li><li><p>开始一个事务</p><p><code>start transaction</code>  <code>begin</code></p></li><li><p>创建一个保存点</p><p><code>savepoint 保存点名</code></p></li><li><p>回到保存点（根据具体情况）</p><p><code>rollback to 保存点名</code> <code>release savepoint</code></p></li><li><p>提交结束当前事务</p><p><code>commit;</code> <code>rollback</code></p></li><li><p>代码演示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; -- 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint aa; -- 设置保存点aa</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(1,&apos;张三&apos;,10); --添加一条存款记录</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint bb; -- 设置保存点bb</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(2,&apos;李四&apos;，100000)； -- 再添加一条记录</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(2,&apos;李四&apos;,100000); -- 再添加一条存款记录</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; -- 两条记录都在</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">| id | name   | balance   |</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">|  1 | 张三   |     10.00 |</span><br><span class="line">|  2 | 李四   | 100000.00 |</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback to bb;  -- 发现后来添加这一条记录是误操作。所以回滚到bb状态 </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; -- 第二条记录没了</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 张三   |   10.00 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-2事务处理注意事项"><a href="#11-2事务处理注意事项" class="headerlink" title="11.2事务处理注意事项"></a>11.2事务处理注意事项</h2><ul><li><p>如果没有设置保存点，也可以回滚，只是回滚到事务的开始。直接使用 rollback(前提事务还没有提交)</p></li><li><p>如果一个事务被提交了（Commit）,则不可以回退（rollback）</p></li><li><p>可以选择回退到哪一个保存点</p></li><li><p>innnoDB支持事务，MyISAM不支持事务</p></li><li><p>开始事务 start transaction</p></li><li><p>rollback只能在一个事务处理内使用（在执行一条start transaction命令之后）</p></li></ul><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips:"></a>小tips:</h3><blockquote><p><strong>事务处理用来管理insert,update和delete语句，不能回退select,create,drop语句，如果你执行回退，他们不会被撤销。</strong>DDL语句和隐式修改MySQL构架的语句：<code>set password</code> ,<code>create user</code>…</p><p>管理语句：<code>cache index</code> <code>load indeex</code>  <code>analyze table</code>…</p></blockquote><h2 id="11-3使用Commit"><a href="#11-3使用Commit" class="headerlink" title="11.3使用Commit"></a>11.3使用Commit</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交(implicit commot)，即提交（写或保存）操作就是自动进行的。</p><p>但是在事务处理块中，提交不会隐含地进行。为进行明确地提交，使用commit语句。commit语句后当前事务就已经结束了，在事务中保存地回退点就不再存在了。</p><p>【以下仅个人理解】</p><p>可以这样理解事务地执行过程，开始一个事务后所有的SQL语句（insert，delete,update）执行的结果都在内存中保存并未真实的写入物理磁盘中（文件），一个回退点就相当标记当前时刻临时表中（内存）的状态，当执行回退时，就像栈一样的之前的语句从语句栈中弹出，返回表的回退点的状态。</p><p><strong>当commit执行后，或者rollback语句执行后事务回关闭。</strong>将内存中的有效SQL语句对应表写回物理磁盘中表（文件）  【此处的rollback语句并非是<code>rollback to 回退点</code>语句，回滚的回退点的语句并不能真正结束事务，还需显示的调用commit 或 rollback语句】</p><p><strong>当一个事务中某行语句执行出错时，commit之前的一条语句，则自动回退到执行错误语句的前面且事务并没有被提交，假如再使用<code>start transaction</code>则会提交之前的事务，开始新的事务。</strong></p><h3 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips:"></a>小Tips:</h3><blockquote><p>隐含事务关闭：当commit执行后，或者rollback语句执行后事务回关闭，事务回自动关闭（将来的更改将会隐式的提交）</p></blockquote><h2 id="11-4使用保留点"><a href="#11-4使用保留点" class="headerlink" title="11.4使用保留点"></a>11.4使用保留点</h2><p>简单的rollback和commit语句就可以写入或撤回整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。</p><p>回退点<code>savepoint 回退点名称</code> ，如果重复使用回退点的名称，则覆盖新的回退点。</p><p><strong>释放保留点</strong>：<code>rollback to 保留点名称</code> 、release savepoint(MySQL 5以来)</p><h2 id="11-5更改默认的提交行为"><a href="#11-5更改默认的提交行为" class="headerlink" title="11.5更改默认的提交行为"></a>11.5更改默认的提交行为</h2><p>默认MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上就是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br></pre></td></tr></table></figure><p>autocommit标志决定是否自动提交更改，不管有没有commit语句。设置autocommit 为（假 0）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p><blockquote><p>改标志autocommit针对每一个连接而不是服务器的。</p></blockquote><h2 id="11-6-事务的隔离级别"><a href="#11-6-事务的隔离级别" class="headerlink" title="11.6 事务的隔离级别"></a>11.6 事务的隔离级别</h2><p>当我们有多个客户端同时操作数据库的某张表，如何进行隔离操作？MySQL提供了个隔离级别</p><p>当MySQL表被多个线程或者客户端开启各自事务操作数据库中的数据库时，MySQL提供了一种机制，可以让不同的事务操作数据时，具有隔离性。从而保证数据的一致性。</p><h3 id="11-6-1无隔离性的带来问题"><a href="#11-6-1无隔离性的带来问题" class="headerlink" title="11.6.1无隔离性的带来问题"></a>11.6.1无隔离性的带来问题</h3><p>1.脏读</p><p>是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交数据中，这时，另外事务也访问这个数据，然后使用了这个不是最新的数据。</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Mary的原工资为1000，财务人员将Mary的工资改为8000（但未提交事务）</span><br><span class="line">2.Mary读取自己的工资，发现自己的工资变为8000，很开心！</span><br><span class="line">3.而财务发现自己操作有误，回滚了事务，Marry工资变为了1000，Marry读到的工资数8000是一个脏数据。</span><br><span class="line">解决:在事务修改完成并提交后才可以读取到数据，则可避免该问题</span><br></pre></td></tr></table></figure><p>2.不可重复读</p><p>是指一个事务内，多次读同一数据。在这个事务还没结束时，另外一个事务也访问该同一数据。那么，在第一个事务中两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据有可能不一样。这样读发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复度。（即不读到相同的数据内容）</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在事务1中，Marry读取到自己工资为1000，操作并没有完成。</span><br><span class="line">2.在事务2中，这时财务人员修改了Marry的工资为2000，并提交事务。</span><br><span class="line">3.在事务1中，Marry再次读取到自己的工资时，工资变了2000</span><br><span class="line">解决方法：在事务修改完成并提交后才可以读取到数据，则可避免该问题</span><br></pre></td></tr></table></figure><p>3.幻读</p><p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改设计到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入了一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就像发生了幻觉一样。</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目前工资为1000的员工有10人。   </span><br><span class="line">1.事务1,读取所有工资为1000的员工。    </span><br><span class="line">2.这时事务2向employee表插入了一条员工记录，工资也为1000    </span><br><span class="line">3.事务1再次读取所有工资为1000的员工 共读取到了11条记录，          </span><br><span class="line">解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题</span><br></pre></td></tr></table></figure><p><strong>备注</strong>：不可重复读的<strong>重点是修改</strong>：同样的条件, 你读取过的数据,再次读取出来发现值不一样了 幻读的重点在 于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样</p><h3 id="11-6-2事务的隔离级别"><a href="#11-6-2事务的隔离级别" class="headerlink" title="11.6.2事务的隔离级别"></a>11.6.2事务的隔离级别</h3><table><thead><tr><th>隔离级别</th><th style="text-align:left">脏读</th><th style="text-align:left">不可重复读</th><th style="text-align:left">幻读</th><th style="text-align:left">加锁读</th></tr></thead><tbody><tr><td></td><td style="text-align:left">1修改未提交2读1回滚2读</td><td style="text-align:left">1读2修改提交1再读</td><td style="text-align:left">1读2增加3读（发现多了一条数据）</td><td style="text-align:left"></td></tr><tr><td>读未提交(read uncommitter）</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>读已提交(read committed)</td><td style="text-align:left">✖</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>可重复读(repeatable read)</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>可串行化读(serializable)</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">加锁</td></tr></tbody></table><ul><li>设置事务的隔离级别</li></ul><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><ul><li>查看当前隔离级别：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>隔离级别：客串行化例子：</li></ul><ol><li>当客户端A在执行select过程中（还没有提交结束事务），DBMS会对库加锁，如果这时客户端B执行插入，只要还没释放锁，插入不进去，会将B的update语句放入阻塞队列，直到释放了锁或超时。</li></ol><blockquote><p><strong>说明：mysql默认的隔离级别是可重复读，一般情况下不要修改，修改完后一定要修改回去，要不然就会一直保持直到关闭客户端。</strong></p></blockquote><h2 id="11-7事务的ACID特性"><a href="#11-7事务的ACID特性" class="headerlink" title="11.7事务的ACID特性"></a>11.7事务的ACID特性</h2><ul><li><strong>原子性（Atomicity）</strong></li></ul><p>事务是应用中最小的执行单位，具有不可再分的特征，事务是应用中不可再分的最小逻辑执行体。</p><ul><li><strong>一致性（Consistency</strong>）</li></ul><p>事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务成功提交的结果 时，数据库处于一致性状态。如果系统运行发生中断，某个事务尚未完成而被迫中断，而改未完成的事务对数据库 所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过原子性来保证的。</p><ul><li><strong>隔离性（lsolation）</strong></li></ul><p>各种事务的执行互不干扰，任意一个事务的内部操作对其他并发事务都是隔离的。也就是说，并发执行的事务之间不能看到对方的中间状态。并发执行的事务之间不能互相影响。</p><ul><li><strong>持久性（Durability）</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库所做的改变都要记录到永久存储其中（如：磁盘）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;11-事务管理&quot;&gt;&lt;a href=&quot;#11-事务管理&quot; class=&quot;headerlink&quot; title=&quot;11-事务管理&quot;&gt;&lt;/a&gt;11-事务管理&lt;/h1&gt;&lt;p&gt;事务就是一组DML语句组成，这些语句在逻辑上存在着相关性，这一组DML语句要么成功，要么全部失败，是一个整体。MySQL提供一种机制，保证我们达到这样的效果。事务还规定不同的客户端看到的数据是不相同的。&lt;/p&gt;
&lt;p&gt;事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可保证一组操作不会中途停止，他们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销操作）以恢复数据库到某个已知且安全的状态。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>10-索引特性</title>
    <link href="https://soyanga.github.io/2019/01/04/10-%E7%B4%A2%E5%BC%95%E7%89%B9%E6%80%A7/"/>
    <id>https://soyanga.github.io/2019/01/04/10-索引特性/</id>
    <published>2019-01-04T08:51:06.000Z</published>
    <updated>2019-01-04T13:10:10.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="10索引特性（重点-）"><a href="#10索引特性（重点-）" class="headerlink" title="10索引特性（重点**）"></a>10索引特性（重点**）</h1><p>索引：提高数据库的性能，索引是物美价廉的东西。不用增加内存，不用该程序，不用调sql ,只要执行正确的<code>create index</code>，查询 ==速度== 就能提高成百上千倍。但是查速度的提高是以插入，更新，删除的速度为代价的，这些写操作，增加了大量的IO。所以它的价值，在于提高==海量数据的键锁速度==。</p><p><strong>常见索引分为：</strong></p><ul><li>主键索引（primary key)</li><li>唯一键索引（unique）</li><li>普通索引 (index)</li><li>全文索引（fulltext）–解决中文索引问题</li></ul><p><strong>索引部分目前只做简单学习，下来将索引部分详细研究后再对本篇博客做补充。</strong></p><a id="more"></a><p><strong>练习</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- 构建一个8000000条记录的数据 --构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解</span><br><span class="line"> </span><br><span class="line">-- 产生随机字符串 </span><br><span class="line">delimiter $$ </span><br><span class="line">create function rand_string(n INT) </span><br><span class="line">returns varchar(255) </span><br><span class="line">begin  </span><br><span class="line">declare chars_str varchar(100) default   &apos;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&apos;; </span><br><span class="line">declare return_str varchar(255) default &apos;&apos;; </span><br><span class="line">declare i int default 0; </span><br><span class="line">while i &lt; n do    </span><br><span class="line">set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));   set i = i + 1;   </span><br><span class="line">end while;  </span><br><span class="line">return return_str;  </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">--产生随机数字 delimiter $$ </span><br><span class="line">create function rand_num() </span><br><span class="line">returns int(5) </span><br><span class="line">begin  </span><br><span class="line">declare i int default 0; </span><br><span class="line">set i = floor(10+rand()*500); </span><br><span class="line">return i; </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">--创建存储过程，向雇员表添加海量数据 </span><br><span class="line">delimiter $$ </span><br><span class="line">create procedure insert_emp(in start int(10),in max_num int(10))</span><br><span class="line">begin </span><br><span class="line">declare i int default 0;  </span><br><span class="line">set autocommit = 0;   </span><br><span class="line">repeat  set i = i + 1;  </span><br><span class="line">insert into EMP values ((start+i) ,rand_string(6),&apos;SALESMAN&apos;,0001,curdate(),2000,400,rand_num());  </span><br><span class="line">until i = max_num </span><br><span class="line">end repeat; </span><br><span class="line">commit; </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> -- 执行存储过程，添加8000000条记录 </span><br><span class="line"> call insert_emp(100001, 8000000);</span><br></pre></td></tr></table></figure><p>目前没有进行mysql sql编程的经验，以下只做这几点的概述。</p><p>关于<code>delimiter $$</code>的意思</p><blockquote><p>将分隔符； 临时性的改为$$  防止在函数中出现” ; “会导致直接执行。<code>用完后改回来。delimiter ;</code></p></blockquote><p>建立处海量数据的表（8000000条数据）</p><ul><li><p>查询员工编号为9998877的员工，MySQL会从第一条数据开始遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp whrer empno=998877;</span><br></pre></td></tr></table></figure><p>耗时4.93秒（耗时时间跟储存介质即电脑中储存mysql数据的硬盘有关），在实际项目中，本机是由一个人来操作的，假如放到公网中，同时又10000个人并发查询，则就可能引起死机</p><p><strong>解决办法：</strong>创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add index(empno);</span><br></pre></td></tr></table></figure><p>耗时0.1秒都不到大大加快了查询速度，但是创建索引的过程还是耗时挺久的4秒左右。</p><p>粗略估计增加了快500倍。</p></li></ul><h2 id="10-1查询过程中的基本原理"><a href="#10-1查询过程中的基本原理" class="headerlink" title="10.1查询过程中的基本原理"></a>10.1查询过程中的基本原理</h2><ul><li><p>没有索引时：执行<code>select * from emp whrer empno=998877;sql语句是对这张存有海量数据的表进行整表的查询</code></p></li><li><p>而增加索引，会让表中数据形成一棵树（MySQL 中默认引擎innodb是形成一颗B+树）影响查询速度的是<strong>树的深度</strong></p><p>B+树 是 普通二叉树的升级版，减少了树的深度。</p><p>B+Tree：详解</p><p><a href="https://zhuanlan.zhihu.com/p/24309634" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24309634</a></p></li></ul><h2 id="10-2创建索引"><a href="#10-2创建索引" class="headerlink" title="10.2创建索引"></a>10.2创建索引</h2><h3 id="10-2-1创建主键索引"><a href="#10-2-1创建主键索引" class="headerlink" title="10.2.1创建主键索引"></a>10.2.1创建主键索引</h3><ul><li><p>第一种方式：</p><p>==在创建表的时候，直接在字段名后面直接指定<code>primay key</code>==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(30)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第二种方式</p><p>==在创建表最后，指定某列或者几列为主键索引==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>第三种方式：</p><p>==创建表之后再添加主题==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ccreate table  user3(</span><br><span class="line">    id int, </span><br><span class="line">    name varchar(30)</span><br><span class="line">); </span><br><span class="line">-- 创建表以后再添加主键 </span><br><span class="line">alter table user3 add primary key(id);</span><br></pre></td></tr></table></figure></li></ul><p><strong>主键索引的特点</strong>：</p><ul><li>一个表中，最多有一个主键索引，当然可以使复合主键 </li><li>主键索引的效率高（主键不可重复） </li><li>创建主键索引的列，它的值不能为null，且不能重复 </li><li>主键索引的列基本上是int</li></ul><h3 id="10-2-2唯一键的创建"><a href="#10-2-2唯一键的创建" class="headerlink" title="10.2.2唯一键的创建"></a>10.2.2唯一键的创建</h3><ul><li><p>第一种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 在表定义时，在某列后直接指定unique唯一属性。 </span><br><span class="line">create table user4(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30) unique</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第二种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表时，在表的后面指定某列或某几列为unique </span><br><span class="line">create table user5(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30), </span><br><span class="line">    unique(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第三种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user6(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30)</span><br><span class="line">）； </span><br><span class="line">-- </span><br><span class="line">alter table user6 add unique(name);</span><br></pre></td></tr></table></figure></li></ul><p><strong>唯一索引的特点：</strong></p><ul><li>一个表中，可以有多个唯一索引 </li><li>查询效率高 如果在某一列建立唯一索引，必须保证这列不能有重复数据 </li><li>==如果一个唯一索引上指定not null，等价于主键索引==</li></ul><h3 id="10-2-3-普通索引的创建"><a href="#10-2-3-普通索引的创建" class="headerlink" title="10.2.3 普通索引的创建"></a>10.2.3 普通索引的创建</h3><ul><li>第一种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table user8(id int primary key,     </span><br><span class="line">name varchar(20),     </span><br><span class="line">email varchar(30),     </span><br><span class="line">index(name) --在表的定义最后，指定某列为索引 </span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>第二种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user9(id int primary key,  name varchar(20),  email varchar(30)); </span><br><span class="line">alter table user9 add index(name); </span><br><span class="line">-- 创建完表以后指定某列为普通索引</span><br></pre></td></tr></table></figure></li><li><p>第三种方式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user10(id int primary key,  </span><br><span class="line">name varchar(20),  </span><br><span class="line">email varchar(30)</span><br><span class="line">); </span><br><span class="line">-- 创建一个索引名为 idx_name 的索引    </span><br><span class="line">create index idx_name on user10(name);</span><br></pre></td></tr></table></figure><p>普通索引的特点：</p><ul><li>一个表中可以有多个普通索引，普通索引在实际开发中用的比较多 </li><li>如果某列需要创建索引，==但是该列有重复的值==，那么我们就应该使用普通索引 </li></ul><h3 id="10-2-4全文索引"><a href="#10-2-4全文索引" class="headerlink" title="10.2.4全文索引"></a>10.2.4全文索引</h3><p>当文章字段或有大量文字的字段进行检索时，会使用到全文索引。MySQL提供全文索引机制。之前是只有在MyISAM引擎，现在innodb引擎也支持全文索引。但是默认支持的是英文，你不支持中文。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles (    </span><br><span class="line">id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,    </span><br><span class="line">title VARCHAR(200),    </span><br><span class="line">body TEXT,    </span><br><span class="line">FULLTEXT (title,body) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO articles (title,body) VALUES    </span><br><span class="line">(&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;),    </span><br><span class="line">(&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;),    </span><br><span class="line">(&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;),    </span><br><span class="line">(&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;),    </span><br><span class="line">(&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;),    </span><br><span class="line">(&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);</span><br></pre></td></tr></table></figure><ul><li>查询有没有’database‘数据</li></ul><p>如果使用如下方式查询，虽然查询出结果，但是没有用到全文索引.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from artices where body like &apos;%database%&apos;;</span><br><span class="line"></span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br></pre></td></tr></table></figure><p>可以使用explain工具看一下，是否使用到索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from articles where body like &apos;database&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE  -- ：简单查询</span><br><span class="line">        table: articles</span><br><span class="line">   partitions: NULL   -- possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</span><br><span class="line">         type: ALL    -- ：全表查询</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL   -- &lt;==key为null表示没有用到索引</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL    -- 显示索引的哪一列被使用了，如果可能的话，是一个常数</span><br><span class="line">         rows: 6       -- ：这个值是innodb预估的一个值(并不是是一个准确值)MYSQL认为必须检查的用来返回请求数据的行数</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><ul><li>全文索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select * from articles</span><br><span class="line">    -&gt; where match(title,body) against (&apos;database&apos;);</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">2 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure><p>通过explain来分析这个sql语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST (&apos;database&apos;)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: articles</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: fulltext  -- 全文索引</span><br><span class="line">possible_keys: title</span><br><span class="line">          key: title     -- &lt;=key 用到了title</span><br><span class="line">      key_len: 0</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>关于explain 分析后的结果参数内容含义解释如下：<a href="https://www.cnblogs.com/yycc/p/7338894.html" target="_blank" rel="noopener">https://www.cnblogs.com/yycc/p/7338894.html</a></p><h2 id="10-3查询索引"><a href="#10-3查询索引" class="headerlink" title="10.3查询索引"></a>10.3查询索引</h2><ul><li>第一种方法： <code>show key from 表明</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show keys from articles\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: articles  -- :表名</span><br><span class="line">   Non_unique: 0   -- 0表示唯一索引</span><br><span class="line">     Key_name: PRIMARY-- &lt;=主键索引</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id-- 索引在那里列</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE   ： -- 以二叉树形式的索引</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: articles</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: title</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: title</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: articles</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: title</span><br><span class="line"> Seq_in_index: 2</span><br><span class="line">  Column_name: body</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p>第二种方式：<code>show index from 表明;</code></p></li><li><p>第三种方式（信息比较简略）：<code>desc 表明：</code></p></li></ul><h2 id="10-4删除索引"><a href="#10-4删除索引" class="headerlink" title="10.4删除索引"></a>10.4删除索引</h2><ul><li>第一种方法-删除主键索引：<code>alter table 表明 drop primary key;</code></li><li>第二种方法-其他索引的删除： <code>alter table 表明 drop index 索引名; 索引名就是show keys from 表名种的key_name字段</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user10 drop index idx_name;</span><br></pre></td></tr></table></figure><ul><li>第三种方法方法：drop index 索引名 on 表名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index name on user10;</span><br></pre></td></tr></table></figure><h2 id="10-5索引创建原则"><a href="#10-5索引创建原则" class="headerlink" title="10.5索引创建原则"></a>10.5索引创建原则</h2><ul><li>比较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件（主要业务的要求）</li><li>更新非常频繁的字段不适合当作创建索引</li><li>不会出现在where子句中的字段不该创建索引</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;10索引特性（重点-）&quot;&gt;&lt;a href=&quot;#10索引特性（重点-）&quot; class=&quot;headerlink&quot; title=&quot;10索引特性（重点**）&quot;&gt;&lt;/a&gt;10索引特性（重点**）&lt;/h1&gt;&lt;p&gt;索引：提高数据库的性能，索引是物美价廉的东西。不用增加内存，不用该程序，不用调sql ,只要执行正确的&lt;code&gt;create index&lt;/code&gt;，查询 ==速度== 就能提高成百上千倍。但是查速度的提高是以插入，更新，删除的速度为代价的，这些写操作，增加了大量的IO。所以它的价值，在于提高==海量数据的键锁速度==。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见索引分为：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键索引（primary key)&lt;/li&gt;
&lt;li&gt;唯一键索引（unique）&lt;/li&gt;
&lt;li&gt;普通索引 (index)&lt;/li&gt;
&lt;li&gt;全文索引（fulltext）–解决中文索引问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;索引部分目前只做简单学习，下来将索引部分详细研究后再对本篇博客做补充。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>09-表的内外连接</title>
    <link href="https://soyanga.github.io/2019/01/03/09-%E8%A1%A8%E7%9A%84%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
    <id>https://soyanga.github.io/2019/01/03/09-表的内外连接/</id>
    <published>2019-01-03T07:38:41.000Z</published>
    <updated>2019-01-04T08:52:32.106Z</updated>
    
    <content type="html"><![CDATA[<p><strong>配合食用效果极佳 </strong></p><p><strong>内连接查询：</strong>往往使用频繁，可以配合多种查询方法食用。</p><p>内连接就是两表的笛卡儿积表的基础上进行筛选</p><p><strong>外连接查询：</strong>首先要确定<strong>基准表</strong>（<strong>基准信息</strong>），即左连接的左表，右连接的右表。然后确定<strong>结合表</strong>，结合表需要的筛选条件。</p><a id="more"></a><h1 id="09-表的内外连接"><a href="#09-表的内外连接" class="headerlink" title="09 表的内外连接"></a>09 表的内外连接</h1><h2 id="9-1内链接"><a href="#9-1内链接" class="headerlink" title="9.1内链接"></a>9.1内链接</h2><p>内连接实际上就是利用where子句对两种表形成的笛卡儿积进行筛选，我们前面学习的查询都是内连接，也是在开发过程中使用的最多的连接查询</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表1 inner join 表2 on 连接条件 and其他连接条件;</span><br></pre></td></tr></table></figure><blockquote><p>之前学的就是内连接</p></blockquote><p>显示smith的名字和部门名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 之前写法</span><br><span class="line">select ename,dename from emp,dept where emp.deptno=dept.deptno and ename=&apos;smith&apos;;</span><br><span class="line"></span><br><span class="line">-- 标准内连接写法</span><br><span class="line">select ename,dename from emp inner join dept on emp.deptno=dept.depyno and ename=&apos;smith&apos;;</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>inner join就是inner join两个表的笛卡儿积中筛选on 后的条件</p><h2 id="9-2外连接"><a href="#9-2外连接" class="headerlink" title="9.2外连接"></a>9.2外连接</h2><p>外连接分为左连接右连接。（记住一种自己熟悉的即可）</p><h3 id="9-2-1左外连接"><a href="#9-2-1左外连接" class="headerlink" title="9.2.1左外连接"></a>9.2.1左外连接</h3><p><strong>左外连接:</strong>  如果联合查询的时，左侧的表我们完全显示 </p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表名1 left join 表名2 on 连接条件</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>left join就是左表（一定显示）和右表中on后筛选后的表的结合（以左表为基础上添加（符合筛选条件的）右表）</p><h3 id="9-2-2右外连接"><a href="#9-2-2右外连接" class="headerlink" title="9.2.2右外连接"></a>9.2.2右外连接</h3><p><strong>右连接：</strong>如果联合查询，右侧的表完全显示我们就说是右外连接。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表明1 right join 表明2 on 连接条件</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>left join就是右表（一定显示）和左表中on后筛选后的表的结合（以右表为基础上添加（符合筛选条件的）左标）</p><p><strong>小练习：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 键两张表</span><br><span class="line">create table stu (id int, name varchar(30));  -- 学生表 </span><br><span class="line">insert into stu values(1,&apos;jack&apos;),(2,&apos;tom&apos;),(3,&apos;kity&apos;),(4,&apos;nono&apos;); </span><br><span class="line"></span><br><span class="line">create table exam (id int, grade int);  -- 成绩表</span><br><span class="line">insert into exam values(1, 56),(2,76),(11, 8);</span><br></pre></td></tr></table></figure><ul><li><p><strong>查询所有学生的成绩，如果没有这个学生的成绩，也要将学生的个人信息显示出来。</strong></p><p><strong>分析：</strong>关键字:所有学生， 成绩，（没有成绩也要显示出来） （<strong>以学生表为基准表，结合成绩表</strong>）外连接（左右都可以）</p><p><strong>左外连接：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu left inner exam on stu.id=exam.id;</span><br></pre></td></tr></table></figure><p>​    <strong>右外连接：</strong>（不适合，因为一般都是基准表在结合表的前面显示）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select stu.* from exam right inner stu on stu.id=exam.id;</span><br><span class="line"></span><br><span class="line">-- 改为：（太麻烦）</span><br><span class="line">select stu.id ,stu.name,exam.id,exam.grade from exam right join stu on stu.id=exam.id;</span><br></pre></td></tr></table></figure><ul><li><strong>对stu表和exam表联合查询，把所有的成绩都显示出来，即使这个成绩没有学生与它对应，也要显示出来</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu right join exam on stu.id=exam.id;</span><br></pre></td></tr></table></figure><ul><li><p><strong>列处部门名称和这些部门的员工信息，同时列出没有员工的部门</strong></p><p><strong>分析：</strong>关键字（部门名称，这些部分的员工信息，列出没有员工的部门）（<strong>以部门名称基准表，结合与员工表</strong>）外连接（左右都可以）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 方法一：</span><br><span class="line">select d.dname, e.* from dept d left join emp e on d.deptno=e.deptno; </span><br><span class="line">-- 方法二： </span><br><span class="line">select d.dname, e.* from emp e right join dept d on d.deptno=e.deptno;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p>内连接查询：往往使用频繁，可以配合多种查询方法食用。</p><p>内连接就是两表的笛卡儿积表的基础上进行筛选</p><p>外连接查询：首先要确定<strong>基准表</strong>（<strong>基准信息</strong>），即左连接的左表，右连接的右表。然后确定<strong>结合表</strong>，结合表需要的筛选条件。</p></blockquote><blockquote><p><strong>SQL</strong>查询中各个关键字的执行先后顺序：</p><p>from &gt; on&gt; join &gt; where &gt; group by &gt; with &gt; having &gt; select &gt; distinct &gt; order by &gt; limit</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;配合食用效果极佳 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内连接查询：&lt;/strong&gt;往往使用频繁，可以配合多种查询方法食用。&lt;/p&gt;
&lt;p&gt;内连接就是两表的笛卡儿积表的基础上进行筛选&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外连接查询：&lt;/strong&gt;首先要确定&lt;strong&gt;基准表&lt;/strong&gt;（&lt;strong&gt;基准信息&lt;/strong&gt;），即左连接的左表，右连接的右表。然后确定&lt;strong&gt;结合表&lt;/strong&gt;，结合表需要的筛选条件。&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL数据库练习" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL练习复合查询</title>
    <link href="https://soyanga.github.io/2019/01/03/MySQL%E7%BB%83%E4%B9%A0%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
    <id>https://soyanga.github.io/2019/01/03/MySQL练习复合查询/</id>
    <published>2019-01-03T05:47:17.000Z</published>
    <updated>2019-01-03T08:55:08.629Z</updated>
    
    <content type="html"><![CDATA[<p><strong>复合查询（重点）</strong></p><ul><li>函数得使用</li></ul><ul><li><p>多表查询</p></li><li><p>自连接</p></li><li><p>子查询</p></li></ul><a id="more"></a><h1 id="07-MySQL-函数"><a href="#07-MySQL-函数" class="headerlink" title="07-MySQL 函数"></a>07-MySQL 函数</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><blockquote><p>查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</p></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select length(&apos;10,A,B&apos;)-length(replace(&apos;10,A,B&apos;, &apos;,&apos; ,&apos;&apos;)) as cnt;</span><br></pre></td></tr></table></figure><h1 id="08-MySQL-复合查询"><a href="#08-MySQL-复合查询" class="headerlink" title="08-MySQL 复合查询"></a>08-MySQL 复合查询</h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><blockquote><p>查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, s.salary from employees as e, salaries as s where e.emp_no =s.emp_no and e.hire_date = s.from_date order by e.emp_no desc;</span><br></pre></td></tr></table></figure><p><strong>解决2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, s.salary from employees as e inner join salaries as s on e.emp_no = s.emp_no and e.hire_date = s.from_date order by e.emp_no desc;</span><br></pre></td></tr></table></figure><h2 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2.题目描述"></a>2.题目描述</h2><blockquote><p>针对库中的所有表生成select count(*)对应的SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; create table emp_bonus(</span><br><span class="line">&gt; emp_no int not null,</span><br><span class="line">&gt; recevied datetime not null,</span><br><span class="line">&gt; btype smallint not null);</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_emp` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;select count(*) from &apos;,t.TABLE_NAME,&apos;;&apos;) AS cnts  from (select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database()) t;</span><br></pre></td></tr></table></figure><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;select count(*) from &quot;||name||&quot;;&quot; as cnts  from sqlite_master where type=&apos;table&apos;</span><br></pre></td></tr></table></figure><h2 id="3-题目描述"><a href="#3-题目描述" class="headerlink" title="3.题目描述"></a>3.题目描述</h2><blockquote><p>获取所有非manager的员工emp_no</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no from employees as e left join dept_manager as d on e.emp_no =d.emp_no where d.dept_no is null</span><br></pre></td></tr></table></figure><h2 id="4-题目描述"><a href="#4-题目描述" class="headerlink" title="4.题目描述"></a>4.题目描述</h2><blockquote><p>获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。<br>结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_emp` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, m.emp_no as manager_no from dept_emp as e inner join dept_manager as m on e.dept_no = m.dept_no where e.to_date = &apos;9999-01-01&apos; and m.to_date = &apos;9999-01-01&apos; and e.emp_no != m.emp_no;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;复合查询（重点）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数得使用&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;多表查询&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子查询&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL数据库练习" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>MySQL练习</title>
    <link href="https://soyanga.github.io/2019/01/02/MySQL%E7%BB%83%E4%B9%A0/"/>
    <id>https://soyanga.github.io/2019/01/02/MySQL练习/</id>
    <published>2019-01-02T15:00:52.000Z</published>
    <updated>2019-01-03T08:54:54.056Z</updated>
    
    <content type="html"><![CDATA[<p><strong>MySQL基本查询得练习（基础部分）</strong></p><p>MySQL学习得关键多连多练多练！！！</p><a id="more"></a><h1 id="MySQL小练"><a href="#MySQL小练" class="headerlink" title="MySQL小练"></a>MySQL小练</h1><h2 id="06-MySQL基本查询"><a href="#06-MySQL基本查询" class="headerlink" title="06-MySQL基本查询"></a>06-MySQL基本查询</h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><blockquote><p>对于表actor批量插入如下数据<br>`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE  IF NOT EXISTS actor  (`</span><br><span class="line">&gt; `actor_id  smallint(5)  NOT NULL PRIMARY KEY,`</span><br><span class="line">&gt; `first_name  varchar(45) NOT NULL,`</span><br><span class="line">&gt; `last_name  varchar(45) NOT NULL,`</span><br><span class="line">&gt; `last_update  timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))`</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into actor(actor_id,first_name,last_name,last_update) values</span><br><span class="line">(1,&apos;PENELOPE&apos;,&apos;GUINESS&apos;,&apos;2006-02-15 12:34:33 &apos;),</span><br><span class="line">(2,&apos;NICK&apos;,&apos;WAHLBERG&apos;,&apos;2006-02-15 12:34:33&apos;);</span><br></pre></td></tr></table></figure><h3 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2. 题目描述"></a>2. 题目描述</h3><blockquote><p>找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct salary from salaries where to_date = &apos;9999-01-01&apos; order by salary desc;</span><br></pre></td></tr></table></figure><h3 id="3-题目描述"><a href="#3-题目描述" class="headerlink" title="3. 题目描述"></a>3. 题目描述</h3><blockquote><p>查找最晚入职员工的所有信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt;  PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; **解答：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 1;</span><br></pre></td></tr></table></figure><h3 id="4-题目描述"><a href="#4-题目描述" class="headerlink" title="4. 题目描述"></a>4. 题目描述</h3><blockquote><p>查找入职员工时间排名倒数第三的员工所有信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 2,1;</span><br></pre></td></tr></table></figure><h3 id="5-题目描述"><a href="#5-题目描述" class="headerlink" title="5. 题目描述"></a>5. 题目描述</h3><blockquote><p>查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no , count(distinct salary) t from salaries group by emp_no having t&gt;15;</span><br></pre></td></tr></table></figure><h3 id="6-题目描述"><a href="#6-题目描述" class="headerlink" title="6. 题目描述"></a>6. 题目描述</h3><blockquote><p>获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dept_no, d.emp_no ,salary from salaries as s ,dept_manager as d </span><br><span class="line">where s.emp_no = d.emp_no </span><br><span class="line">and d.to_date = &apos;9999-01-01&apos; </span><br><span class="line">and s.to_date = &apos;9999-01-01&apos;;</span><br></pre></td></tr></table></figure><h3 id="7-题目描述"><a href="#7-题目描述" class="headerlink" title="7. 题目描述"></a>7. 题目描述</h3><blockquote><p>从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS &quot;titles&quot; (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `title` varchar(50) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date DEFAULT NULL);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title ,count(title) t from titles group by title having t&gt;=2;</span><br></pre></td></tr></table></figure><h3 id="8-LeetCode-182-查找重复的电子邮箱"><a href="#8-LeetCode-182-查找重复的电子邮箱" class="headerlink" title="8. LeetCode [182. 查找重复的电子邮箱]"></a>8. LeetCode [182. 查找重复的电子邮箱]</h3><blockquote><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Create table If Not Exists Person (</span><br><span class="line">&gt; Id int, </span><br><span class="line">&gt; Email varchar(255)</span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select Email from Person group by Email having count(Email)&gt;1;</span><br></pre></td></tr></table></figure><h3 id="9-LeetCode-595-大的国家"><a href="#9-LeetCode-595-大的国家" class="headerlink" title="9. LeetCode [595.大的国家]"></a>9. LeetCode [595.大的国家]</h3><blockquote><p>这里有张 <code>World</code> 表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt; | name            | continent  | area       | population   | gdp           |</span><br><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt; | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">&gt; | Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">&gt; | Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">&gt; | Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">&gt; | Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt; | name         | population  | area         |</span><br><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt; | Afghanistan  | 25500100    | 652230       |</span><br><span class="line">&gt; | Algeria      | 37100000    | 2381741      |</span><br><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>World表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; Create table If Not Exists World (</span><br><span class="line">&gt; </span><br><span class="line">&gt; name varchar(255), </span><br><span class="line">&gt; </span><br><span class="line">&gt; continent varchar(255), </span><br><span class="line">&gt; </span><br><span class="line">&gt; area int, </span><br><span class="line">&gt; </span><br><span class="line">&gt; population int,</span><br><span class="line">&gt; </span><br><span class="line">&gt; gdp int</span><br><span class="line">&gt; </span><br><span class="line">&gt; )；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name ,population,area from World where area&gt;3000000 or population&gt;25000000;</span><br></pre></td></tr></table></figure><h3 id="10-LeetCode-177-第N高薪水"><a href="#10-LeetCode-177-第N高薪水" class="headerlink" title="10. LeetCode[177.第N高薪水]"></a>10. LeetCode[177.第N高薪水]</h3><blockquote><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 <em>n</em> 高的薪水（Salary）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; +----+--------+</span><br><span class="line">&gt; | Id | Salary |</span><br><span class="line">&gt; +----+--------+</span><br><span class="line">&gt; | 1  | 100    |</span><br><span class="line">&gt; | 2  | 200    |</span><br><span class="line">&gt; | 3  | 300    |</span><br><span class="line">&gt; +----+--------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>例如上述 <code>Employee</code> 表，<em>n = 2</em> 时，应返回第二高的薪水 <code>200</code>。如果不存在第 <em>n</em> 高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; +------------------------+</span><br><span class="line">&gt; | getNthHighestSalary(2) |</span><br><span class="line">&gt; +------------------------+</span><br><span class="line">&gt; | 200                    |</span><br><span class="line">&gt; +------------------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  declare M Int;</span><br><span class="line">  Set M = N-1;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      select distinct Salary from Employee  order by Salary desc LIMIT M,1</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;MySQL基本查询得练习（基础部分）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL学习得关键多连多练多练！！！&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/categories/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL数据库" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL数据库练习" scheme="https://soyanga.github.io/tags/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://soyanga.github.io/2018/05/15/hello-world/"/>
    <id>https://soyanga.github.io/2018/05/15/hello-world/</id>
    <published>2018-05-15T13:16:53.615Z</published>
    <updated>2019-01-03T08:56:02.147Z</updated>
    
    <content type="html"><![CDATA[<p><strong>博客开始2018</strong></p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;博客开始2018&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

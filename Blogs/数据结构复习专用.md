---
title: 数据结构复习专用
date: 2019-01-31 23:33:16
tags:
	- 数据结构与算法
	- LeetCode
categories:
	- 数据结构与算法
password: sjjg
top: true
---

<meta name="referrer" content="no-referrer" />

[TOC]



# 数据结构



## 链表



<!--more-->

### 反转单链表 [LeetCode206]

**示例：** 

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**解答：**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null){
            return null;
        }
        ListNode cur = head;
        ListNode per = null;
        ListNode next = null;
        
        while(cur!=null){
            next = cur.next;
            cur.next = per;
            per = cur;
            cur = next;
        }
        return per;
    }
}
```

如图：

其实就只一直在将`cur.next=pre`，然后pre变为cur,cur变为next。

![反转单链表图解](反转单链表图解.png)



### 环形链表（链表是否带环）[LeetCode141]

**示例1：** 

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**示例 3：**

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

**解答：**

1. **利用哈希表Set（无重复值）存储链表节点，头节点向后遍历，只要走到相同的节点，就带环**

   **反之只要头节点向后遍历到null，则链表无环。**

   **时间复杂度O(n) 空间复杂度O(n)**

   ```java
   /**
    * Definition for singly-linked list.
    * class ListNode {
    *     int val;
    *     ListNode next;
    *     ListNode(int x) {
    *         val = x;
    *         next = null;
    *     }
    * }
    */
   public class Solution {
       public boolean hasCycle(ListNode head) {
           Set<ListNode> set = new HashSet();
           while(head!=null){
               if(set.contains(head)){
                   return true;
               }else{
                   set.add(head);
               }
               head=head.next;
           }
           return false;
       }
   }
   ```

   

2. **利用快慢指针，相差一步的快慢指针，**

   **时间复杂度O(n) 空间复杂度O(n)**

   **关于为什么是一个走两步，一个走一步的原因：既然是要相遇，如果快指针走三步，它每次会跳过两个节点，慢指针一次只能走一步，这就可能会错过。快指针每次走两步的话，只会跳过一个节点，无论如何后都会和慢指针相遇。**

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null&&fast.next!=null){
            slow = slow.next;
            fast = fast.next.next;
            while(fast==slow){
                return true;
            }
        }
        return false;
    }
}
```



### 合并两个有序链表[LeetCode21]



**示例：** 

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

**解答：**

时间复杂度：O(n)

空间复杂度：O(1)  

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode newNode = new ListNode(0); //带头结点的新链表
        ListNode cur = newNode;
        while(l1!=null&&l2!=null){//谁小，新链表接谁
            if(l1.val>l2.val){
                 cur.next = l2;
                l2 = l2.next;
            }else{
                cur.next = l1;
                l1 = l1.next;
            }
            cur = cur.next;
        }
        if(l1==null){     //一个链表完了直接接另一个有序列表
            cur.next=l2;
        }else{
            cur.next = l1;
        }
        return newNode.next;
    }
}

```



### 删除链表的倒数第N个节点[LeetCode19]

**示例：** 

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.

```



**解答：** 

时间复杂度：O(n)

空间复杂度：O(1)  

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode newhead = new ListNode(0);//带头节点
        newhead.next = head;
        ListNode fast = newhead;
        ListNode slow = newhead;
        for (int i = 1; i <= n + 1; i++) { //快指针先走n+1步
            fast = fast.next;
        }
        while(fast!=null){  //同时走
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;  倒数第n个节点的前一个节点
        return newhead.next;
    }
}

```



### 求链表的中间结点[LeetCode876]

**示例：**

给定一个带有头结点 `head` 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**示例 1：**

```
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.

```

**示例 2：**

```
输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。

```



**解答：**

**快慢指针法**

- 时间复杂度：O(N)*O*(*N*)，其中 N*N* 是给定列表的结点数目
- 空间复杂度：O(1)*O*(1)，`slow` 和 `fast` 用去的空间

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast!=null&&fast.next!=null){
            fast =fast.next.next;
            slow = slow.next;
        }
        return slow;
    }
}


```



## 栈



### 有效括号[LeetCode20]

**示例：** 

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

```
输入: "()"
输出: true
```

**示例 2:**

```
输入: "()[]{}"
输出: true
```

**示例 3:**

```
输入: "(]"
输出: false
```

**示例 4:**

```
输入: "([)]"
输出: false
```

**示例 5:**

```
输入: "{[]}"
输出: true
```



**解答：利用哈希表以Key-Value模型 存储要匹配的两个字符** 

例如： `map.put(')','(');`假如出现')'则在此相邻的必定出现了'('与之相对，所以将出现的未匹配成功的字符（匹配字符的左括号）压入栈中，等待右括号出现，立马进行出栈确认，在栈为字符串中率先出现一个右括号则在栈中压入一个“#“。则获取匹配已经失败。

反之当字符串都经历了这个流程后栈为空时，此时字符串括号匹配。

代码如下：

```java
class Solution {
    private HashMap<Character,Character> mappings; //存储括号的对应值
    
    public Solution(){
        this.mappings = new HashMap<Character,Character>();
        this.mappings.put(')','(');
        this.mappings.put('}','{');
        this.mappings.put(']','[');
    }
    
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>(); //括号匹配栈
        
        for(int i = 0; i < s.length(); i++){ //按照字符拆分字符串
            char c = s.charAt(i);
            //如果字符串中的字符是一个右半括号
            if(this.mappings.containsKey(c)){
                char toElement = stack.empty()? '#' :stack.pop();
                //按照key查找对应的value值即可
                if(toElement != this.mappings.get(c)){ //括号匹配则继续进行，不匹配则返回不匹配
                    return false;
                }
            }else{
                //如果字符串中是一个左半括号
                stack.push(c);
            }
        }
        return stack.isEmpty();
    }
}
```



### 最小栈[LeetCode155]

**示例：**

设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) -- 将元素 x 推入栈中。
- pop() -- 删除栈顶的元素。
- top() -- 获取栈顶元素。
- getMin() -- 检索栈中的最小元素。

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```



**解答：双栈（主栈+最小栈）/（单栈模拟双栈）**

**双栈**

```java
class MinStack {
    Stack <Integer>stack;
    Stack <Integer>minStack;
    int min;

    /** initialize your data structure here. */
    public MinStack() {
        this.stack = new Stack<Integer>();
        this.minStack = new Stack<Integer>();
    }
    
    public void push(int x) {  //无论如何双栈中压入元素个数相同
        if(minStack.isEmpty()||x<minStack.peek())
            minStack.push(x);
        else{
        minStack.push(minStack.peek());
        }
        stack.push(x);
    }
    
    public void pop() {  //无论如何双栈中抛出元素个数相同
        stack.pop();
        minStack.pop();
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

**单栈模拟双栈：**

```java
class MinStack {
    Stack <Integer>stack;
    /** initialize your data structure here. */
    public MinStack() {
        this.stack = new Stack<Integer>();
    }
    
    public void push(int x) {
        if(stack.isEmpty()){
            stack.push(x);
            stack.push(x);
        }else{
            int temp = stack.peek();
            stack.push(x);
            if(temp<x){
                stack.push(temp);
            }else{
                stack.push(x);
            }
        }   
    }
    
    public void pop() {
        stack.pop();
        stack.pop();
    }
    
    public int top() {
        return stack.get(stack.size()-2);
    }
    
    public int getMin() {
        return stack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```


<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络基础&lt;1&gt;</title>
      <link href="/2019/01/14/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-1/"/>
      <url>/2019/01/14/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80-1/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念（复习）-铺垫"><a href="#线程的概念（复习）-铺垫" class="headerlink" title="线程的概念（复习）-铺垫"></a>线程的概念（复习）-铺垫</h1><ul><li><p>进程是<strong>分配系统资源的基本单位</strong></p></li><li><p>线程是<strong>一个标准的进程(一个执行流的进程)</strong></p></li></ul><h2 id="1-理解（Linux下）"><a href="#1-理解（Linux下）" class="headerlink" title="1.理解（Linux下）"></a>1.理解（Linux下）</h2><p><strong>线程是在进程的内部运行的：</strong>线程是在进程的地址空间内运行的，共享一份虚拟地址空间。</p><p>线程大部分资源都是共享的。（共用一个虚拟地址空间）</p><p>进程大部分资源都是独立的。（每个一个进程都有自己独自的一份虚拟地址空间）</p><p>CPU是只能识别PCB的，但是他无法区分进程还是线程。所以Linux当中CPU看到的一个进程相当于一个轻量级进程（&lt;=一个标准的进程(一个执行流的进程)）</p><p>Linux下没有一份真正意义的进程。使用进程模拟线程。</p><p>TCB ThreadContrlClock 线程控制块</p> <a id="more"></a><h2 id="2-线程的资源"><a href="#2-线程的资源" class="headerlink" title="2.线程的资源"></a>2.线程的资源</h2><ul><li><strong>私有资源</strong></li></ul><ol><li>上下文信息</li><li>线程ID</li><li>一组寄存器</li><li>线程栈</li><li>erro</li><li>信号屏蔽字</li><li>调度优先级</li></ol><ul><li><strong>共享资源</strong></li></ul><ol><li>同有个地址空间</li><li>文件描述符</li><li>每种处理信号处理方式（忽略，默认，自定义）</li><li>当前工作目录</li><li>用户id和组id</li></ol><h3 id="3-线程优点"><a href="#3-线程优点" class="headerlink" title="3.线程优点"></a>3.线程优点</h3><ul><li>创建线程比创建一个进程代价小</li><li>与进程之间切换相比，线程之间的切换需要操作系统的工作小的多</li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速IO操作的同时，程序可以执行其他任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>IO密集型应用，为了提高性能，将IO操作重叠。线程可以同时等待不同IO操作</li></ul><h2 id="4-线程缺点"><a href="#4-线程缺点" class="headerlink" title="4.线程缺点"></a>4.线程缺点</h2><ul><li>性能损失<ul><li>一个很少被外部事件阻塞的计算密集型线程往往⽆无法与共它线程共享同⼀一个处理器。如 果计算密集型线程的数量⽐比可⽤用的处理器多，那么可能会有较⼤大的性能损失，这⾥里的性 能损失指的是增加了额外的同步和调度开销，⽽而可⽤用的资源不变。</li></ul></li></ul><ul><li><p>健壮性降低</p><ul><li>编写多 程需要更全⾯面更深⼊入的考虑，在一个多线程程序⾥里，因时间分配上的细微偏差 或者因共享了不该共享的变量⽽而造成不良影响的可能性是很⼤大的，换句话说线程之间是 缺乏保护的。</li></ul></li><li><p>缺乏访问控制</p><ul><li>进程是访问控制的基本粒度，在⼀一个线程中调⽤用某些OS函数会对整个进程造成影响</li></ul></li><li><p>编程难度提高</p></li></ul><h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="1-POSIX线程库"><a href="#1-POSIX线程库" class="headerlink" title="1.POSIX线程库"></a>1.POSIX线程库</h2><ul><li>与线程有关的函数构成了⼀一个完整的系列，绝⼤大多数函数的名字都是以“pthread_”打头的 </li><li>引入头文件</li><li>链接这些线程库时要使用编译命令”-lpthread”选项</li></ul><p><strong>在Linux查看正在运行的线程</strong> </p><p><strong><code>ps -aL</code></strong></p><h1 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h1><p>mutex(互斥量)</p><ul><li>大部分情况，线程使用的数据都是局部变量，变量的地址空间在线程的栈空间内，这种情况，变量的归属单个线程，其他线程无法获取这种变量</li><li>但是有的时候，很多变量都需要线程共享，这样的变量称为共享变量，可以通过数据的共享，完成线程之间的交互</li><li>多个线程并发操作共享变量，会带来一些问题。</li></ul><p>通常情况下同步是要互斥为前提的，同步可以保证多个执行流按照特定有效的顺序去访问临界资源。</p><p><strong>总结：</strong>互斥了解决数据的二义性问题，安全性，正确性问题。</p><p>同步互斥可以让多个线程，多个进程之间可以协同工作。</p><h2 id="1-互斥锁（mutex）"><a href="#1-互斥锁（mutex）" class="headerlink" title="1.互斥锁（mutex）"></a>1.互斥锁（mutex）</h2><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作共享变量会有问题的售票系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> * <span class="title">buyTicket</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> * thread = (<span class="keyword">char</span>*) arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             usleep(<span class="number">1000</span>);</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%s get a ticket ,num:%d\n"</span>,thread,tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%s quit!\n"</span>,thread);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1,t2,t3,t4;</span><br><span class="line">    pthread_create(&amp;t1,<span class="literal">NULL</span>,buyTicket,(<span class="keyword">void</span> *)<span class="string">"thread 1"</span>);</span><br><span class="line">    pthread_create(&amp;t3,<span class="literal">NULL</span>,buyTicket,(<span class="keyword">void</span> *)<span class="string">"thread 3"</span>);</span><br><span class="line">    pthread_create(&amp;t4,<span class="literal">NULL</span>,buyTicket,(<span class="keyword">void</span> *)<span class="string">"thread 4"</span>);    </span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t3,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t4,<span class="literal">NULL</span>);                                                                                                                             </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁后 互斥</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ticket = <span class="number">100</span>; <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">route</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">char</span> *id = (<span class="keyword">char</span>*)arg;    </span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);        </span><br><span class="line">        <span class="keyword">if</span> ( ticket &gt; <span class="number">0</span> ) &#123;           </span><br><span class="line">            usleep(<span class="number">1000</span>);            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s sells ticket:%d\n"</span>, id, ticket);           </span><br><span class="line">            ticket--;            </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);            <span class="comment">// sched_yield(); 放弃CPU       </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);            </span><br><span class="line">            <span class="keyword">break</span>;       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2, t3, t4;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, route, <span class="string">"thread 1"</span>);    </span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, route, <span class="string">"thread 2"</span>);   </span><br><span class="line">    pthread_create(&amp;t3, <span class="literal">NULL</span>, route, <span class="string">"thread 3"</span>);   </span><br><span class="line">    pthread_create(&amp;t4, <span class="literal">NULL</span>, route, <span class="string">"thread 4"</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_join(t3, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_join(t4, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutex锁必须先初始化，互斥锁用完后，必须删除互斥锁</p><p>锁的初始化</p><ul><li>静态初始化</li></ul><p><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code></p><ul><li><p>动态初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> pthread_mutexattr <span class="keyword">_t</span> *<span class="keyword">restrict</span> attr)</span></span>;    参数：        mutex：要初始化的互斥量        attr：<span class="literal">NULL</span>`</span><br></pre></td></tr></table></figure><p>销毁互斥量 </p><p>销毁互斥量需要注意： </p><ul><li><p>使⽤用PTHREAD_ MUTEX_ INITIALIZER初始化的互斥量不需要销毁 </p></li><li><p>不要销毁⼀一个已经加锁的互斥量 </p></li><li><p>已经销毁的互斥量，要确保后⾯面不会有线程再尝试加锁</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex)；</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>互斥量加锁和解锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 返回值:成功返回0,失败返回错误号</span><br></pre></td></tr></table></figure><blockquote><p>调⽤用pthread_ lock 时，可能会遇到以下情况: 互斥量处于未锁状态，该函数会将互斥量锁定，同时返回成功 发起函数调⽤用时，其他线程已经锁定互斥量，或者存在其他线程同时申请互斥量，但没有竞争到互 斥量，那么pthread_ lock调⽤<strong>会陷⼊入阻塞，等待互斥量解锁。</strong> </p></blockquote><p><strong>trylock：非阻塞式获取锁</strong></p><p><strong>总结：</strong></p><p><strong>锁本身是临界资源</strong>，但是申请锁的操作是原子性的。所以才可以使用锁保护临界资源。</p><h1 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h1><blockquote><ul><li>当一个线程互斥地访问某个变量时，它可能发现在其他线程状态改变值之前，它什么也做不了。</li><li>例如一个线程访问队列时，发现队列为空，它只能等待，只到其它线程将一个节点添加到队列中。 这种情况就需要⽤用到条件变量。</li></ul></blockquote><h1 id="生产消费者"><a href="#生产消费者" class="headerlink" title="生产消费者"></a>生产消费者</h1><p>分析：</p><p>生产者生产者之间的关系—互斥关系（不能共享）</p><p>生产者消费者之间的关系—互斥关系，同步关系</p><p>消费者消费者之间的关系—互斥关系（不能共享）</p><p><strong>交易场所：超市</strong></p><p>321原则： 3种关系，2个角色，1 个交易场所</p>]]></content>
      
      
      <categories>
          
          <category> -Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-javaIO</title>
      <link href="/2019/01/06/14-javaIO/"/>
      <url>/2019/01/06/14-javaIO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java高级开发之JavaIO"><a href="#Java高级开发之JavaIO" class="headerlink" title="Java高级开发之JavaIO"></a>Java高级开发之JavaIO</h1><p>IO部分的重点：五个类（File、OutputStream、InputStream、Reader、Writer）一个接口（Serializable）</p><h1 id="1-File文件操作类"><a href="#1-File文件操作类" class="headerlink" title="1.File文件操作类"></a>1.File文件操作类</h1><p>在java.io包中，File类是唯一一个与文件本身操作（创建，删除，取得信息）有关的程序类</p><h2 id="1-1File类的基本使用"><a href="#1-1File类的基本使用" class="headerlink" title="1.1File类的基本使用"></a>1.1File类的基本使用</h2><p>java.io.File类是一个普通的类，直接产生实例化对象即可，两个构造方法如下：</p><blockquote><p>public File(String pathname);</p><p>public File(String parent,String child); //设置父路径和子类</p></blockquote><p>如果要进行文件的基本操作，可以使用FIle类的如下方法；</p><blockquote><p>创建一个新文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOExcepotion</span></span><br></pre></td></tr></table></figure><blockquote><p>判断一个文件是否存在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> bollean <span class="title">exists</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>由于java具有跨平台特性但是，在实际项目部署环境可能与开发环境不同.那么这个时候路径的问题就很麻烦。Windows下面使用的是“\”,而Unix系统下使用的是“/”。所以使用路径分隔符时都会采用File类的一个常量”<code>public static final String separator</code>“来描述</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JavaSE基础 -Java学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-视图</title>
      <link href="/2019/01/06/12-%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/01/06/12-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="12-视图"><a href="#12-视图" class="headerlink" title="12.视图"></a>12.视图</h1><p>MySQL5添加了对视图的支持。</p><p>视图是一个<strong>虚拟的表</strong>。其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。<strong>视图的数据变化会影响到基表，基表的数据变化也会影响到视图。</strong></p><p>视图可以把查询包装成一个虚拟表（临时表），方便检索。</p><a id="more"></a><h2 id="12-1使用视图的作用"><a href="#12-1使用视图的作用" class="headerlink" title="12.1使用视图的作用"></a>12.1使用视图的作用</h2><blockquote><ul><li><strong>重用SQL语句</strong></li><li><strong>简化复杂的SQL操作。在编写查询后，可以方便地重新利用而不必知道它地基本查询细节</strong></li><li><strong>使用表地组成部分而不是整个表</strong></li><li><strong>保护数据。可以给用户授予表地特定部分的访问权限而不是整个表的访问权限。</strong>(提高安全性)</li><li><strong>更改数据格式和表。视图可以返回与底层表的表示和格式不同的数据。</strong></li></ul></blockquote><p>在视图创建后，可以利用与表基本相同的方式利用他们。可以对视图执行select操作，过滤和排序数据，将视图联结到其他视图或者表，甚至能添加更新操作（添加更新数据存在某种限制）</p><h3 id="12-1-2视图带来的性能问题"><a href="#12-1-2视图带来的性能问题" class="headerlink" title="12.1.2视图带来的性能问题"></a>12.1.2视图带来的性能问题</h3><p>因为视图本省不包含数据，所以每次检索使用视图时，都必须处理查询执行时所需的任一个检索。如果你用了多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降的很厉害。因此在部署使用了大量视图的应用前，应该进行测试。</p><h2 id="12-2视图的规则和限制"><a href="#12-2视图的规则和限制" class="headerlink" title="12.2视图的规则和限制"></a>12.2视图的规则和限制</h2><ul><li>与表名相同，视图也需要唯一名称</li><li>对于可以创建的视图数目没有限制</li><li>对于创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予</li><li>视图可以像表一样嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图</li><li>order by可以用在视图中，但是如果从该视图检索数据的select语句也包含order by,那么该视图中的order by将被覆盖。</li><li>视图不能索引[^1]，也不能有关联的触发器[^2]或默认值。</li></ul><p>[^1]: 视图是一张临时表（存储引擎 myisam） 不能有主键<br>[^2]: view procedure  ,trigger(触发器)：会监听 一些update 等 相当于一个切面</p><ul><li><p>视图可以和表一起使用，例如，编写一条联结表和视图的select语句。 </p><p>​                                                                          `</p></li></ul><h2 id="12-3视图使用"><a href="#12-3视图使用" class="headerlink" title="12.3视图使用"></a>12.3视图使用</h2><ul><li>创建视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名 as select 语句</span><br></pre></td></tr></table></figure><ul><li>查看创建视图的语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create view 视图名</span><br></pre></td></tr></table></figure><ul><li>删除视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名</span><br></pre></td></tr></table></figure><ul><li>更新视图</li></ul><blockquote><p>可以先用<code>drop</code>再用<code>create</code>，也可以直接用<code>create or replace view</code><br>如果要更新的视图不存在，则第二条更新语句就会创建一个新的视图；<br>如果要更新的视图存在；则第二条根更新的语句会替代原有视图。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view v_ename_dname as select ename,dname from emp,dept where emp.deptno = dept.deptno;</span><br><span class="line">Query OK, 0 rows affected (0.25 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_scott |</span><br><span class="line">+-----------------+</span><br><span class="line">| dept            |</span><br><span class="line">| emp             |</span><br><span class="line">| exam            |</span><br><span class="line">| salgrade        |</span><br><span class="line">| stu             |</span><br><span class="line">| v_ename_dname   |</span><br><span class="line">+-----------------+</span><br><span class="line">6 rows in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  v_ename_dname;</span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| WARD   | SALES      |</span><br><span class="line">| JONES  | RESEARCH   |</span><br><span class="line">| MARTIN | SALES      |</span><br><span class="line">| BLAKE  | SALES      |</span><br><span class="line">| CLARK  | ACCOUNTING |</span><br><span class="line">| SCOTT  | RESEARCH   |</span><br><span class="line">| KING   | ACCOUNTING |</span><br><span class="line">| TURNER | SALES      |</span><br><span class="line">| ADAMS  | RESEARCH   |</span><br><span class="line">| JAMES  | SALES      |</span><br><span class="line">| FORD   | RESEARCH   |</span><br><span class="line">| MILLER | ACCOUNTING |</span><br><span class="line">+--------+------------+</span><br><span class="line">14 rows in set (0.12 sec)</span><br></pre></td></tr></table></figure><ul><li>修改了视图，对基表数据有影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">update v_ename_dname set dname=&apos;sales&apos;  where ename=&apos;CLARK&apos;; </span><br><span class="line">select * from EMP  where ename=&apos;CLARK&apos;;</span><br><span class="line">+--------+-------+---------+------+---------------------+---------+------+--------+</span><br><span class="line">| empno  | ename | job     | mgr  | hiredate            | sal     | comm | deptno |</span><br><span class="line">+--------+-------+---------+------+---------------------+---------+------+--------+</span><br><span class="line">| 007782 | CLARK | MANAGER | 7839 | 1981-06-09 00:00:00 | 2450.00 | NULL |     10 |</span><br><span class="line">+--------+-------+---------+------+---------------------+---------+------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| deptno | dname      | loc      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | sales      | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>修改了基表，。对视图也有影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update emp set deptno=20 where ename=&apos;james&apos;; -- 修改基表</span><br><span class="line">Query OK, 1 row affected (0.09 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from v_ename_dname where ename = &apos;james&apos;;</span><br><span class="line">+-------+----------+</span><br><span class="line">| ename | dname    |</span><br><span class="line">+-------+----------+</span><br><span class="line">| JAMES | RESEARCH |   &lt;-视图中的数据发生了变化</span><br><span class="line">+-------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>删除视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><h2 id="12-4利用视图简化更复杂的联结"><a href="#12-4利用视图简化更复杂的联结" class="headerlink" title="12.4利用视图简化更复杂的联结"></a>12.4利用视图简化更复杂的联结</h2><p>从上面的例子就可以看出，我再次从筛选出来的视图中查找时，就不需要再写where from 条件，直接使用视图即可。</p><blockquote><p>创建可重用的视图：创建不受特定数据限制的视图是一种好办法。扩展视图的范围不仅可以使得它能被重用，而且甚至更多有用。这样做不需要创建和维护多个类似视图</p></blockquote><h2 id="12-5用视图过滤不想要的数据"><a href="#12-5用视图过滤不想要的数据" class="headerlink" title="12.5用视图过滤不想要的数据"></a>12.5用视图过滤不想要的数据</h2><p>视图对应普通的where子句也很有用。</p><blockquote><p>where子句和where子句如果从检索数据时使用了一条where子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p></blockquote><h2 id="12-6使用视图与计算字段"><a href="#12-6使用视图与计算字段" class="headerlink" title="12.6使用视图与计算字段"></a>12.6使用视图与计算字段</h2><p>将用select 筛选出来的的计算字段的语句将筛选出来的结果作为视图用运用，简化SQL语句，便于查找。</p><h2 id="12-7更新视图（详解）"><a href="#12-7更新视图（详解）" class="headerlink" title="12.7更新视图（详解）"></a>12.7更新视图（详解）</h2><p>通常，视图是可以更新的（即，可以对视图 insert、update、delete）。更新一个视图将更新其基表，因为视图是一个虚拟表，其中并没有真实存在数据而只是select筛选出来的数据的整合成一个临时表而已。如果你对视图进行修改，则实际上是对其基表增加或删除，修改。</p><p>但是并非所有视图都是可以更新的。基本上说，如果MySQL不能正确地确定被更新的数据，则不允许更新（包括插入删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ul><li>分组（使用group by）;</li><li>联结；</li><li>子查询；</li><li><p>聚集函数（min()、count()、sum() 等）；</p></li><li><p>distinct;</p></li><li>导出（计算）列</li></ul><p>即视图基本不能进行更新，这不是一种严重的限制，其实视图主要用于数据检索的。</p><blockquote><p>一般，视图应该用于检索（select语句）而不是用于更新(insert,update和delete)。</p></blockquote><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>视图是一个虚拟的表。他们包含的不是数据而是根据需要检索出来的数据的查询。视图提供了一种MySQL的Select语句层次的封装，可以用来简化数据处理以及重新格式化基础数据或保护基础数据。</strong></p><ul><li>与表一样，必须唯一命名（不能出现同名视图或表名）</li><li>创建视图数目无限制，但要考虑复杂查询创建为视图之后的性能影响 </li><li>视图不能添加索引，也不能有关联的触发器或者默认值 </li><li>视图可以提高安全性，必须具有足够的访问权限 </li><li><code>order by</code> 可以用在视图中，但是如果从该视图检索数据 <code>select</code>中也含有 <code>order by</code> ,那么该视图中的 <code>order by</code> 将被覆盖 </li><li>视图可以和表一起使用</li></ul><h1 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h1><p><strong>牛客：针对actor表创建视图actor_name_view</strong></p><p><a href="https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&amp;&amp;tqId=29806&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener">牛客：针对actor表创建视图actor_name_view</a></p><p><strong>题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v：</span><br><span class="line">CREATE TABLE IF NOT EXISTS actor (</span><br><span class="line">actor_id smallint(5) NOT NULL PRIMARY KEY,</span><br><span class="line">first_name varchar(45) NOT NULL,</span><br><span class="line">last_name varchar(45) NOT NULL,</span><br><span class="line">last_update timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))</span><br></pre></td></tr></table></figure><p>分析：写视图就是先思考select语句即可</p><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view actor_name_view  as select first_name as first_name_v , last_name as last_name_v from actor;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-事务管理</title>
      <link href="/2019/01/05/11-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2019/01/05/11-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="11-事务管理"><a href="#11-事务管理" class="headerlink" title="11-事务管理"></a>11-事务管理</h1><p>事务就是一组DML语句组成，这些语句在逻辑上存在着相关性，这一组DML语句要么成功，要么全部失败，是一个整体。MySQL提供一种机制，保证我们达到这样的效果。事务还规定不同的客户端看到的数据是不相同的。</p><p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可保证一组操作不会中途停止，他们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销操作）以恢复数据库到某个已知且安全的状态。</p><a id="more"></a><p>基本术语：</p><blockquote><ul><li><strong>事务（transaction）指一组SQL语句；</strong></li><li><strong>回退（rollback）指撤销指定SQL语句的过程</strong></li><li><strong>提交（Commit）指将未储存的SQL语句结果写入数据库表；</strong></li><li><strong>保留点（savepoint）指事处理中设置的临界占位符（place-holder），你可以对它发布退回（与回退整个事务处理不同）</strong></li></ul></blockquote><h2 id="11-2-事务处理基本操作"><a href="#11-2-事务处理基本操作" class="headerlink" title="11.2  事务处理基本操作"></a>11.2  事务处理基本操作</h2><p>案例：</p><p>银行转账的例子更需要考虑事务问题。</p><ul><li><p>创建测试表</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table account(</span><br><span class="line">    -&gt; id int primary key,</span><br><span class="line">    -&gt; name varchar(50) not null default &apos;&apos;,</span><br><span class="line">    -&gt; balance decimal(10,2) not null default 0.0</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure></li><li><p>开始一个事务</p><p><code>start transaction</code>  <code>begin</code></p></li><li><p>创建一个保存点</p><p><code>savepoint 保存点名</code></p></li><li><p>回到保存点（根据具体情况）</p><p><code>rollback to 保存点名</code> <code>release savepoint</code></p></li><li><p>提交结束当前事务</p><p><code>commit;</code> <code>rollback</code></p></li><li><p>代码演示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; -- 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint aa; -- 设置保存点aa</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(1,&apos;张三&apos;,10); --添加一条存款记录</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint bb; -- 设置保存点bb</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(2,&apos;李四&apos;，100000)； -- 再添加一条记录</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(2,&apos;李四&apos;,100000); -- 再添加一条存款记录</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; -- 两条记录都在</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">| id | name   | balance   |</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">|  1 | 张三   |     10.00 |</span><br><span class="line">|  2 | 李四   | 100000.00 |</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback to bb;  -- 发现后来添加这一条记录是误操作。所以回滚到bb状态 </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; -- 第二条记录没了</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 张三   |   10.00 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-2事务处理注意事项"><a href="#11-2事务处理注意事项" class="headerlink" title="11.2事务处理注意事项"></a>11.2事务处理注意事项</h2><ul><li><p>如果没有设置保存点，也可以回滚，只是回滚到事务的开始。直接使用 rollback(前提事务还没有提交)</p></li><li><p>如果一个事务被提交了（Commit）,则不可以回退（rollback）</p></li><li><p>可以选择回退到哪一个保存点</p></li><li><p>innnoDB支持事务，MyISAM不支持事务</p></li><li><p>开始事务 start transaction</p></li><li><p>rollback只能在一个事务处理内使用（在执行一条start transaction命令之后）</p></li></ul><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips:"></a>小tips:</h3><blockquote><p><strong>事务处理用来管理insert,update和delete语句，不能回退select,create,drop语句，如果你执行回退，他们不会被撤销。</strong>DDL语句和隐式修改MySQL构架的语句：<code>set password</code> ,<code>create user</code>…</p><p>管理语句：<code>cache index</code> <code>load indeex</code>  <code>analyze table</code>…</p></blockquote><h2 id="11-3使用Commit"><a href="#11-3使用Commit" class="headerlink" title="11.3使用Commit"></a>11.3使用Commit</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交(implicit commot)，即提交（写或保存）操作就是自动进行的。</p><p>但是在事务处理块中，提交不会隐含地进行。为进行明确地提交，使用commit语句。commit语句后当前事务就已经结束了，在事务中保存地回退点就不再存在了。</p><p>【以下仅个人理解】</p><p>可以这样理解事务地执行过程，开始一个事务后所有的SQL语句（insert，delete,update）执行的结果都在内存中保存并未真实的写入物理磁盘中（文件），一个回退点就相当标记当前时刻临时表中（内存）的状态，当执行回退时，就像栈一样的之前的语句从语句栈中弹出，返回表的回退点的状态。</p><p><strong>当commit执行后，或者rollback语句执行后事务回关闭。</strong>将内存中的有效SQL语句对应表写回物理磁盘中表（文件）  【<strong>此处的rollback语句并非是<code>rollback to 回退点</code>语句，回滚的回退点的语句并不能真正结束事务，还需显示的调用commit 或 rollback语句</strong>】</p><p><strong>当一个事务中某行语句执行出错时，commit之前的一条语句，则自动回退到执行错误语句的前面且事务并没有被提交，假如再使用<code>start transaction</code>则会提交之前的事务，开始新的事务。</strong></p><h3 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips:"></a>小Tips:</h3><blockquote><p>隐含事务关闭：当commit执行后，或者rollback语句执行后事务回关闭，事务回自动关闭（将来的更改将会隐式的提交）</p></blockquote><h2 id="11-4使用保留点"><a href="#11-4使用保留点" class="headerlink" title="11.4使用保留点"></a>11.4使用保留点</h2><p>简单的rollback和commit语句就可以写入或撤回整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。</p><p>回退点<code>savepoint 回退点名称</code> ，如果重复使用回退点的名称，则覆盖新的回退点。</p><p><strong>释放保留点</strong>：<code>rollback to 保留点名称</code> 、release savepoint(MySQL 5以来)</p><h2 id="11-5更改默认的提交行为"><a href="#11-5更改默认的提交行为" class="headerlink" title="11.5更改默认的提交行为"></a>11.5更改默认的提交行为</h2><p>默认MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上就是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br></pre></td></tr></table></figure><p>autocommit标志决定是否自动提交更改，不管有没有commit语句。设置autocommit 为（假 0）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p><blockquote><p>改标志autocommit针对每一个连接而不是服务器的。</p></blockquote><h2 id="11-6-事务的隔离级别"><a href="#11-6-事务的隔离级别" class="headerlink" title="11.6 事务的隔离级别"></a>11.6 事务的隔离级别</h2><p>当我们有多个客户端同时操作数据库的某张表，如何进行隔离操作？MySQL提供了个隔离级别</p><p>当MySQL表被多个线程或者客户端开启各自事务操作数据库中的数据库时，MySQL提供了一种机制，可以让不同的事务操作数据时，具有隔离性。从而保证数据的一致性。</p><h3 id="11-6-1无隔离性的带来问题"><a href="#11-6-1无隔离性的带来问题" class="headerlink" title="11.6.1无隔离性的带来问题"></a>11.6.1无隔离性的带来问题</h3><p>1.脏读</p><p>是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交数据中，这时，另外事务也访问这个数据，然后使用了这个不是最新的数据。</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Mary的原工资为1000，财务人员将Mary的工资改为8000（但未提交事务）</span><br><span class="line">2.Mary读取自己的工资，发现自己的工资变为8000，很开心！</span><br><span class="line">3.而财务发现自己操作有误，回滚了事务，Marry工资变为了1000，Marry读到的工资数8000是一个脏数据。</span><br><span class="line">解决:在事务修改完成并提交后才可以读取到数据，则可避免该问题</span><br></pre></td></tr></table></figure><p>2.不可重复读</p><p>是指一个事务内，多次读同一数据。在这个事务还没结束时，另外一个事务也访问该同一数据。那么，在第一个事务中两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据有可能不一样。这样读发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复度。（即不读到相同的数据内容）</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在事务1中，Marry读取到自己工资为1000，操作并没有完成。</span><br><span class="line">2.在事务2中，这时财务人员修改了Marry的工资为2000，并提交事务。</span><br><span class="line">3.在事务1中，Marry再次读取到自己的工资时，工资变了2000</span><br><span class="line">解决方法：在事务修改完成并提交后才可以读取到数据，则可避免该问题</span><br></pre></td></tr></table></figure><p>3.幻读</p><p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改设计到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入了一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就像发生了幻觉一样。</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目前工资为1000的员工有10人。   </span><br><span class="line">1.事务1,读取所有工资为1000的员工。    </span><br><span class="line">2.这时事务2向employee表插入了一条员工记录，工资也为1000    </span><br><span class="line">3.事务1再次读取所有工资为1000的员工 共读取到了11条记录，          </span><br><span class="line">解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题</span><br></pre></td></tr></table></figure><p><strong>备注</strong>：不可重复读的<strong>重点是修改</strong>：同样的条件, 你读取过的数据,再次读取出来发现值不一样了 幻读的重点在 于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样</p><h3 id="11-6-2事务的隔离级别"><a href="#11-6-2事务的隔离级别" class="headerlink" title="11.6.2事务的隔离级别"></a>11.6.2事务的隔离级别</h3><table><thead><tr><th>隔离级别</th><th style="text-align:left">脏读</th><th style="text-align:left">不可重复读</th><th style="text-align:left">幻读</th><th style="text-align:left">加锁读</th></tr></thead><tbody><tr><td></td><td style="text-align:left">1修改未提交2读1回滚2读</td><td style="text-align:left">1读2修改提交1再读</td><td style="text-align:left">1读2增加3读（发现多了一条数据）</td><td style="text-align:left"></td></tr><tr><td>读未提交(read uncommitter）</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>读已提交(read committed)</td><td style="text-align:left">✖</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>可重复读(repeatable read)</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>可串行化读(serializable)</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">加锁</td></tr></tbody></table><ul><li>设置事务的隔离级别</li></ul><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><ul><li>查看当前隔离级别：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>隔离级别：客串行化例子：</li></ul><ol><li>当客户端A在执行select过程中（还没有提交结束事务），DBMS会对库加锁，如果这时客户端B执行插入，只要还没释放锁，插入不进去，会将B的update语句放入阻塞队列，直到释放了锁或超时。</li></ol><blockquote><p><strong>说明：mysql默认的隔离级别是可重复读，一般情况下不要修改，修改完后一定要修改回去，要不然就会一直保持直到关闭客户端。</strong></p></blockquote><h2 id="11-7事务的ACID特性"><a href="#11-7事务的ACID特性" class="headerlink" title="11.7事务的ACID特性"></a>11.7事务的ACID特性</h2><ul><li><strong>原子性（Atomicity）</strong></li></ul><p>事务是应用中最小的执行单位，具有不可再分的特征，事务是应用中不可再分的最小逻辑执行体。</p><ul><li><strong>一致性（Consistency</strong>）</li></ul><p>事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务成功提交的结果 时，数据库处于一致性状态。如果系统运行发生中断，某个事务尚未完成而被迫中断，而改未完成的事务对数据库 所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过原子性来保证的。</p><ul><li><strong>隔离性（lsolation）</strong></li></ul><p>各种事务的执行互不干扰，任意一个事务的内部操作对其他并发事务都是隔离的。也就是说，并发执行的事务之间不能看到对方的中间状态。并发执行的事务之间不能互相影响。</p><ul><li><strong>持久性（Durability）</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库所做的改变都要记录到永久存储其中（如：磁盘）。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-索引特性</title>
      <link href="/2019/01/04/10-%E7%B4%A2%E5%BC%95%E7%89%B9%E6%80%A7/"/>
      <url>/2019/01/04/10-%E7%B4%A2%E5%BC%95%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="10索引特性（重点-）"><a href="#10索引特性（重点-）" class="headerlink" title="10索引特性（重点**）"></a>10索引特性（重点**）</h1><p>索引：提高数据库的性能，索引是物美价廉的东西。不用增加内存，不用该程序，不用调sql ,只要执行正确的<code>create index</code>，查询 ==速度== 就能提高成百上千倍。但是查速度的提高是以插入，更新，删除的速度为代价的，这些写操作，增加了大量的IO。所以它的价值，在于提高==海量数据的键锁速度==。</p><p><strong>常见索引分为：</strong></p><ul><li>主键索引（primary key)</li><li>唯一键索引（unique）</li><li>普通索引 (index)</li><li>全文索引（fulltext）–解决中文索引问题</li></ul><p><strong>索引部分目前只做简单学习，下来将索引部分详细研究后再对本篇博客做补充。</strong></p><a id="more"></a><p><strong>练习</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- 构建一个8000000条记录的数据 --构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解</span><br><span class="line"> </span><br><span class="line">-- 产生随机字符串 </span><br><span class="line">delimiter $$ </span><br><span class="line">create function rand_string(n INT) </span><br><span class="line">returns varchar(255) </span><br><span class="line">begin  </span><br><span class="line">declare chars_str varchar(100) default   &apos;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&apos;; </span><br><span class="line">declare return_str varchar(255) default &apos;&apos;; </span><br><span class="line">declare i int default 0; </span><br><span class="line">while i &lt; n do    </span><br><span class="line">set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));   set i = i + 1;   </span><br><span class="line">end while;  </span><br><span class="line">return return_str;  </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">--产生随机数字 delimiter $$ </span><br><span class="line">create function rand_num() </span><br><span class="line">returns int(5) </span><br><span class="line">begin  </span><br><span class="line">declare i int default 0; </span><br><span class="line">set i = floor(10+rand()*500); </span><br><span class="line">return i; </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">--创建存储过程，向雇员表添加海量数据 </span><br><span class="line">delimiter $$ </span><br><span class="line">create procedure insert_emp(in start int(10),in max_num int(10))</span><br><span class="line">begin </span><br><span class="line">declare i int default 0;  </span><br><span class="line">set autocommit = 0;   </span><br><span class="line">repeat  set i = i + 1;  </span><br><span class="line">insert into EMP values ((start+i) ,rand_string(6),&apos;SALESMAN&apos;,0001,curdate(),2000,400,rand_num());  </span><br><span class="line">until i = max_num </span><br><span class="line">end repeat; </span><br><span class="line">commit; </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> -- 执行存储过程，添加8000000条记录 </span><br><span class="line"> call insert_emp(100001, 8000000);</span><br></pre></td></tr></table></figure><p>目前没有进行mysql sql编程的经验，以下只做这几点的概述。</p><p>关于<code>delimiter $$</code>的意思</p><blockquote><p>将分隔符； 临时性的改为$$  防止在函数中出现” ; “会导致直接执行。<code>用完后改回来。delimiter ;</code></p></blockquote><p>建立处海量数据的表（8000000条数据）</p><ul><li><p>查询员工编号为9998877的员工，MySQL会从第一条数据开始遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp whrer empno=998877;</span><br></pre></td></tr></table></figure><p>耗时4.93秒（耗时时间跟储存介质即电脑中储存mysql数据的硬盘有关），在实际项目中，本机是由一个人来操作的，假如放到公网中，同时又10000个人并发查询，则就可能引起死机</p><p><strong>解决办法：</strong>创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add index(empno);</span><br></pre></td></tr></table></figure><p>耗时0.1秒都不到大大加快了查询速度，但是创建索引的过程还是耗时挺久的4秒左右。</p><p>粗略估计增加了快500倍。</p></li></ul><h2 id="10-1查询过程中的基本原理"><a href="#10-1查询过程中的基本原理" class="headerlink" title="10.1查询过程中的基本原理"></a>10.1查询过程中的基本原理</h2><ul><li><p>没有索引时：执行<code>select * from emp whrer empno=998877;sql语句是对这张存有海量数据的表进行整表的查询</code></p></li><li><p>而增加索引，会让表中数据形成一棵树（MySQL 中默认引擎innodb是形成一颗B+树）影响查询速度的是<strong>树的深度</strong></p><p>B+树 是 普通二叉树的升级版，减少了树的深度。</p><p>B+Tree：详解</p><p><a href="https://zhuanlan.zhihu.com/p/24309634" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24309634</a></p></li></ul><h2 id="10-2创建索引"><a href="#10-2创建索引" class="headerlink" title="10.2创建索引"></a>10.2创建索引</h2><h3 id="10-2-1创建主键索引"><a href="#10-2-1创建主键索引" class="headerlink" title="10.2.1创建主键索引"></a>10.2.1创建主键索引</h3><ul><li><p>第一种方式：</p><p>==在创建表的时候，直接在字段名后面直接指定<code>primay key</code>==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(30)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第二种方式</p><p>==在创建表最后，指定某列或者几列为主键索引==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>第三种方式：</p><p>==创建表之后再添加主题==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ccreate table  user3(</span><br><span class="line">    id int, </span><br><span class="line">    name varchar(30)</span><br><span class="line">); </span><br><span class="line">-- 创建表以后再添加主键 </span><br><span class="line">alter table user3 add primary key(id);</span><br></pre></td></tr></table></figure></li></ul><p><strong>主键索引的特点</strong>：</p><ul><li>一个表中，最多有一个主键索引，当然可以使复合主键 </li><li>主键索引的效率高（主键不可重复） </li><li>创建主键索引的列，它的值不能为null，且不能重复 </li><li>主键索引的列基本上是int</li></ul><h3 id="10-2-2唯一键的创建"><a href="#10-2-2唯一键的创建" class="headerlink" title="10.2.2唯一键的创建"></a>10.2.2唯一键的创建</h3><ul><li><p>第一种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 在表定义时，在某列后直接指定unique唯一属性。 </span><br><span class="line">create table user4(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30) unique</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第二种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表时，在表的后面指定某列或某几列为unique </span><br><span class="line">create table user5(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30), </span><br><span class="line">    unique(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第三种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user6(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30)</span><br><span class="line">）； </span><br><span class="line">-- </span><br><span class="line">alter table user6 add unique(name);</span><br></pre></td></tr></table></figure></li></ul><p><strong>唯一索引的特点：</strong></p><ul><li>一个表中，可以有多个唯一索引 </li><li>查询效率高 如果在某一列建立唯一索引，必须保证这列不能有重复数据 </li><li>==如果一个唯一索引上指定not null，等价于主键索引==</li></ul><h3 id="10-2-3-普通索引的创建"><a href="#10-2-3-普通索引的创建" class="headerlink" title="10.2.3 普通索引的创建"></a>10.2.3 普通索引的创建</h3><ul><li>第一种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table user8(id int primary key,     </span><br><span class="line">name varchar(20),     </span><br><span class="line">email varchar(30),     </span><br><span class="line">index(name) --在表的定义最后，指定某列为索引 </span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>第二种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user9(id int primary key,  name varchar(20),  email varchar(30)); </span><br><span class="line">alter table user9 add index(name); </span><br><span class="line">-- 创建完表以后指定某列为普通索引</span><br></pre></td></tr></table></figure></li><li><p>第三种方式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user10(id int primary key,  </span><br><span class="line">name varchar(20),  </span><br><span class="line">email varchar(30)</span><br><span class="line">); </span><br><span class="line">-- 创建一个索引名为 idx_name 的索引    </span><br><span class="line">create index idx_name on user10(name);</span><br></pre></td></tr></table></figure><p>普通索引的特点：</p><ul><li>一个表中可以有多个普通索引，普通索引在实际开发中用的比较多 </li><li>如果某列需要创建索引，==但是该列有重复的值==，那么我们就应该使用普通索引 </li></ul><h3 id="10-2-4全文索引"><a href="#10-2-4全文索引" class="headerlink" title="10.2.4全文索引"></a>10.2.4全文索引</h3><p>当文章字段或有大量文字的字段进行检索时，会使用到全文索引。MySQL提供全文索引机制。之前是只有在MyISAM引擎，现在innodb引擎也支持全文索引。但是默认支持的是英文，你不支持中文。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles (    </span><br><span class="line">id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,    </span><br><span class="line">title VARCHAR(200),    </span><br><span class="line">body TEXT,    </span><br><span class="line">FULLTEXT (title,body) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO articles (title,body) VALUES    </span><br><span class="line">(&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;),    </span><br><span class="line">(&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;),    </span><br><span class="line">(&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;),    </span><br><span class="line">(&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;),    </span><br><span class="line">(&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;),    </span><br><span class="line">(&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);</span><br></pre></td></tr></table></figure><ul><li>查询有没有’database‘数据</li></ul><p>如果使用如下方式查询，虽然查询出结果，但是没有用到全文索引.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from artices where body like &apos;%database%&apos;;</span><br><span class="line"></span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br></pre></td></tr></table></figure><p>可以使用explain工具看一下，是否使用到索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from articles where body like &apos;database&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE  -- ：简单查询</span><br><span class="line">        table: articles</span><br><span class="line">   partitions: NULL   -- possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</span><br><span class="line">         type: ALL    -- ：全表查询</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL   -- &lt;==key为null表示没有用到索引</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL    -- 显示索引的哪一列被使用了，如果可能的话，是一个常数</span><br><span class="line">         rows: 6       -- ：这个值是innodb预估的一个值(并不是是一个准确值)MYSQL认为必须检查的用来返回请求数据的行数</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><ul><li>全文索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select * from articles</span><br><span class="line">    -&gt; where match(title,body) against (&apos;database&apos;);</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">2 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure><p>通过explain来分析这个sql语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST (&apos;database&apos;)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: articles</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: fulltext  -- 全文索引</span><br><span class="line">possible_keys: title</span><br><span class="line">          key: title     -- &lt;=key 用到了title</span><br><span class="line">      key_len: 0</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>关于explain 分析后的结果参数内容含义解释如下：<a href="https://www.cnblogs.com/yycc/p/7338894.html" target="_blank" rel="noopener">https://www.cnblogs.com/yycc/p/7338894.html</a></p><h2 id="10-3查询索引"><a href="#10-3查询索引" class="headerlink" title="10.3查询索引"></a>10.3查询索引</h2><ul><li>第一种方法： <code>show key from 表明</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show keys from articles\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: articles  -- :表名</span><br><span class="line">   Non_unique: 0   -- 0表示唯一索引</span><br><span class="line">     Key_name: PRIMARY-- &lt;=主键索引</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id-- 索引在那里列</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE   ： -- 以二叉树形式的索引</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: articles</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: title</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: title</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: articles</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: title</span><br><span class="line"> Seq_in_index: 2</span><br><span class="line">  Column_name: body</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p>第二种方式：<code>show index from 表明;</code></p></li><li><p>第三种方式（信息比较简略）：<code>desc 表明：</code></p></li></ul><h2 id="10-4删除索引"><a href="#10-4删除索引" class="headerlink" title="10.4删除索引"></a>10.4删除索引</h2><ul><li>第一种方法-删除主键索引：<code>alter table 表明 drop primary key;</code></li><li>第二种方法-其他索引的删除： <code>alter table 表明 drop index 索引名; 索引名就是show keys from 表名种的key_name字段</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user10 drop index idx_name;</span><br></pre></td></tr></table></figure><ul><li>第三种方法方法：drop index 索引名 on 表名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index name on user10;</span><br></pre></td></tr></table></figure><h2 id="10-5索引创建原则"><a href="#10-5索引创建原则" class="headerlink" title="10.5索引创建原则"></a>10.5索引创建原则</h2><ul><li>比较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件（主要业务的要求）</li><li>更新非常频繁的字段不适合当作创建索引</li><li>不会出现在where子句中的字段不该创建索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-表的内外连接</title>
      <link href="/2019/01/03/09-%E8%A1%A8%E7%9A%84%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/01/03/09-%E8%A1%A8%E7%9A%84%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><strong>配合食用效果极佳 </strong></p><p><strong>内连接查询：</strong>往往使用频繁，可以配合多种查询方法食用。</p><p>内连接就是两表的笛卡儿积表的基础上进行筛选</p><p><strong>外连接查询：</strong>首先要确定<strong>基准表</strong>（<strong>基准信息</strong>），即左连接的左表，右连接的右表。然后确定<strong>结合表</strong>，结合表需要的筛选条件。</p><a id="more"></a><h1 id="09-表的内外连接"><a href="#09-表的内外连接" class="headerlink" title="09 表的内外连接"></a>09 表的内外连接</h1><h2 id="9-1内链接"><a href="#9-1内链接" class="headerlink" title="9.1内链接"></a>9.1内链接</h2><p>内连接实际上就是利用where子句对两种表形成的笛卡儿积进行筛选，我们前面学习的查询都是内连接，也是在开发过程中使用的最多的连接查询</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表1 inner join 表2 on 连接条件 and其他连接条件;</span><br></pre></td></tr></table></figure><blockquote><p>之前学的就是内连接</p></blockquote><p>显示smith的名字和部门名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 之前写法</span><br><span class="line">select ename,dename from emp,dept where emp.deptno=dept.deptno and ename=&apos;smith&apos;;</span><br><span class="line"></span><br><span class="line">-- 标准内连接写法</span><br><span class="line">select ename,dename from emp inner join dept on emp.deptno=dept.depyno and ename=&apos;smith&apos;;</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>inner join就是inner join两个表的笛卡儿积中筛选on 后的条件</p><h2 id="9-2外连接"><a href="#9-2外连接" class="headerlink" title="9.2外连接"></a>9.2外连接</h2><p>外连接分为左连接右连接。（记住一种自己熟悉的即可）</p><h3 id="9-2-1左外连接"><a href="#9-2-1左外连接" class="headerlink" title="9.2.1左外连接"></a>9.2.1左外连接</h3><p><strong>左外连接:</strong>  如果联合查询的时，左侧的表我们完全显示 </p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表名1 left join 表名2 on 连接条件</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>left join就是左表（一定显示）和右表中on后筛选后的表的结合（以左表为基础上添加（符合筛选条件的）右表）</p><h3 id="9-2-2右外连接"><a href="#9-2-2右外连接" class="headerlink" title="9.2.2右外连接"></a>9.2.2右外连接</h3><p><strong>右连接：</strong>如果联合查询，右侧的表完全显示我们就说是右外连接。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表明1 right join 表明2 on 连接条件</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>left join就是右表（一定显示）和左表中on后筛选后的表的结合（以右表为基础上添加（符合筛选条件的）左标）</p><p><strong>小练习：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 键两张表</span><br><span class="line">create table stu (id int, name varchar(30));  -- 学生表 </span><br><span class="line">insert into stu values(1,&apos;jack&apos;),(2,&apos;tom&apos;),(3,&apos;kity&apos;),(4,&apos;nono&apos;); </span><br><span class="line"></span><br><span class="line">create table exam (id int, grade int);  -- 成绩表</span><br><span class="line">insert into exam values(1, 56),(2,76),(11, 8);</span><br></pre></td></tr></table></figure><ul><li><p><strong>查询所有学生的成绩，如果没有这个学生的成绩，也要将学生的个人信息显示出来。</strong></p><p><strong>分析：</strong>关键字:所有学生， 成绩，（没有成绩也要显示出来） （<strong>以学生表为基准表，结合成绩表</strong>）外连接（左右都可以）</p><p><strong>左外连接：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu left inner exam on stu.id=exam.id;</span><br></pre></td></tr></table></figure><p>​    <strong>右外连接：</strong>（不适合，因为一般都是基准表在结合表的前面显示）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select stu.* from exam right inner stu on stu.id=exam.id;</span><br><span class="line"></span><br><span class="line">-- 改为：（太麻烦）</span><br><span class="line">select stu.id ,stu.name,exam.id,exam.grade from exam right join stu on stu.id=exam.id;</span><br></pre></td></tr></table></figure><ul><li><strong>对stu表和exam表联合查询，把所有的成绩都显示出来，即使这个成绩没有学生与它对应，也要显示出来</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu right join exam on stu.id=exam.id;</span><br></pre></td></tr></table></figure><ul><li><p><strong>列处部门名称和这些部门的员工信息，同时列出没有员工的部门</strong></p><p><strong>分析：</strong>关键字（部门名称，这些部分的员工信息，列出没有员工的部门）（<strong>以部门名称基准表，结合与员工表</strong>）外连接（左右都可以）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 方法一：</span><br><span class="line">select d.dname, e.* from dept d left join emp e on d.deptno=e.deptno; </span><br><span class="line">-- 方法二： </span><br><span class="line">select d.dname, e.* from emp e right join dept d on d.deptno=e.deptno;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p>内连接查询：往往使用频繁，可以配合多种查询方法食用。</p><p>内连接就是两表的笛卡儿积表的基础上进行筛选</p><p>外连接查询：首先要确定<strong>基准表</strong>（<strong>基准信息</strong>），即左连接的左表，右连接的右表。然后确定<strong>结合表</strong>，结合表需要的筛选条件。</p></blockquote><blockquote><p><strong>SQL</strong>查询中各个关键字的执行先后顺序：</p><p>from &gt; on&gt; join &gt; where &gt; group by &gt; with &gt; having &gt; select &gt; distinct &gt; order by &gt; limit</p></blockquote><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>1.<a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">178. 分数排名</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</span><br><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Create table If Not Exists Scores (Id int, Score DECIMAL(3,2))；</span><br><span class="line">Truncate table Scores</span><br><span class="line">insert into Scores (Id, Score) values (&apos;1&apos;, &apos;3.5&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;2&apos;, &apos;3.65&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;3&apos;, &apos;4.0&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;4&apos;, &apos;3.85&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;5&apos;, &apos;4.0&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;6&apos;, &apos;3.65&apos;)；</span><br></pre></td></tr></table></figure><p><strong>解答</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">a.Score as Score,</span><br><span class="line">count(*) as Rank</span><br><span class="line">from Scores a inner join (select distinct Score from Scores ) b </span><br><span class="line">where a.Score&lt;=b.Score</span><br><span class="line">group by a.id</span><br><span class="line">order by Rank;</span><br></pre></td></tr></table></figure><p>2.<a href="https://leetcode-cn.com/problems/exchange-seats/" target="_blank" rel="noopener">626. 换座位</a></p><p><strong>题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。</span><br><span class="line"></span><br><span class="line">其中纵列的 id 是连续递增的</span><br><span class="line"></span><br><span class="line">小美想改变相邻俩学生的座位。</span><br><span class="line"></span><br><span class="line">你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</span><br><span class="line"></span><br><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Abbot   |</span><br><span class="line">|    2    | Doris   |</span><br><span class="line">|    3    | Emerson |</span><br><span class="line">|    4    | Green   |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Doris   |</span><br><span class="line">|    2    | Abbot   |</span><br><span class="line">|    3    | Green   |</span><br><span class="line">|    4    | Emerson |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL练习复合查询</title>
      <link href="/2019/01/03/MySQL%E7%BB%83%E4%B9%A0%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/01/03/MySQL%E7%BB%83%E4%B9%A0%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p><strong>复合查询（重点）</strong></p><ul><li>函数得使用</li></ul><ul><li><p>多表查询</p></li><li><p>自连接</p></li><li><p>子查询</p></li></ul><a id="more"></a><h1 id="07-MySQL-函数"><a href="#07-MySQL-函数" class="headerlink" title="07-MySQL 函数"></a>07-MySQL 函数</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><blockquote><p>查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</p></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select length(&apos;10,A,B&apos;)-length(replace(&apos;10,A,B&apos;, &apos;,&apos; ,&apos;&apos;)) as cnt;</span><br></pre></td></tr></table></figure><h1 id="08-MySQL-复合查询"><a href="#08-MySQL-复合查询" class="headerlink" title="08-MySQL 复合查询"></a>08-MySQL 复合查询</h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><blockquote><p>查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, s.salary from employees as e, salaries as s where e.emp_no =s.emp_no and e.hire_date = s.from_date order by e.emp_no desc;</span><br></pre></td></tr></table></figure><p><strong>解决2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, s.salary from employees as e inner join salaries as s on e.emp_no = s.emp_no and e.hire_date = s.from_date order by e.emp_no desc;</span><br></pre></td></tr></table></figure><h2 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2.题目描述"></a>2.题目描述</h2><blockquote><p>针对库中的所有表生成select count(*)对应的SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; create table emp_bonus(</span><br><span class="line">&gt; emp_no int not null,</span><br><span class="line">&gt; recevied datetime not null,</span><br><span class="line">&gt; btype smallint not null);</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_emp` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;select count(*) from &apos;,t.TABLE_NAME,&apos;;&apos;) AS cnts  from (select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database()) t;</span><br></pre></td></tr></table></figure><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;select count(*) from &quot;||name||&quot;;&quot; as cnts  from sqlite_master where type=&apos;table&apos;</span><br></pre></td></tr></table></figure><h2 id="3-题目描述"><a href="#3-题目描述" class="headerlink" title="3.题目描述"></a>3.题目描述</h2><blockquote><p>获取所有非manager的员工emp_no</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no from employees as e left join dept_manager as d on e.emp_no =d.emp_no where d.dept_no is null</span><br></pre></td></tr></table></figure><h2 id="4-题目描述"><a href="#4-题目描述" class="headerlink" title="4.题目描述"></a>4.题目描述</h2><blockquote><p>获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。<br>结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_emp` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, m.emp_no as manager_no from dept_emp as e inner join dept_manager as m on e.dept_no = m.dept_no where e.to_date = &apos;9999-01-01&apos; and m.to_date = &apos;9999-01-01&apos; and e.emp_no != m.emp_no;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
            <tag> MySQL数据库练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL练习</title>
      <link href="/2019/01/02/MySQL%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/01/02/MySQL%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>MySQL基本查询得练习（基础部分）</strong></p><p>MySQL学习得关键多连多练多练！！！</p><a id="more"></a><h1 id="MySQL小练"><a href="#MySQL小练" class="headerlink" title="MySQL小练"></a>MySQL小练</h1><h2 id="06-MySQL基本查询"><a href="#06-MySQL基本查询" class="headerlink" title="06-MySQL基本查询"></a>06-MySQL基本查询</h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><blockquote><p>对于表actor批量插入如下数据<br>`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE  IF NOT EXISTS actor  (`</span><br><span class="line">&gt; `actor_id  smallint(5)  NOT NULL PRIMARY KEY,`</span><br><span class="line">&gt; `first_name  varchar(45) NOT NULL,`</span><br><span class="line">&gt; `last_name  varchar(45) NOT NULL,`</span><br><span class="line">&gt; `last_update  timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))`</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into actor(actor_id,first_name,last_name,last_update) values</span><br><span class="line">(1,&apos;PENELOPE&apos;,&apos;GUINESS&apos;,&apos;2006-02-15 12:34:33 &apos;),</span><br><span class="line">(2,&apos;NICK&apos;,&apos;WAHLBERG&apos;,&apos;2006-02-15 12:34:33&apos;);</span><br></pre></td></tr></table></figure><h3 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2. 题目描述"></a>2. 题目描述</h3><blockquote><p>找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct salary from salaries where to_date = &apos;9999-01-01&apos; order by salary desc;</span><br></pre></td></tr></table></figure><h3 id="3-题目描述"><a href="#3-题目描述" class="headerlink" title="3. 题目描述"></a>3. 题目描述</h3><blockquote><p>查找最晚入职员工的所有信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt;  PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; **解答：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 1;</span><br></pre></td></tr></table></figure><h3 id="4-题目描述"><a href="#4-题目描述" class="headerlink" title="4. 题目描述"></a>4. 题目描述</h3><blockquote><p>查找入职员工时间排名倒数第三的员工所有信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 2,1;</span><br></pre></td></tr></table></figure><h3 id="5-题目描述"><a href="#5-题目描述" class="headerlink" title="5. 题目描述"></a>5. 题目描述</h3><blockquote><p>查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no , count(distinct salary) t from salaries group by emp_no having t&gt;15;</span><br></pre></td></tr></table></figure><h3 id="6-题目描述"><a href="#6-题目描述" class="headerlink" title="6. 题目描述"></a>6. 题目描述</h3><blockquote><p>获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dept_no, d.emp_no ,salary from salaries as s ,dept_manager as d </span><br><span class="line">where s.emp_no = d.emp_no </span><br><span class="line">and d.to_date = &apos;9999-01-01&apos; </span><br><span class="line">and s.to_date = &apos;9999-01-01&apos;;</span><br></pre></td></tr></table></figure><h3 id="7-题目描述"><a href="#7-题目描述" class="headerlink" title="7. 题目描述"></a>7. 题目描述</h3><blockquote><p>从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS &quot;titles&quot; (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `title` varchar(50) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date DEFAULT NULL);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title ,count(title) t from titles group by title having t&gt;=2;</span><br></pre></td></tr></table></figure><h3 id="8-LeetCode-182-查找重复的电子邮箱"><a href="#8-LeetCode-182-查找重复的电子邮箱" class="headerlink" title="8. LeetCode [182. 查找重复的电子邮箱]"></a>8. LeetCode [182. 查找重复的电子邮箱]</h3><blockquote><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Create table If Not Exists Person (</span><br><span class="line">&gt; Id int, </span><br><span class="line">&gt; Email varchar(255)</span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select Email from Person group by Email having count(Email)&gt;1;</span><br></pre></td></tr></table></figure><h3 id="9-LeetCode-595-大的国家"><a href="#9-LeetCode-595-大的国家" class="headerlink" title="9. LeetCode [595.大的国家]"></a>9. LeetCode [595.大的国家]</h3><blockquote><p>这里有张 <code>World</code> 表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt; | name            | continent  | area       | population   | gdp           |</span><br><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt; | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">&gt; | Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">&gt; | Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">&gt; | Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">&gt; | Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt; | name         | population  | area         |</span><br><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt; | Afghanistan  | 25500100    | 652230       |</span><br><span class="line">&gt; | Algeria      | 37100000    | 2381741      |</span><br><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>World表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; Create table If Not Exists World (</span><br><span class="line">&gt; </span><br><span class="line">&gt; name varchar(255), </span><br><span class="line">&gt; </span><br><span class="line">&gt; continent varchar(255), </span><br><span class="line">&gt; </span><br><span class="line">&gt; area int, </span><br><span class="line">&gt; </span><br><span class="line">&gt; population int,</span><br><span class="line">&gt; </span><br><span class="line">&gt; gdp int</span><br><span class="line">&gt; </span><br><span class="line">&gt; )；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name ,population,area from World where area&gt;3000000 or population&gt;25000000;</span><br></pre></td></tr></table></figure><h3 id="10-LeetCode-177-第N高薪水"><a href="#10-LeetCode-177-第N高薪水" class="headerlink" title="10. LeetCode[177.第N高薪水]"></a>10. LeetCode[177.第N高薪水]</h3><blockquote><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 <em>n</em> 高的薪水（Salary）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; +----+--------+</span><br><span class="line">&gt; | Id | Salary |</span><br><span class="line">&gt; +----+--------+</span><br><span class="line">&gt; | 1  | 100    |</span><br><span class="line">&gt; | 2  | 200    |</span><br><span class="line">&gt; | 3  | 300    |</span><br><span class="line">&gt; +----+--------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>例如上述 <code>Employee</code> 表，<em>n = 2</em> 时，应返回第二高的薪水 <code>200</code>。如果不存在第 <em>n</em> 高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; +------------------------+</span><br><span class="line">&gt; | getNthHighestSalary(2) |</span><br><span class="line">&gt; +------------------------+</span><br><span class="line">&gt; | 200                    |</span><br><span class="line">&gt; +------------------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  declare M Int;</span><br><span class="line">  Set M = N-1;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      select distinct Salary from Employee  order by Salary desc LIMIT M,1</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
            <tag> MySQL数据库练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/15/hello-world/"/>
      <url>/2018/05/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p><strong>博客开始2018</strong></p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

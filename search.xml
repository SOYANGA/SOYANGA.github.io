<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络基础(1)</title>
      <link href="/2019/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80(1)/"/>
      <url>/2019/01/16/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="网络基础（1）"><a href="#网络基础（1）" class="headerlink" title="网络基础（1）"></a>网络基础（1）</h1><p><strong>重点：</strong></p><ul><li>网络发展背景，对局域网/广域网的概念有基本认识</li><li>了解网络协议的意义，重点理解TCP/IP五层结构模型</li><li>网络传输的基本流程，理解封装和分用</li></ul><h2 id="计算机网络背景"><a href="#计算机网络背景" class="headerlink" title="计算机网络背景"></a>计算机网络背景</h2><ul><li><p>在同一个局域网内两台主机是可以直接通信的。</p></li><li><p>任何一个在局域网上的主机，在不欠运营费的情况下是可以访问公网下的任意一台主机的。</p></li><li><p>不在同一个局域网的主机可以通信的原因，通过公网这座桥梁读写操作。</p></li></ul><p><strong>网络发展</strong></p><p><strong>独立模式</strong>：计算机之间相互独立；分别计算数据，把数据加工处理完后又必须拷贝到另一台机器。</p><p><strong>机器传输数据之间是人工过程，太过繁琐</strong></p><p><strong>网络互联:</strong> 多台计算机连接在一起, 完成数据共享，<strong>冯诺依曼体系（系统) 是网络</strong>，只是连接线不同。</p><p>但是<strong>长距离传输数据容易丢失</strong>，而且传输速度慢。解决–<strong>TCP协议：解决数据安全，丢包问题</strong>。<strong>IP解决查找问题。</strong> </p><p><strong>局域网LAN:</strong> 计算机数量更多了, 通过交换机和路由器连接在一起，<strong>交换机：</strong>最低层对数据进行数据帧交换。 </p><p><strong>广域网WAN:</strong> 将远隔千里的计算机都连在一起</p><p><strong>所谓</strong> “局域网” 和 “广域网” 只是一个相对的概念. 比如, 我们有 “天朝特色” 的广域网, 也可以看做一个比较大的局域网。</p><a id="more"></a><h2 id="认识协议"><a href="#认识协议" class="headerlink" title="认识协议"></a>认识协议</h2><p>“协议是一种<strong>约定</strong>“ -<strong>多方遵守的协议（数据层面的相关约定）</strong> </p><p>快递例子：</p><p><strong>买洗面奶：</strong> </p><p>（卖家把洗面奶包装发个快递公司，快递公司把（准确）快递发给买家，买家需要拆包装）</p><p>​                                                             <strong>封装                       分用                                  解包</strong> </p><p><strong>协议保证数据正确性：</strong> 计算机之间的传输媒介是光电信号，通过”频率“和”强弱“来表示0和1这样的信息，要像传递各种不同信息，就需要约定好双方的数据格式。</p><p><strong>方言例子：</strong> </p><blockquote><ul><li>计算机生产商有很多；</li><li>计算机操作系统，也很多；</li><li>计算机网络硬件设备，还有很多；</li><li>如何让这些不同厂商之间生产的计算机能够相互顺畅的通信? 就需要有人站出来, 约定一个共同的标准, 大家都来遵守, 这就是 <strong>网络协议;</strong> </li></ul></blockquote><h2 id="网络协议初始"><a href="#网络协议初始" class="headerlink" title="网络协议初始"></a>网络协议初始</h2><p><strong>协议分层-网络协议栈</strong> <strong>-层状结构</strong>-<strong>（网络工程中）功能上相互独立，逻辑上解耦</strong></p><p> 打电话例子</p><p>为了让和我们更好的使用协议，认识协议。网络上会使用分层。</p><p><strong>原因：</strong>通信过程中，<strong>有相同语言</strong> （一层协议比如<strong>汉语</strong>）</p><p>​       语音通过电话之间的协议（无线电协议）进行传输，传输给电话另一端的人（实现人-人通话）</p><p>​       当我们通过座机通话时，我们人语言方式还不变但是中间协议变了（座机协议）</p><p>​        分层作用达到软件工程解耦作用，一层出故障不会影响下层。你说话结巴了电话通信也断断续续的？</p><p><strong>网络协议一定时层状的</strong>，<strong>一定是同层协议之间的通信，直接通信。</strong> </p><p> <strong>分层最大的好处在于封装。</strong></p><h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><ul><li><strong>OSI</strong>(Open System Interconnection ,开放系统互连) 七层网络模型称为开放式系统互联参考模型，是一种逻辑上定义和规范</li><li><strong>把网络从逻辑上分为7层</strong>，每一层都有相关，相对应的物理设备，比如路由器，交换机；</li><li>OSI七层网络模型是一种<strong>框架性</strong>的设计方法，其主要的功能就是帮助不同类型的主机实现数据传输</li><li>它最大的优点是将<strong>服务，接口和协议</strong>这三个概念明确地<strong>区分</strong>开，概念清除，理论也比较完整，通过7个层次化地结构模型使不同系统不同网络之间实现可靠地通讯；</li><li>但是，它即复杂又不实用，所以我们来详细了解<strong>TCP/IP四层模型</strong>。</li></ul><h2 id="TCP-IP五层（或四层）模型"><a href="#TCP-IP五层（或四层）模型" class="headerlink" title="TCP/IP五层（或四层）模型"></a>TCP/IP五层（或四层）模型</h2><p>TCP/IP是⼀一组协议的代名词，它还包括许多协议，组成了<strong>TCP/IP协议簇</strong>. TCP/IP通讯协议采⽤用了5层的层级结构，<strong>每⼀层都呼叫它的下一层所提供的网络</strong>来完成自己的需求. </p><blockquote><p>物理层</p></blockquote><p>一般而言</p><ul><li>对于一台主机, 它的<strong>操作系统内核</strong>实现了从<strong>传输层到物理层</strong>的内容; </li><li>对于一台<strong>路由器</strong>, 它实现了从<strong>网络层到物理层</strong>; </li><li>对于一台<strong>交换机</strong>, 它实现了从<strong>数据链路层到物理层</strong>; </li><li>对于<strong>集线器</strong>, 它只实现了<strong>物理层</strong>; </li></ul><p>理解：</p><p><strong>路由器：</strong>在网络层，网络包，网络包转发。</p><p><strong>交换机：</strong>工作在局域网，转发数据帧。</p><p><strong>集线器：</strong>物理层，解决长距离传输信号变弱。，增强信号。</p><p>但是并不绝对. 很多<strong>交换机也实现了网络层的转发</strong>; 很多<strong>路由器也实现了部分传输层的内容(比如端口转发</strong>);</p><h2 id="网络传输基本流程"><a href="#网络传输基本流程" class="headerlink" title="网络传输基本流程"></a>网络传输基本流程</h2><h3 id="网络传输流程图"><a href="#网络传输流程图" class="headerlink" title="网络传输流程图"></a>网络传输流程图</h3><p>同一个网段内的两台主机进行文件传输</p><table><thead><tr><th style="text-align:left">应用层                                   TeInet、FTP和e-mail等 Http 、SSH</th></tr></thead><tbody><tr><td style="text-align:left">传输层                                    TCP和UDP     –负责网路传输</td></tr><tr><td style="text-align:left">网络层                                     IP、ICMP和IGMP</td></tr><tr><td style="text-align:left">链路层                                     设备驱动程序及接口卡  –网卡驱动、数据帧</td></tr></tbody></table><h3 id="局域网通信"><a href="#局域网通信" class="headerlink" title="局域网通信"></a>局域网通信</h3><p><strong>以太网：</strong>这种基于冲突检测的网络称之为以太网。</p><p><strong>所有用户向局域网发送数据</strong></p><ul><li>发生冲突，采用冲突避免算法进行处理</li><li>若没有发生冲突，或者冲突已经解决就会直接可以进行通信。</li><li>避免冲突算法：分时间发送数据</li></ul><p>在局域网通信中每个主机在底层都有<strong>一个唯一的标识符</strong>——网卡中的序列号：MAC地址（全球唯一的地址）</p><p><strong>混杂模式的网卡：</strong>可以抓取任意一个在局域网中的包。</p><h2 id="数据的解包分用的过程"><a href="#数据的解包分用的过程" class="headerlink" title="数据的解包分用的过程"></a>数据的解包分用的过程</h2><p><strong>任何通信的行为都是从上层驱动的。</strong></p><p><strong>例子：图在下端</strong></p><p>A客户端（应用层）发送向客户端B一个请求</p><p>（<strong>发送信息</strong>）A客户端发送的信息从应用层<strong>一层一层</strong>的（<strong>封装</strong>）发送到最底层链路层，然后再发到以太网上去，</p><p>B客户端从链路层中获取的数据向上<strong>一层一层</strong>（<strong>解包，分用</strong>）的发送到B客户端的应用层。(<strong>获取信息</strong>)</p><p><strong>CPU：</strong>对数据进行封装处理，数据在内存中发送给网卡。</p><p>​    网卡中的信息发送到，内存中，CPU进行解包处理。</p><p><strong>封装：</strong> </p><p>当前层添加<strong>报头</strong>，（<strong>应用层</strong>）上层添加<strong>有效载荷</strong>（<strong>数据</strong>）</p><p><strong>分用：</strong>除了最顶层协议，任何一个协议它的报头当中，一定包<strong>含一个字段</strong>，这个字段用来表明，<strong>要将自己的有效载荷要交个上层的哪一个协议</strong>，只要有了个字段，就准确地将我们地报文实现向上交付了。</p><p><strong>解包：</strong> </p><p>拆去报头，拿出有效载荷（<strong>数据</strong>）</p><p><strong>应用层协议：</strong> </p><p>如何使用有效载荷（<strong>数据</strong>）</p><p><strong>根据当层协议将数据进行报头和有效载荷的拆解</strong></p><p>把数据链路层的数据叫做：数据帧</p><p>网络层IP层的数据叫做：数据报</p><p>传输层TCP层数据叫做：数据段</p><p>传输层UDP层数据叫做：数据报</p><p>两台计算机通过TCP\IP协议通讯的过程如下所示（以上是文字叙述）</p><h2 id="TCP-IP通讯过程（两台主机在同一个局域网当中）"><a href="#TCP-IP通讯过程（两台主机在同一个局域网当中）" class="headerlink" title="TCP/IP通讯过程（两台主机在同一个局域网当中）"></a><strong>TCP/IP通讯过程（两台主机在同一个局域网当中）</strong></h2><p><img src="img/两台主机在同一个局域网当中的通信.png" alt="两台主机在同一个局域网当中的通信"></p><p>跨网段的主机的文件传输. 数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器。</p><p><strong>交换机的应用</strong>: （大局域网中的应用）</p><p>交换机会有效的划分，碰撞域（冲突）</p><p>将大局域网拆分为多个小的局域网，拆分成的局域网中发送的信息，先交给交换机，交换将没有发生碰撞的信息发送到以太网上去。（碰撞的信息不发送到以太网上去，才用冲突算法进行解决。解决后再发送到局域网上去)。</p><p><strong>路由器的应用：</strong>路由器的作用连接局域网对网道网的数据进行转发。</p><p>路由器横跨两个局域网，路由器至少连接两个网卡，既有两个网卡的MAC地址（硬件地址）。</p><p><strong>ifconfig：</strong>查看当前Linux虚拟机的网络</p><p><strong>ens33: </strong> 当前网络接口</p><p><strong>inet:</strong> <strong>IP地址</strong> 占4个字节，一共<strong>32个bit位</strong>   </p><p>（硬件地址）<strong>MAC网卡地址</strong>：占6个字节，一共<strong>48个bit位</strong></p><p><strong>lo：</strong>本地环回接口</p><p>每一个硬件设备都有可能都会向服务器推送设备，IP地址不够了。</p><p>所以部署IPV6</p><p>IPV6:<strong>128bit位</strong></p><p>两种方式确定一个主机。产生一个问题：</p><p>唐僧取经例子：</p><p>IP地址从一个到另一个IP地址（提供大致方向）</p><p>其中经过不同的网卡（主机），所以我们的Mac地址一直在变（每次传输更靠近IP地址）</p><p>MAC地址一致在变，真正的进行数据传输。</p><h2 id="不同局域网之间的网络传输"><a href="#不同局域网之间的网络传输" class="headerlink" title="不同局域网之间的网络传输"></a>不同局域网之间的网络传输</h2><p><strong>路由器的应用：</strong>路由器的作用连接局域网对网道网的数据进行转发。</p><p>路由器横跨两个局域网，路由器至少连接两个网卡，<strong>既有两个网卡的MAC地址（硬件地址）</strong> </p><p>路由器有<strong>两个的接口**</strong>两张网卡<strong>，分别连接两个</strong>（<strong>两个独立的MAC地址</strong>），一个网卡连接以太网去驱动程序，右侧的这个连接里令牌环驱动程序。</p><p><img src="img/1547734714801.png" alt="1547734714801"></p><p>A主机自顶向下进行交付，封装到网络层时（查找自己的路由表）发现要去的目标IP不再同一个局域网。</p><p>所以发出数据的地址传自己的IP、MAC，目标地址传路由器的MAC地址。</p><p>数据帧由A主机发送到局域网上，所有局域网内的所有主机都受到了这条消息，其他主机收到消息后要做第一件事情，解包然后对对比，对比自己的IP地址与数据帧中解包出来的目的IP地址。</p><p>路由器的链路层以太网的驱动程序，对比发现这个包是发给它的，所以它把数据封装把数据向上传递给路由器的网络层，然后路由器进行一番路由，路由器将报文交付到下层，进行封装（报头中含有目标地址IP，和令牌环环的地址），最后令牌环将数据发送给主机B的令牌环驱动程序。</p><p>报文在整个过程中IP地址一致不变，IP层以上认为全球的网络称之为IP网络。（唯一IP）</p>]]></content>
      
      
      <categories>
          
          <category> Linux网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LinuxPOSIX信号量</title>
      <link href="/2019/01/16/LinuxPOSIX%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2019/01/16/LinuxPOSIX%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h1><p>POSIX信号量和System信号量作用相同，都是用于同步操作，达到无冲突访问共享资源的目的。但是POSIX可以用于线程同步、互斥。</p><p><strong>信号量：本质上是一把<em>计数器</em>，他用来描述临界资源当中资源数目的多少。</strong></p><h3 id="初始化信号量"><a href="#初始化信号量" class="headerlink" title="初始化信号量"></a><strong>初始化信号量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt; </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; </span><br><span class="line">参数：    </span><br><span class="line">pshared:<span class="number">0</span>表⽰示线程间共享，⾮非零表示进程间共享    </span><br><span class="line">value：信号量初始值</span><br></pre></td></tr></table></figure><h3 id="销毁信号量"><a href="#销毁信号量" class="headerlink" title="销毁信号量"></a><strong>销毁信号量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destory</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="等待信号量"><a href="#等待信号量" class="headerlink" title="等待信号量"></a><strong>等待信号量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">功能：等待信号量，会将信号量的值减<span class="number">1</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="信号量理解："><a href="#信号量理解：" class="headerlink" title="信号量理解："></a><strong>信号量理解：</strong></h3><p>当一个线程申请到信号量，信号量的计数器减一，线程就访问临界资源了。</p><p>释放信号量，信号量<strong>计数器</strong>加一。</p><p><strong>(二元)信号量</strong>且信号量的计数器设置为1就相当于一个互斥锁。</p><p>每个线程都能访问到信号量资源，<strong>信号量本身就是临界资源。</strong></p><p><strong>保证PV操作的原子性：</strong></p><p><strong>P操作：</strong>信号量申请操作是原子的</p><p><strong>V操作：</strong>信号量释放操作是原子的</p><h2 id="基于环形队列的生产者消费者模型"><a href="#基于环形队列的生产者消费者模型" class="headerlink" title="基于环形队列的生产者消费者模型"></a>基于环形队列的生产者消费者模型</h2><p><img src="img\基于环形队列的生产者消费者模型1.png" alt="基于环形队列的生产者消费者模型"></p><a id="more"></a><h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>处理有些公共资源修改比较少，读的机会比较多。通常情况下读的过程，往往伴随着查找的操作，中间耗时很长。给这种代码段加锁，会极大的降低我们程序的效率。</p><p><strong>读写锁本质是一种自旋锁</strong>:-&gt;<strong>[长时间等人短时间等人的例子]</strong> 是比较浪费CPU的操作</p><p><strong>目标线程在临界资源的待的时间长短</strong></p><p>长时间等待：<strong>挂起等待（阻塞）</strong></p><p>短时间等待：<strong>选择自旋式等待（轮询）</strong></p><p><strong>读者写着模型分析321原则：</strong>【写黑板报，读黑板报关系】</p><p>读者与读者之间：<strong>共享关系</strong></p><p>写者与写者之间：<strong>互斥关系</strong></p><p>读者与写着之间：<strong>互斥，同步关系</strong></p><p><strong>2种角色</strong></p><p><strong>1个场所</strong></p><table><thead><tr><th>当前锁状态</th><th>读写请求</th><th>写锁请求</th></tr></thead><tbody><tr><td>无锁</td><td>可以</td><td>可以</td></tr><tr><td>读锁</td><td>可以</td><td>阻塞</td></tr><tr><td>写锁</td><td>阻塞</td><td>阻塞</td></tr></tbody></table><blockquote><p><strong>注意：写独占，读共享，写锁优先级高</strong></p></blockquote><p>读写锁接口</p><p>初始化</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr _t *restrict attr)；</span><br></pre></td></tr></table></figure><p>销毁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><p>加锁和解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;  读锁加锁</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;  写锁加锁</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;  解锁</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程同步</title>
      <link href="/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux同步"><a href="#Linux同步" class="headerlink" title="Linux同步"></a>Linux同步</h1><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><blockquote><ul><li>当一个线程互斥地访问某个变量时，它可能发现在其他线程状态改变值之前，它什么也做不了。</li><li>例如一个线程访问队列时，发现队列为空，它只能等待，只到其它线程将一个节点添加到队列中。 这种情况就需要⽤用到条件变量。</li></ul></blockquote><p><strong>同步解决了进程饥饿问题</strong></p><h2 id="条件变量函数"><a href="#条件变量函数" class="headerlink" title="条件变量函数"></a>条件变量函数</h2><p>初始化条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *rest rict attr)</span></span>; </span><br><span class="line">参数：    </span><br><span class="line">cond：要初始化的条件变量    </span><br><span class="line">attr：<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>销毁条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond）</span></span></span><br></pre></td></tr></table></figure><p>等待条件满足</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mute x)</span></span>; </span><br><span class="line">参数：    </span><br><span class="line">cond：要在这个条件变量上等待    </span><br><span class="line">mutex：互斥量，后⾯面详细解</span><br></pre></td></tr></table></figure><p>唤醒等待</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure><h1 id="生产消费者"><a href="#生产消费者" class="headerlink" title="生产消费者"></a>生产消费者</h1><p>分析：</p><p>生产者生产者之间的关系—互斥关系（不能共享）</p><p>生产者消费者之间的关系—互斥关系，同步关系</p><p>消费者消费者之间的关系—互斥关系（不能共享）</p><p><strong>交易场所：超市</strong></p><p>321原则： 3种关系，2个角色，1 个交易场所</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程中可重入VS线程安全</title>
      <link href="/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%8F%AF%E9%87%8D%E5%85%A5VS%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
      <url>/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%8F%AF%E9%87%8D%E5%85%A5VS%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="可重入VS线程安全"><a href="#可重入VS线程安全" class="headerlink" title="可重入VS线程安全"></a>可重入VS线程安全</h2><p>概念：</p><blockquote><ul><li>线程安全：多个线程并发同一段代码时，不会出现不同结果。常见对全局变量或静态变量进行操作，并且没有锁保护的情况下，会出现该问题。</li><li>重入：同一函数被不同的执行流程钓调用，当前一个流程还没有执行完，就有其他执行流再次进入，我们称之为重入。一个函数在重入的条件下，运行结果不会出现任何不同或者任何问题，则该函数被称为可重入函数，否则不是。</li></ul></blockquote><a id="more"></a><h2 id="常见的线程安全不安全问题"><a href="#常见的线程安全不安全问题" class="headerlink" title="常见的线程安全不安全问题"></a>常见的线程安全不安全问题</h2><blockquote><ul><li>不保护共享变量的函数</li><li>函数状态随时被调用，状态发变化的函数</li><li>返回指向静态变量指针的函数</li><li>调用线程不安全函数的函数</li></ul></blockquote><h2 id="常见的线程安全的情况"><a href="#常见的线程安全的情况" class="headerlink" title="常见的线程安全的情况"></a>常见的线程安全的情况</h2><blockquote><ul><li>每个线程对全局变量或者静态变量只有读取权限，而没有写入的权限，一般来说这些线程是安全的</li><li>类或者接口对于线程来说都是原子操作</li><li>多个线程之间的切换不会导致该接口的执行结果存在二义性</li></ul></blockquote><h2 id="常见不可重入的情况"><a href="#常见不可重入的情况" class="headerlink" title="常见不可重入的情况"></a>常见不可重入的情况</h2><blockquote><ul><li>调用了malloc/free函数，因为malloc函数使用全局链表来管理堆的</li><li>调用了标准I/O库函数，标准I/O库的很多实现都以不可重入的方式使用全局数据结构 </li><li>可重入函数体内使用了静态的数据结构</li></ul></blockquote><h2 id="常见的可重入函数的情况"><a href="#常见的可重入函数的情况" class="headerlink" title="常见的可重入函数的情况"></a>常见的可重入函数的情况</h2><blockquote><ul><li>不是使用静态变量或全局变量</li><li>不使用用malloc或new开辟出来的空间</li><li>不调用课不可重入的函数</li><li>不返回静态或者全局数据，所有数据都有函数的调用者提供</li><li>使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据</li></ul></blockquote><h2 id="可重入与线程安全联系"><a href="#可重入与线程安全联系" class="headerlink" title="可重入与线程安全联系"></a>可重入与线程安全联系</h2><blockquote><ul><li>函数是可重入的，线程就是安全的</li><li>函数是不可重入，那就不能由多个线程使用，有可能引发线程安全问题</li><li>如果一个函数由全局变量，那么这个函数即不是线程安全的也不是可重入的。</li></ul></blockquote><h2 id="可重入与线程安全的区别"><a href="#可重入与线程安全的区别" class="headerlink" title="可重入与线程安全的区别"></a>可重入与线程安全的区别</h2><blockquote><ul><li>可重入函数是线程安全函数的一种</li><li>线程安全不一定可重入，而可重入函数则一定是线程安全的。</li><li>如果将对临界资源的访问加上锁，则这个函数是线程安全的，但如果这个重入函数，若锁还未释放则会产生死锁（自己进入自己锁好的函数，本线程被挂起，本线程带着锁且被挂起，线程携带的锁永远不会被释放–<strong>死锁</strong>），因此是不可重入的。</li></ul></blockquote><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a><strong>死锁的概念</strong></h3><ul><li><blockquote><p>死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占有不会释放的资源而处于一种永久等待状态。</p></blockquote></li></ul><h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a><strong>死锁的四个必要条件</strong></h3><blockquote><ul><li>互斥条件：一个资源每次只能被一个执行流使用</li><li>请求与保持条件：一个执行流因请求资源而阻塞时，对已获得资源保持不放</li><li>不剥夺条件：一个执行已获得的资源，在未使用完之前，不能强行剥夺</li><li>循环等待条件：若干执行流之间形成一种头尾相接的循环等待资源的关系。</li></ul></blockquote><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><blockquote><ul><li>破坏死锁四个必要条件</li><li>加锁顺序一致  所有线程申请锁的顺序是一定</li><li>避免未释放场景</li><li>资源一次性分配</li></ul></blockquote><h2 id="避免死锁的算法"><a href="#避免死锁的算法" class="headerlink" title="避免死锁的算法"></a>避免死锁的算法</h2><blockquote><ul><li><p>死锁检测算法</p></li><li><p>银行家算法</p><p>哲学家就餐问题</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程互斥</title>
      <link href="/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5/"/>
      <url>/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="线程互斥"><a href="#线程互斥" class="headerlink" title="线程互斥"></a>线程互斥</h1><h3 id="进程线程间的互斥相关背景概念"><a href="#进程线程间的互斥相关背景概念" class="headerlink" title="进程线程间的互斥相关背景概念"></a>进程线程间的互斥相关背景概念</h3><ul><li><strong>临界资源</strong>：多线程执行流共享的资源叫做临界资源</li><li><strong>临界区</strong>：每个线程内部，访问临界资源的代码，就叫做临界区</li><li><strong>互斥</strong>：任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常对临界资源起保护作用</li><li><strong>原子性</strong>：不被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成</li></ul><h2 id="–-操作并不是原子的操作，而是对应三条汇编指令"><a href="#–-操作并不是原子的操作，而是对应三条汇编指令" class="headerlink" title="–/++操作并不是原子的操作，而是对应三条汇编指令"></a>–/++操作并不是原子的操作，而是对应三条汇编指令</h2><ul><li>load:将共享变量从内存加载到寄存器中</li><li>update:更新寄存器里面的值，执行-1操作</li><li>store：将新值，从寄存器中写回共享变量的内存地址中</li></ul><p>要解决++/–操作不是原子的要做到以下3点</p><ol><li>代码必须有互斥行为：当代码进入到临界区执行时，不允许其他线程进入该临界区</li><li>如果多个线程同时要求执行临界区的代码时。并且临界区没有线程在执行，那么只允许一个线程进入该临界区。</li><li>如果线程不在临界区中执行，那么该线程不能阻止其他线程进入临界区。</li></ol><p><img src="img\1547620588390.png" alt="Lock原理图"></p><a id="more"></a><h2 id="mutex-互斥量"><a href="#mutex-互斥量" class="headerlink" title="mutex(互斥量)"></a>mutex(互斥量)</h2><blockquote><ul><li>大部分情况，线程使用的数据都是局部变量，变量的地址空间在线程的栈空间内，这种情况，变量的归属单个线程，其他线程无法获取这种变量</li><li>但是有的时候，很多变量都需要线程共享，这样的变量称为共享变量，可以通过数据的共享，完成线程之间的交互</li><li>多个线程并发操作共享变量，会带来一些问题。</li></ul><p>通常情况下同步是要互斥为前提的，同步可以保证多个执行流按照特定有效的顺序去访问临界资源。</p></blockquote><p><strong>总结：</strong>互斥了解决数据的二义性问题，安全性，正确性问题。</p><p>同步互斥可以让多个线程，多个进程之间可以协同工作。</p><h2 id="1-互斥锁（mutex）"><a href="#1-互斥锁（mutex）" class="headerlink" title="1.互斥锁（mutex）"></a>1.互斥锁（mutex）</h2><p>例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作共享变量会有问题的售票系统</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span> * <span class="title">buyTicket</span><span class="params">(<span class="keyword">void</span> * arg)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> * thread = (<span class="keyword">char</span>*) arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">             usleep(<span class="number">1000</span>);</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%s get a ticket ,num:%d\n"</span>,thread,tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%s quit!\n"</span>,thread);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t1,t2,t3,t4;</span><br><span class="line">    pthread_create(&amp;t1,<span class="literal">NULL</span>,buyTicket,(<span class="keyword">void</span> *)<span class="string">"thread 1"</span>);</span><br><span class="line">    pthread_create(&amp;t3,<span class="literal">NULL</span>,buyTicket,(<span class="keyword">void</span> *)<span class="string">"thread 3"</span>);</span><br><span class="line">    pthread_create(&amp;t4,<span class="literal">NULL</span>,buyTicket,(<span class="keyword">void</span> *)<span class="string">"thread 4"</span>);    </span><br><span class="line">    pthread_join(t1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t2,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t3,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t4,<span class="literal">NULL</span>);                                                                                                                             </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁后 互斥</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ticket = <span class="number">100</span>; <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">route</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">char</span> *id = (<span class="keyword">char</span>*)arg;    </span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> ) &#123;        </span><br><span class="line">        pthread_mutex_lock(&amp;mutex);        </span><br><span class="line">        <span class="keyword">if</span> ( ticket &gt; <span class="number">0</span> ) &#123;           </span><br><span class="line">            usleep(<span class="number">1000</span>);            </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s sells ticket:%d\n"</span>, id, ticket);           </span><br><span class="line">            ticket--;            </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);            <span class="comment">// sched_yield(); 放弃CPU       </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);            </span><br><span class="line">            <span class="keyword">break</span>;       </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">pthread_t</span> t1, t2, t3, t4;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t1, <span class="literal">NULL</span>, route, <span class="string">"thread 1"</span>);    </span><br><span class="line">    pthread_create(&amp;t2, <span class="literal">NULL</span>, route, <span class="string">"thread 2"</span>);   </span><br><span class="line">    pthread_create(&amp;t3, <span class="literal">NULL</span>, route, <span class="string">"thread 3"</span>);   </span><br><span class="line">    pthread_create(&amp;t4, <span class="literal">NULL</span>, route, <span class="string">"thread 4"</span>);</span><br><span class="line">    pthread_join(t1, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_join(t2, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_join(t3, <span class="literal">NULL</span>);    </span><br><span class="line">    pthread_join(t4, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mutex锁必须先初始化，互斥锁用完后，必须删除互斥锁</p><p>锁的初始化</p><ul><li>静态初始化</li></ul><p><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER</code></p><ul><li><p>动态初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> pthread_mutexattr <span class="keyword">_t</span> *<span class="keyword">restrict</span> attr)</span></span>;    参数：        mutex：要初始化的互斥量        attr：<span class="literal">NULL</span>`</span><br></pre></td></tr></table></figure><p>销毁互斥量 </p><p>销毁互斥量需要注意： </p><ul><li><p>使⽤用PTHREAD_ MUTEX_ INITIALIZER初始化的互斥量不需要销毁 </p></li><li><p>不要销毁⼀一个已经加锁的互斥量 </p></li><li><p>已经销毁的互斥量，要确保后⾯面不会有线程再尝试加锁</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_destroy(pthread_mutex_t *mutex)；</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>互斥量加锁和解锁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_lock(pthread_mutex_t *mutex); int pthread_mutex_unlock(pthread_mutex_t *mutex); 返回值:成功返回0,失败返回错误号</span><br></pre></td></tr></table></figure><blockquote><p>调⽤用pthread_ lock 时，可能会遇到以下情况: 互斥量处于未锁状态，该函数会将互斥量锁定，同时返回成功 发起函数调⽤用时，其他线程已经锁定互斥量，或者存在其他线程同时申请互斥量，但没有竞争到互 斥量，那么pthread_ lock调⽤<strong>会陷⼊入阻塞，等待互斥量解锁。</strong> </p></blockquote><p><strong>trylock：非阻塞式获取锁</strong></p><p><strong>总结：</strong></p><p><strong>锁本身是临界资源</strong>，但是申请锁的操作是原子性的。所以才可以使用锁保护临界资源。</p>]]></content>
      
      
      <categories>
          
          <category> Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程控制</title>
      <link href="/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/01/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h2><blockquote><ul><li>与线程有关的函数构成了⼀一个完整的系列，绝⼤大多数函数的名字都是以“pthread_”打头的 </li><li>引入头文件</li><li>链接这些线程库时要使用编译命令”-lpthread”选项</li></ul></blockquote><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能：创建⼀一个新的线程 </span><br><span class="line">原型    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*star t_routine)(void*), void *arg); </span><br><span class="line">参数    thread:返回线程ID    attr:设置线程的属性，attr为<span class="literal">NULL</span>表⽰示使⽤用默认属性    start_routine:是个函数地址，线程启动后要执⾏行的函数    arg:传给线程启动函数的参数</span><br><span class="line">返回值：成功返回<span class="number">0</span>；失败返回错误码</span><br></pre></td></tr></table></figure><p>错误检查: </p><ul><li>传统的⼀一些函数是，成功返回0，失败返回-1，并且对全局变量errno赋值以指⽰示错误。</li><li>pthreads函数出错时不会设置全局变量errno（⽽而⼤大部分其他POSIX函数会这样做）。⽽而是将错误 代码通过返回值返回 </li><li>pthreads同样也提供了线程内的errno变量，以⽀支持其它使⽤用errno的代码。对于pthreads函数的错 误，建议通过返回值判定，因为读取返回值要比读取线程内的errno变量的开销更小</li></ul><a id="more"></a><h2 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h2><p>pthread库中</p><p><strong>线程需要等待：</strong></p><ul><li>已经退出的线程，其空间没有被释放，仍然在进程的地址空间内。 </li><li>创建新的线程不会复用刚才退出线程的地址空间。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能：等待线程结束 </span><br><span class="line">原型    <span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **value_ptr)</span></span>; </span><br><span class="line">参数    thread:线程ID    value_ptr:它指向一个指针，后者指向线程的返回值 </span><br><span class="line">返回值：成功返回<span class="number">0</span>；失败返回错误码</span><br></pre></td></tr></table></figure><blockquote><p><strong>线程等待，当前发起等待线程被挂起（阻塞式），等待被等待退出。</strong></p></blockquote><p>retval：被等待线程退出的返回值。（不关注就传一个NULL）</p><p>线程退出几种情况：</p><ul><li>线程运行完了结果对</li><li>线程运行完了结果不对</li><li>线程没运行完出异常</li></ul><p>但是一个进程中的线程异常退出，整个进程就退出了，发起等待线程也就被终止，所以不关注出异常情况。</p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法:</p><ol><li>从线程函数return 退出码。这种方法对主线程不适用,从main函数return相当于调用exit。 </li><li>线程可以调用pthread_ exit（退出码）终止自己。 </li><li>一个线程可以调用pthread_ cancel终止同一进程中的另一个线程</li></ol><ul><li>pthread_exit函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能：线程终止 </span><br><span class="line">原型    <span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *value_ptr)</span></span>; </span><br><span class="line">参数    value_ptr:value_ptr不要指向一个局部变量。 </span><br><span class="line">返回值：无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）</span><br></pre></td></tr></table></figure><ul><li>需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的,不能在线程函数 的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。</li><li>pthread_cancel函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能：取消一个执行中的线程 </span><br><span class="line">原型    int pthread_cancel(pthread_t thread); </span><br><span class="line">参数    thread:线程ID </span><br><span class="line">返回值：成功返回0；失败返回错误码</span><br></pre></td></tr></table></figure><p>调用<strong>join函数</strong>的线程将挂起等待,直到id为thread的线程终止。thread线程以不同的方法终止,通过pthread_join得到的终 止状态是不同的，总结如下:</p><blockquote><p>1.如果thread线程通过<strong>return</strong>返回,value_ ptr所指向的单元里存放的是thread线程函数的返回值。 2. 如果thread线程被别的线程调用<strong>pthread_ cance</strong>l异常终掉,value_ ptr所指向的单元里存放的是常数<strong>PTHREAD_ CANCELED   ——返回值为：-1。</strong> </p><p>3.如果thread线程是自己调用<strong>pthread_exit</strong>终止的,value_ptr所指向的单元存放的是传给<strong>pthread_exit的参数。</strong> </p><p>4.如果对thread线程的<strong>终止状态不感兴趣,可以传NULL给value_ ptr参数</strong>。</p></blockquote><h2 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h2><ul><li>默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资 源，从而造成系统泄漏。</li><li>如果不关心线程的返回值，join是一种负担，这个时候，我们可以告诉系统，当线程退出时，自动释放线程 资源。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><p>可以是线程组内其他线程对目标线程进行分离，也可以是线程自己分离:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_detach(pthread_self());</span><br></pre></td></tr></table></figure><p>joinable和分离是冲突的，一个线程不能既是joinable又是分离的。</p><p>joinable和分离是冲突的，一个线程不能既是joinable又是分离的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux线程ID和进程ID</title>
      <link href="/2019/01/16/Linux%E7%BA%BF%E7%A8%8BID%E5%92%8C%E8%BF%9B%E7%A8%8BID/"/>
      <url>/2019/01/16/Linux%E7%BA%BF%E7%A8%8BID%E5%92%8C%E8%BF%9B%E7%A8%8BID/</url>
      
        <content type="html"><![CDATA[<h1 id="在Linux查看正在运行的线程"><a href="#在Linux查看正在运行的线程" class="headerlink" title="在Linux查看正在运行的线程"></a><strong>在Linux查看正在运行的线程</strong></h1><p><strong><code>ps -aL</code></strong></p><h1 id="线程ID和进程ID"><a href="#线程ID和进程ID" class="headerlink" title="线程ID和进程ID"></a>线程ID和进程ID</h1><p><img src="img\1547621920737.png" alt="线程ID和进程ID"></p><p>同一个进程内部的线程（多个执行流）用getpid()返回的是一个一个PID。（用户级id）</p><a id="more"></a><ul><li>一个进程里面对应多个PCB(线程的PCB) </li></ul><table><thead><tr><th>用户态</th><th>系统调用</th><th>内核进程描述符中对应的结构</th></tr></thead><tbody><tr><td>线程ID</td><td>pid_t gettid(void);</td><td>pid_t pid(操作系统调度的线程号) 操作系统级别 //c库中被没有间接调用 tid = syscall(SYS_gettid);——<strong>LWP</strong></td></tr><tr><td>进程ID</td><td>pid_t getpid(void);</td><td>pid_t tgid (进程组ID)  用户级  直接可以调用**</td></tr></tbody></table><p><strong>LWP - getttid()  –pid</strong> (操作系统级别)</p><p><strong>ps命令中的-L选项，会显示如下信息：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost linux]<span class="meta"># ps -eLf |head -1 &amp;&amp; ps -eLf |grep a.out |grep -v grep UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD </span></span><br><span class="line">root     <span class="number">28543</span> <span class="number">22937</span> <span class="number">28543</span>  <span class="number">0</span>    <span class="number">2</span> <span class="number">15</span>:<span class="number">32</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ./a.out </span><br><span class="line">root     <span class="number">28543</span> <span class="number">22937</span> <span class="number">28544</span>  <span class="number">0</span>    <span class="number">2</span> <span class="number">15</span>:<span class="number">32</span> pts/<span class="number">0</span>    <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> ./a.out</span><br></pre></td></tr></table></figure><ul><li>LWP:线程ID，既gettid()系统调用的返回值。 </li><li>NLWP:线程组内线程的个</li></ul><blockquote><p>Linux提供了gettid系统调用来返回其线程ID，可是glibc并没有将该系统调用封装起来，在开放接口来共程序员使 用。如果确实需要获得线程ID，可以采用如下方法：     #include &lt;sys/syscall.h&gt;   pid_t tid;   tid = syscall(SYS_gettid);</p></blockquote><p><strong>当一个线程的pid=tgid则这个线程是主线程</strong></p><p>线程ID及进程地址空间布局</p><ul><li><p>pthread_create函数会产生一个线程ID，存放在第一个参数指向的地址中。该线程ID(库级别操作id)和前面所说的线程ID（pid）不是一回事。</p></li><li><p>前面讲的线程ID属于进程调度的范畴。因为线程是轻量级进程，是操作系统调度器的最小单位，所以需要 一个数值来唯一表示该线程。 </p></li><li><p>pthread_ create函数第一个参数指向一个虚拟内存单元，该内存单元的地址即为新创建线程的线程ID，属于 NPTL线程库的范畴。线程库的后续操作，就是根据该线程ID来操作线程的。 线程库NPTL提供了pthread_ self函数，可以获得线程自身的ID：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多线程概念</title>
      <link href="/2019/01/14/Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/01/14/Linux%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的概念（复习）-铺垫"><a href="#线程的概念（复习）-铺垫" class="headerlink" title="线程的概念（复习）-铺垫"></a>线程的概念（复习）-铺垫</h1><ul><li>进程是<strong>分配系统资源的基本单位</strong></li><li>线程是<strong>一个标准的进程(一个执行流的进程)</strong></li></ul><p><img src="img\1547621339288.png" alt="Linux线程图解"></p><h2 id="1-理解（Linux下）"><a href="#1-理解（Linux下）" class="headerlink" title="1.理解（Linux下）"></a>1.理解（Linux下）</h2><p><strong>线程是在进程的内部运行的：</strong>线程是在进程的地址空间内运行的，共享一份虚拟地址空间。</p><p><strong>线程大部分资源都是共享的</strong>。（共用一个虚拟地址空间）</p><p><strong>进程大部分资源都是独立的</strong>。（每个一个进程都有自己独自的一份虚拟地址空间）</p><p>CPU是只能识别PCB的，但是他无法区分进程还是线程。所以Linux当中CPU看到的一个进程相当于一个轻量级进程（&lt;=一个标准的进程(一个执行流的进程)）</p><p>Linux下没有一份真正意义的进程。使用进程模拟线程。</p><p>TCB ThreadContrlClock 线程控制块</p><p><img src="img\线程概念.png" alt="线程概念"></p><a id="more"></a><h2 id="2-线程的资源"><a href="#2-线程的资源" class="headerlink" title="2.线程的资源"></a>2.线程的资源</h2><ul><li><strong>私有资源</strong></li></ul><blockquote><ol><li>线程ID</li><li>一组寄存器（上下文保护）</li><li>线程栈</li><li>erro</li><li>信号屏蔽字</li><li>调度优先级</li></ol></blockquote><ul><li><strong>共享资源</strong></li></ul><blockquote><ol><li>同有个地址空间</li><li>文件描述符</li><li>每种处理信号处理方式（忽略，默认，自定义）</li><li>当前工作目录</li><li>用户id和组id</li></ol></blockquote><h2 id="3-线程优点"><a href="#3-线程优点" class="headerlink" title="3.线程优点"></a>3.线程优点</h2><blockquote><ul><li>创建线程比创建一个进程代价小</li><li>与进程之间切换相比，线程之间的切换需要操作系统的工作小的多</li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速IO操作的同时，程序可以执行其他任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>IO密集型应用，为了提高性能，将IO操作重叠。线程可以同时等待不同IO操作</li></ul></blockquote><h2 id="4-线程缺点"><a href="#4-线程缺点" class="headerlink" title="4.线程缺点"></a>4.线程缺点</h2><ul><li>性能损失<ul><li>一个很少被外部事件阻塞的计算密集型线程往往⽆无法与共它线程共享同⼀一个处理器。如 果计算密集型线程的数量⽐比可⽤用的处理器多，那么可能会有较⼤大的性能损失，这⾥里的性 能损失指的是增加了额外的同步和调度开销，⽽而可⽤用的资源不变。</li></ul></li></ul><ul><li><p>健壮性降低</p><ul><li>编写多 程需要更全⾯面更深⼊入的考虑，在一个多线程程序⾥里，因时间分配上的细微偏差 或者因共享了不该共享的变量⽽而造成不良影响的可能性是很⼤大的，换句话说线程之间是 缺乏保护的。</li></ul></li><li><p>缺乏访问控制</p><ul><li>进程是访问控制的基本粒度，在⼀一个线程中调⽤用某些OS函数会对整个进程造成影响</li></ul></li><li><p>编程难度提高</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14-javaIO</title>
      <link href="/2019/01/06/14-javaIO/"/>
      <url>/2019/01/06/14-javaIO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java高级开发之JavaIO"><a href="#Java高级开发之JavaIO" class="headerlink" title="Java高级开发之JavaIO"></a>Java高级开发之JavaIO</h1><p>IO部分的重点：五个类（File、OutputStream、InputStream、Reader、Writer）一个接口（Serializable）</p><h1 id="1-File文件操作类"><a href="#1-File文件操作类" class="headerlink" title="1.File文件操作类"></a>1.File文件操作类</h1><p>在java.io包中，File类是唯一一个与文件本身操作（创建，删除，取得信息）有关的程序类</p><h2 id="1-1File类的基本使用"><a href="#1-1File类的基本使用" class="headerlink" title="1.1File类的基本使用"></a>1.1File类的基本使用</h2><p>java.io.File类是一个普通的类，直接产生实例化对象即可，两个构造方法如下：</p><blockquote><p>public File(String pathname);</p><p>public File(String parent,String child); //设置父路径和子类</p></blockquote><p>如果要进行文件的基本操作，可以使用FIle类的如下方法；</p><blockquote><p>创建一个新文件</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="keyword">throws</span> IOExcepotion</span></span><br></pre></td></tr></table></figure><blockquote><p>判断一个文件是否存在</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> bollean <span class="title">exists</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>由于java具有跨平台特性但是，在实际项目部署环境可能与开发环境不同.那么这个时候路径的问题就很麻烦。Windows下面使用的是“\”,而Unix系统下使用的是“/”。所以使用路径分隔符时都会采用File类的一个常量”<code>public static final String separator</code>“来描述</p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaSE基础 </tag>
            
            <tag> Java学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12-视图</title>
      <link href="/2019/01/06/12-%E8%A7%86%E5%9B%BE/"/>
      <url>/2019/01/06/12-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="12-视图"><a href="#12-视图" class="headerlink" title="12.视图"></a>12.视图</h1><p>MySQL5添加了对视图的支持。</p><p>视图是一个<strong>虚拟的表</strong>。其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。<strong>视图的数据变化会影响到基表，基表的数据变化也会影响到视图。</strong></p><p>视图可以把查询包装成一个虚拟表（临时表），方便检索。</p><a id="more"></a><h2 id="12-1使用视图的作用"><a href="#12-1使用视图的作用" class="headerlink" title="12.1使用视图的作用"></a>12.1使用视图的作用</h2><blockquote><ul><li><strong>重用SQL语句</strong></li><li><strong>简化复杂的SQL操作。在编写查询后，可以方便地重新利用而不必知道它地基本查询细节</strong></li><li><strong>使用表地组成部分而不是整个表</strong></li><li><strong>保护数据。可以给用户授予表地特定部分的访问权限而不是整个表的访问权限。</strong>(提高安全性)</li><li><strong>更改数据格式和表。视图可以返回与底层表的表示和格式不同的数据。</strong></li></ul></blockquote><p>在视图创建后，可以利用与表基本相同的方式利用他们。可以对视图执行select操作，过滤和排序数据，将视图联结到其他视图或者表，甚至能添加更新操作（添加更新数据存在某种限制）</p><h3 id="12-1-2视图带来的性能问题"><a href="#12-1-2视图带来的性能问题" class="headerlink" title="12.1.2视图带来的性能问题"></a>12.1.2视图带来的性能问题</h3><p>因为视图本省不包含数据，所以每次检索使用视图时，都必须处理查询执行时所需的任一个检索。如果你用了多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降的很厉害。因此在部署使用了大量视图的应用前，应该进行测试。</p><h2 id="12-2视图的规则和限制"><a href="#12-2视图的规则和限制" class="headerlink" title="12.2视图的规则和限制"></a>12.2视图的规则和限制</h2><ul><li>与表名相同，视图也需要唯一名称</li><li>对于可以创建的视图数目没有限制</li><li>对于创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予</li><li>视图可以像表一样嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图</li><li>order by可以用在视图中，但是如果从该视图检索数据的select语句也包含order by,那么该视图中的order by将被覆盖。</li><li>视图不能索引[^1]，也不能有关联的触发器[^2]或默认值。</li></ul><p>[^1]: 视图是一张临时表（存储引擎 myisam） 不能有主键<br>[^2]: view procedure  ,trigger(触发器)：会监听 一些update 等 相当于一个切面</p><ul><li><p>视图可以和表一起使用，例如，编写一条联结表和视图的select语句。 </p><p>​                                                                          `</p></li></ul><h2 id="12-3视图使用"><a href="#12-3视图使用" class="headerlink" title="12.3视图使用"></a>12.3视图使用</h2><ul><li>创建视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名 as select 语句</span><br></pre></td></tr></table></figure><ul><li>查看创建视图的语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create view 视图名</span><br></pre></td></tr></table></figure><ul><li>删除视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名</span><br></pre></td></tr></table></figure><ul><li>更新视图</li></ul><blockquote><p>可以先用<code>drop</code>再用<code>create</code>，也可以直接用<code>create or replace view</code><br>如果要更新的视图不存在，则第二条更新语句就会创建一个新的视图；<br>如果要更新的视图存在；则第二条根更新的语句会替代原有视图。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create view v_ename_dname as select ename,dname from emp,dept where emp.deptno = dept.deptno;</span><br><span class="line">Query OK, 0 rows affected (0.25 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_scott |</span><br><span class="line">+-----------------+</span><br><span class="line">| dept            |</span><br><span class="line">| emp             |</span><br><span class="line">| exam            |</span><br><span class="line">| salgrade        |</span><br><span class="line">| stu             |</span><br><span class="line">| v_ename_dname   |</span><br><span class="line">+-----------------+</span><br><span class="line">6 rows in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from  v_ename_dname;</span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| WARD   | SALES      |</span><br><span class="line">| JONES  | RESEARCH   |</span><br><span class="line">| MARTIN | SALES      |</span><br><span class="line">| BLAKE  | SALES      |</span><br><span class="line">| CLARK  | ACCOUNTING |</span><br><span class="line">| SCOTT  | RESEARCH   |</span><br><span class="line">| KING   | ACCOUNTING |</span><br><span class="line">| TURNER | SALES      |</span><br><span class="line">| ADAMS  | RESEARCH   |</span><br><span class="line">| JAMES  | SALES      |</span><br><span class="line">| FORD   | RESEARCH   |</span><br><span class="line">| MILLER | ACCOUNTING |</span><br><span class="line">+--------+------------+</span><br><span class="line">14 rows in set (0.12 sec)</span><br></pre></td></tr></table></figure><ul><li>修改了视图，对基表数据有影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">update v_ename_dname set dname=&apos;sales&apos;  where ename=&apos;CLARK&apos;; </span><br><span class="line">select * from EMP  where ename=&apos;CLARK&apos;;</span><br><span class="line">+--------+-------+---------+------+---------------------+---------+------+--------+</span><br><span class="line">| empno  | ename | job     | mgr  | hiredate            | sal     | comm | deptno |</span><br><span class="line">+--------+-------+---------+------+---------------------+---------+------+--------+</span><br><span class="line">| 007782 | CLARK | MANAGER | 7839 | 1981-06-09 00:00:00 | 2450.00 | NULL |     10 |</span><br><span class="line">+--------+-------+---------+------+---------------------+---------+------+--------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from dept;</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| deptno | dname      | loc      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | sales      | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>修改了基表，。对视图也有影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; update emp set deptno=20 where ename=&apos;james&apos;; -- 修改基表</span><br><span class="line">Query OK, 1 row affected (0.09 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from v_ename_dname where ename = &apos;james&apos;;</span><br><span class="line">+-------+----------+</span><br><span class="line">| ename | dname    |</span><br><span class="line">+-------+----------+</span><br><span class="line">| JAMES | RESEARCH |   &lt;-视图中的数据发生了变化</span><br><span class="line">+-------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>删除视图</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><h2 id="12-4利用视图简化更复杂的联结"><a href="#12-4利用视图简化更复杂的联结" class="headerlink" title="12.4利用视图简化更复杂的联结"></a>12.4利用视图简化更复杂的联结</h2><p>从上面的例子就可以看出，我再次从筛选出来的视图中查找时，就不需要再写where from 条件，直接使用视图即可。</p><blockquote><p>创建可重用的视图：创建不受特定数据限制的视图是一种好办法。扩展视图的范围不仅可以使得它能被重用，而且甚至更多有用。这样做不需要创建和维护多个类似视图</p></blockquote><h2 id="12-5用视图过滤不想要的数据"><a href="#12-5用视图过滤不想要的数据" class="headerlink" title="12.5用视图过滤不想要的数据"></a>12.5用视图过滤不想要的数据</h2><p>视图对应普通的where子句也很有用。</p><blockquote><p>where子句和where子句如果从检索数据时使用了一条where子句，则两组子句（一组在视图中，另一组是传递给视图的）将自动组合。</p></blockquote><h2 id="12-6使用视图与计算字段"><a href="#12-6使用视图与计算字段" class="headerlink" title="12.6使用视图与计算字段"></a>12.6使用视图与计算字段</h2><p>将用select 筛选出来的的计算字段的语句将筛选出来的结果作为视图用运用，简化SQL语句，便于查找。</p><h2 id="12-7更新视图（详解）"><a href="#12-7更新视图（详解）" class="headerlink" title="12.7更新视图（详解）"></a>12.7更新视图（详解）</h2><p>通常，视图是可以更新的（即，可以对视图 insert、update、delete）。更新一个视图将更新其基表，因为视图是一个虚拟表，其中并没有真实存在数据而只是select筛选出来的数据的整合成一个临时表而已。如果你对视图进行修改，则实际上是对其基表增加或删除，修改。</p><p>但是并非所有视图都是可以更新的。基本上说，如果MySQL不能正确地确定被更新的数据，则不允许更新（包括插入删除）。这实际上意味着，如果视图定义中有以下操作，则不能进行视图的更新：</p><ul><li>分组（使用group by）;</li><li>联结；</li><li>子查询；</li><li><p>聚集函数（min()、count()、sum() 等）；</p></li><li><p>distinct;</p></li><li>导出（计算）列</li></ul><p>即视图基本不能进行更新，这不是一种严重的限制，其实视图主要用于数据检索的。</p><blockquote><p>一般，视图应该用于检索（select语句）而不是用于更新(insert,update和delete)。</p></blockquote><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><strong>视图是一个虚拟的表。他们包含的不是数据而是根据需要检索出来的数据的查询。视图提供了一种MySQL的Select语句层次的封装，可以用来简化数据处理以及重新格式化基础数据或保护基础数据。</strong></p><ul><li>与表一样，必须唯一命名（不能出现同名视图或表名）</li><li>创建视图数目无限制，但要考虑复杂查询创建为视图之后的性能影响 </li><li>视图不能添加索引，也不能有关联的触发器或者默认值 </li><li>视图可以提高安全性，必须具有足够的访问权限 </li><li><code>order by</code> 可以用在视图中，但是如果从该视图检索数据 <code>select</code>中也含有 <code>order by</code> ,那么该视图中的 <code>order by</code> 将被覆盖 </li><li>视图可以和表一起使用</li></ul><h1 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h1><p><strong>牛客：针对actor表创建视图actor_name_view</strong></p><p><a href="https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&amp;&amp;tqId=29806&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking" target="_blank" rel="noopener">牛客：针对actor表创建视图actor_name_view</a></p><p><strong>题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">针对actor表创建视图actor_name_view，只包含first_name以及last_name两列，并对这两列重新命名，first_name为first_name_v，last_name修改为last_name_v：</span><br><span class="line">CREATE TABLE IF NOT EXISTS actor (</span><br><span class="line">actor_id smallint(5) NOT NULL PRIMARY KEY,</span><br><span class="line">first_name varchar(45) NOT NULL,</span><br><span class="line">last_name varchar(45) NOT NULL,</span><br><span class="line">last_update timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))</span><br></pre></td></tr></table></figure><p>分析：写视图就是先思考select语句即可</p><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create view actor_name_view  as select first_name as first_name_v , last_name as last_name_v from actor;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11-事务管理</title>
      <link href="/2019/01/05/11-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2019/01/05/11-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="11-事务管理"><a href="#11-事务管理" class="headerlink" title="11-事务管理"></a>11-事务管理</h1><p>事务就是一组DML语句组成，这些语句在逻辑上存在着相关性，这一组DML语句要么成功，要么全部失败，是一个整体。MySQL提供一种机制，保证我们达到这样的效果。事务还规定不同的客户端看到的数据是不相同的。</p><p>事务处理是一种机制，用来管理必须成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可保证一组操作不会中途停止，他们或者作为整体执行，或者完全不执行（除非明确指示）。如果没有错误发生，整组语句提交给（写到）数据库表。如果发生错误，则进行回退（撤销操作）以恢复数据库到某个已知且安全的状态。</p><a id="more"></a><p>基本术语：</p><blockquote><ul><li><strong>事务（transaction）指一组SQL语句；</strong></li><li><strong>回退（rollback）指撤销指定SQL语句的过程</strong></li><li><strong>提交（Commit）指将未储存的SQL语句结果写入数据库表；</strong></li><li><strong>保留点（savepoint）指事处理中设置的临界占位符（place-holder），你可以对它发布退回（与回退整个事务处理不同）</strong></li></ul></blockquote><h2 id="11-2-事务处理基本操作"><a href="#11-2-事务处理基本操作" class="headerlink" title="11.2  事务处理基本操作"></a>11.2  事务处理基本操作</h2><p>案例：</p><p>银行转账的例子更需要考虑事务问题。</p><ul><li><p>创建测试表</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table account(</span><br><span class="line">    -&gt; id int primary key,</span><br><span class="line">    -&gt; name varchar(50) not null default &apos;&apos;,</span><br><span class="line">    -&gt; balance decimal(10,2) not null default 0.0</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure></li><li><p>开始一个事务</p><p><code>start transaction</code>  <code>begin</code></p></li><li><p>创建一个保存点</p><p><code>savepoint 保存点名</code></p></li><li><p>回到保存点（根据具体情况）</p><p><code>rollback to 保存点名</code> <code>release savepoint</code></p></li><li><p>提交结束当前事务</p><p><code>commit;</code> <code>rollback</code></p></li><li><p>代码演示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start transaction; -- 开始事务</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint aa; -- 设置保存点aa</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(1,&apos;张三&apos;,10); --添加一条存款记录</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; savepoint bb; -- 设置保存点bb</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(2,&apos;李四&apos;，100000)； -- 再添加一条记录</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into account values(2,&apos;李四&apos;,100000); -- 再添加一条存款记录</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; -- 两条记录都在</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">| id | name   | balance   |</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">|  1 | 张三   |     10.00 |</span><br><span class="line">|  2 | 李四   | 100000.00 |</span><br><span class="line">+----+--------+-----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback to bb;  -- 发现后来添加这一条记录是误操作。所以回滚到bb状态 </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; -- 第二条记录没了</span><br><span class="line">+----+--------+---------+</span><br><span class="line">| id | name   | balance |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">|  1 | 张三   |   10.00 |</span><br><span class="line">+----+--------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-2事务处理注意事项"><a href="#11-2事务处理注意事项" class="headerlink" title="11.2事务处理注意事项"></a>11.2事务处理注意事项</h2><ul><li><p>如果没有设置保存点，也可以回滚，只是回滚到事务的开始。直接使用 rollback(前提事务还没有提交)</p></li><li><p>如果一个事务被提交了（Commit）,则不可以回退（rollback）</p></li><li><p>可以选择回退到哪一个保存点</p></li><li><p>innnoDB支持事务，MyISAM不支持事务</p></li><li><p>开始事务 start transaction</p></li><li><p>rollback只能在一个事务处理内使用（在执行一条start transaction命令之后）</p></li></ul><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips:"></a>小tips:</h3><blockquote><p><strong>事务处理用来管理insert,update和delete语句，不能回退select,create,drop语句，如果你执行回退，他们不会被撤销。</strong>DDL语句和隐式修改MySQL构架的语句：<code>set password</code> ,<code>create user</code>…</p><p>管理语句：<code>cache index</code> <code>load indeex</code>  <code>analyze table</code>…</p></blockquote><h2 id="11-3使用Commit"><a href="#11-3使用Commit" class="headerlink" title="11.3使用Commit"></a>11.3使用Commit</h2><p>一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交(implicit commot)，即提交（写或保存）操作就是自动进行的。</p><p>但是在事务处理块中，提交不会隐含地进行。为进行明确地提交，使用commit语句。commit语句后当前事务就已经结束了，在事务中保存地回退点就不再存在了。</p><p>【以下仅个人理解】</p><p>可以这样理解事务地执行过程，开始一个事务后所有的SQL语句（insert，delete,update）执行的结果都在内存中保存并未真实的写入物理磁盘中（文件），一个回退点就相当标记当前时刻临时表中（内存）的状态，当执行回退时，就像栈一样的之前的语句从语句栈中弹出，返回表的回退点的状态。</p><p><strong>当commit执行后，或者rollback语句执行后事务回关闭。</strong>将内存中的有效SQL语句对应表写回物理磁盘中表（文件）  【<strong>此处的rollback语句并非是<code>rollback to 回退点</code>语句，回滚的回退点的语句并不能真正结束事务，还需显示的调用commit 或 rollback语句</strong>】</p><p><strong>当一个事务中某行语句执行出错时，commit之前的一条语句，则自动回退到执行错误语句的前面且事务并没有被提交，假如再使用<code>start transaction</code>则会提交之前的事务，开始新的事务。</strong></p><h3 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips:"></a>小Tips:</h3><blockquote><p>隐含事务关闭：当commit执行后，或者rollback语句执行后事务回关闭，事务回自动关闭（将来的更改将会隐式的提交）</p></blockquote><h2 id="11-4使用保留点"><a href="#11-4使用保留点" class="headerlink" title="11.4使用保留点"></a>11.4使用保留点</h2><p>简单的rollback和commit语句就可以写入或撤回整个事务处理。但是，只是对简单的事务处理才能这样做，更复杂的事务处理可能需要部分提交或回退。</p><p>回退点<code>savepoint 回退点名称</code> ，如果重复使用回退点的名称，则覆盖新的回退点。</p><p><strong>释放保留点</strong>：<code>rollback to 保留点名称</code> 、release savepoint(MySQL 5以来)</p><h2 id="11-5更改默认的提交行为"><a href="#11-5更改默认的提交行为" class="headerlink" title="11.5更改默认的提交行为"></a>11.5更改默认的提交行为</h2><p>默认MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上就是针对表执行的，而且所做的更改立即生效。为指示MySQL不自动提交更改，需要使用以下语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit=0;</span><br></pre></td></tr></table></figure><p>autocommit标志决定是否自动提交更改，不管有没有commit语句。设置autocommit 为（假 0）指示MySQL不自动提交更改（直到autocommit被设置为真为止）</p><blockquote><p>改标志autocommit针对每一个连接而不是服务器的。</p></blockquote><h2 id="11-6-事务的隔离级别"><a href="#11-6-事务的隔离级别" class="headerlink" title="11.6 事务的隔离级别"></a>11.6 事务的隔离级别</h2><p>当我们有多个客户端同时操作数据库的某张表，如何进行隔离操作？MySQL提供了个隔离级别</p><p>当MySQL表被多个线程或者客户端开启各自事务操作数据库中的数据库时，MySQL提供了一种机制，可以让不同的事务操作数据时，具有隔离性。从而保证数据的一致性。</p><h3 id="11-6-1无隔离性的带来问题"><a href="#11-6-1无隔离性的带来问题" class="headerlink" title="11.6.1无隔离性的带来问题"></a>11.6.1无隔离性的带来问题</h3><p>1.脏读</p><p>是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交数据中，这时，另外事务也访问这个数据，然后使用了这个不是最新的数据。</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Mary的原工资为1000，财务人员将Mary的工资改为8000（但未提交事务）</span><br><span class="line">2.Mary读取自己的工资，发现自己的工资变为8000，很开心！</span><br><span class="line">3.而财务发现自己操作有误，回滚了事务，Marry工资变为了1000，Marry读到的工资数8000是一个脏数据。</span><br><span class="line">解决:在事务修改完成并提交后才可以读取到数据，则可避免该问题</span><br></pre></td></tr></table></figure><p>2.不可重复读</p><p>是指一个事务内，多次读同一数据。在这个事务还没结束时，另外一个事务也访问该同一数据。那么，在第一个事务中两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据有可能不一样。这样读发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复度。（即不读到相同的数据内容）</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在事务1中，Marry读取到自己工资为1000，操作并没有完成。</span><br><span class="line">2.在事务2中，这时财务人员修改了Marry的工资为2000，并提交事务。</span><br><span class="line">3.在事务1中，Marry再次读取到自己的工资时，工资变了2000</span><br><span class="line">解决方法：在事务修改完成并提交后才可以读取到数据，则可避免该问题</span><br></pre></td></tr></table></figure><p>3.幻读</p><p>是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改设计到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入了一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就像发生了幻觉一样。</p><p>如以下场景：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">目前工资为1000的员工有10人。   </span><br><span class="line">1.事务1,读取所有工资为1000的员工。    </span><br><span class="line">2.这时事务2向employee表插入了一条员工记录，工资也为1000    </span><br><span class="line">3.事务1再次读取所有工资为1000的员工 共读取到了11条记录，          </span><br><span class="line">解决办法：如果在操作事务完成数据处理之前，任何其他事务都不可以添加新数据，则可避免该问题</span><br></pre></td></tr></table></figure><p><strong>备注</strong>：不可重复读的<strong>重点是修改</strong>：同样的条件, 你读取过的数据,再次读取出来发现值不一样了 幻读的重点在 于新增或者删除：同样的条件, 第1次和第2次读出来的记录数不一样</p><h3 id="11-6-2事务的隔离级别"><a href="#11-6-2事务的隔离级别" class="headerlink" title="11.6.2事务的隔离级别"></a>11.6.2事务的隔离级别</h3><table><thead><tr><th>隔离级别</th><th style="text-align:left">脏读</th><th style="text-align:left">不可重复读</th><th style="text-align:left">幻读</th><th style="text-align:left">加锁读</th></tr></thead><tbody><tr><td></td><td style="text-align:left">1修改未提交2读1回滚2读</td><td style="text-align:left">1读2修改提交1再读</td><td style="text-align:left">1读2增加3读（发现多了一条数据）</td><td style="text-align:left"></td></tr><tr><td>读未提交(read uncommitter）</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>读已提交(read committed)</td><td style="text-align:left">✖</td><td style="text-align:left">✔</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>可重复读(repeatable read)</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">✔</td><td style="text-align:left">不加</td></tr><tr><td>可串行化读(serializable)</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">✖</td><td style="text-align:left">加锁</td></tr></tbody></table><ul><li>设置事务的隔离级别</li></ul><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><ul><li>查看当前隔离级别：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li>隔离级别：客串行化例子：</li></ul><ol><li>当客户端A在执行select过程中（还没有提交结束事务），DBMS会对库加锁，如果这时客户端B执行插入，只要还没释放锁，插入不进去，会将B的update语句放入阻塞队列，直到释放了锁或超时。</li></ol><blockquote><p><strong>说明：mysql默认的隔离级别是可重复读，一般情况下不要修改，修改完后一定要修改回去，要不然就会一直保持直到关闭客户端。</strong></p></blockquote><h2 id="11-7事务的ACID特性"><a href="#11-7事务的ACID特性" class="headerlink" title="11.7事务的ACID特性"></a>11.7事务的ACID特性</h2><ul><li><strong>原子性（Atomicity）</strong></li></ul><p>事务是应用中最小的执行单位，具有不可再分的特征，事务是应用中不可再分的最小逻辑执行体。</p><ul><li><strong>一致性（Consistency</strong>）</li></ul><p>事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态。当数据库只包含事务成功提交的结果 时，数据库处于一致性状态。如果系统运行发生中断，某个事务尚未完成而被迫中断，而改未完成的事务对数据库 所做的修改已被写入数据库，此时数据库就处于一种不正确（不一致）的状态。因此一致性是通过原子性来保证的。</p><ul><li><strong>隔离性（lsolation）</strong></li></ul><p>各种事务的执行互不干扰，任意一个事务的内部操作对其他并发事务都是隔离的。也就是说，并发执行的事务之间不能看到对方的中间状态。并发执行的事务之间不能互相影响。</p><ul><li><strong>持久性（Durability）</strong></li></ul><p>持久性是指一个事务一旦被提交，它对数据库所做的改变都要记录到永久存储其中（如：磁盘）。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-索引特性</title>
      <link href="/2019/01/04/10-%E7%B4%A2%E5%BC%95%E7%89%B9%E6%80%A7/"/>
      <url>/2019/01/04/10-%E7%B4%A2%E5%BC%95%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="10索引特性（重点-）"><a href="#10索引特性（重点-）" class="headerlink" title="10索引特性（重点**）"></a>10索引特性（重点**）</h1><p>索引：提高数据库的性能，索引是物美价廉的东西。不用增加内存，不用该程序，不用调sql ,只要执行正确的<code>create index</code>，查询 ==速度== 就能提高成百上千倍。但是查速度的提高是以插入，更新，删除的速度为代价的，这些写操作，增加了大量的IO。所以它的价值，在于提高==海量数据的键锁速度==。</p><p><strong>常见索引分为：</strong></p><ul><li>主键索引（primary key)</li><li>唯一键索引（unique）</li><li>普通索引 (index)</li><li>全文索引（fulltext）–解决中文索引问题</li></ul><p><strong>索引部分目前只做简单学习，下来将索引部分详细研究后再对本篇博客做补充。</strong></p><a id="more"></a><p><strong>练习</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- 构建一个8000000条记录的数据 --构建的海量表数据需要有差异性，所以使用存储过程来创建， 拷贝下面代码就可以了，暂时不用理解</span><br><span class="line"> </span><br><span class="line">-- 产生随机字符串 </span><br><span class="line">delimiter $$ </span><br><span class="line">create function rand_string(n INT) </span><br><span class="line">returns varchar(255) </span><br><span class="line">begin  </span><br><span class="line">declare chars_str varchar(100) default   &apos;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&apos;; </span><br><span class="line">declare return_str varchar(255) default &apos;&apos;; </span><br><span class="line">declare i int default 0; </span><br><span class="line">while i &lt; n do    </span><br><span class="line">set return_str =concat(return_str,substring(chars_str,floor(1+rand()*52),1));   set i = i + 1;   </span><br><span class="line">end while;  </span><br><span class="line">return return_str;  </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">--产生随机数字 delimiter $$ </span><br><span class="line">create function rand_num() </span><br><span class="line">returns int(5) </span><br><span class="line">begin  </span><br><span class="line">declare i int default 0; </span><br><span class="line">set i = floor(10+rand()*500); </span><br><span class="line">return i; </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">--创建存储过程，向雇员表添加海量数据 </span><br><span class="line">delimiter $$ </span><br><span class="line">create procedure insert_emp(in start int(10),in max_num int(10))</span><br><span class="line">begin </span><br><span class="line">declare i int default 0;  </span><br><span class="line">set autocommit = 0;   </span><br><span class="line">repeat  set i = i + 1;  </span><br><span class="line">insert into EMP values ((start+i) ,rand_string(6),&apos;SALESMAN&apos;,0001,curdate(),2000,400,rand_num());  </span><br><span class="line">until i = max_num </span><br><span class="line">end repeat; </span><br><span class="line">commit; </span><br><span class="line">end $$ </span><br><span class="line">delimiter ;</span><br><span class="line"> -- 执行存储过程，添加8000000条记录 </span><br><span class="line"> call insert_emp(100001, 8000000);</span><br></pre></td></tr></table></figure><p>目前没有进行mysql sql编程的经验，以下只做这几点的概述。</p><p>关于<code>delimiter $$</code>的意思</p><blockquote><p>将分隔符； 临时性的改为$$  防止在函数中出现” ; “会导致直接执行。<code>用完后改回来。delimiter ;</code></p></blockquote><p>建立处海量数据的表（8000000条数据）</p><ul><li><p>查询员工编号为9998877的员工，MySQL会从第一条数据开始遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp whrer empno=998877;</span><br></pre></td></tr></table></figure><p>耗时4.93秒（耗时时间跟储存介质即电脑中储存mysql数据的硬盘有关），在实际项目中，本机是由一个人来操作的，假如放到公网中，同时又10000个人并发查询，则就可能引起死机</p><p><strong>解决办法：</strong>创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table emp add index(empno);</span><br></pre></td></tr></table></figure><p>耗时0.1秒都不到大大加快了查询速度，但是创建索引的过程还是耗时挺久的4秒左右。</p><p>粗略估计增加了快500倍。</p></li></ul><h2 id="10-1查询过程中的基本原理"><a href="#10-1查询过程中的基本原理" class="headerlink" title="10.1查询过程中的基本原理"></a>10.1查询过程中的基本原理</h2><ul><li><p>没有索引时：执行<code>select * from emp whrer empno=998877;sql语句是对这张存有海量数据的表进行整表的查询</code></p></li><li><p>而增加索引，会让表中数据形成一棵树（MySQL 中默认引擎innodb是形成一颗B+树）影响查询速度的是<strong>树的深度</strong></p><p>B+树 是 普通二叉树的升级版，减少了树的深度。</p><p>B+Tree：详解</p><p><a href="https://zhuanlan.zhihu.com/p/24309634" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24309634</a></p></li></ul><h2 id="10-2创建索引"><a href="#10-2创建索引" class="headerlink" title="10.2创建索引"></a>10.2创建索引</h2><h3 id="10-2-1创建主键索引"><a href="#10-2-1创建主键索引" class="headerlink" title="10.2.1创建主键索引"></a>10.2.1创建主键索引</h3><ul><li><p>第一种方式：</p><p>==在创建表的时候，直接在字段名后面直接指定<code>primay key</code>==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table user(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(30)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第二种方式</p><p>==在创建表最后，指定某列或者几列为主键索引==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><p>第三种方式：</p><p>==创建表之后再添加主题==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ccreate table  user3(</span><br><span class="line">    id int, </span><br><span class="line">    name varchar(30)</span><br><span class="line">); </span><br><span class="line">-- 创建表以后再添加主键 </span><br><span class="line">alter table user3 add primary key(id);</span><br></pre></td></tr></table></figure></li></ul><p><strong>主键索引的特点</strong>：</p><ul><li>一个表中，最多有一个主键索引，当然可以使复合主键 </li><li>主键索引的效率高（主键不可重复） </li><li>创建主键索引的列，它的值不能为null，且不能重复 </li><li>主键索引的列基本上是int</li></ul><h3 id="10-2-2唯一键的创建"><a href="#10-2-2唯一键的创建" class="headerlink" title="10.2.2唯一键的创建"></a>10.2.2唯一键的创建</h3><ul><li><p>第一种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 在表定义时，在某列后直接指定unique唯一属性。 </span><br><span class="line">create table user4(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30) unique</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第二种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表时，在表的后面指定某列或某几列为unique </span><br><span class="line">create table user5(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30), </span><br><span class="line">    unique(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>第三种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user6(</span><br><span class="line">    id int primary key, </span><br><span class="line">    name varchar(30)</span><br><span class="line">）； </span><br><span class="line">-- </span><br><span class="line">alter table user6 add unique(name);</span><br></pre></td></tr></table></figure></li></ul><p><strong>唯一索引的特点：</strong></p><ul><li>一个表中，可以有多个唯一索引 </li><li>查询效率高 如果在某一列建立唯一索引，必须保证这列不能有重复数据 </li><li>==如果一个唯一索引上指定not null，等价于主键索引==</li></ul><h3 id="10-2-3-普通索引的创建"><a href="#10-2-3-普通索引的创建" class="headerlink" title="10.2.3 普通索引的创建"></a>10.2.3 普通索引的创建</h3><ul><li>第一种方式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table user8(id int primary key,     </span><br><span class="line">name varchar(20),     </span><br><span class="line">email varchar(30),     </span><br><span class="line">index(name) --在表的定义最后，指定某列为索引 </span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>第二种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table user9(id int primary key,  name varchar(20),  email varchar(30)); </span><br><span class="line">alter table user9 add index(name); </span><br><span class="line">-- 创建完表以后指定某列为普通索引</span><br></pre></td></tr></table></figure></li><li><p>第三种方式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table user10(id int primary key,  </span><br><span class="line">name varchar(20),  </span><br><span class="line">email varchar(30)</span><br><span class="line">); </span><br><span class="line">-- 创建一个索引名为 idx_name 的索引    </span><br><span class="line">create index idx_name on user10(name);</span><br></pre></td></tr></table></figure><p>普通索引的特点：</p><ul><li>一个表中可以有多个普通索引，普通索引在实际开发中用的比较多 </li><li>如果某列需要创建索引，==但是该列有重复的值==，那么我们就应该使用普通索引 </li></ul><h3 id="10-2-4全文索引"><a href="#10-2-4全文索引" class="headerlink" title="10.2.4全文索引"></a>10.2.4全文索引</h3><p>当文章字段或有大量文字的字段进行检索时，会使用到全文索引。MySQL提供全文索引机制。之前是只有在MyISAM引擎，现在innodb引擎也支持全文索引。但是默认支持的是英文，你不支持中文。</p><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE articles (    </span><br><span class="line">id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,    </span><br><span class="line">title VARCHAR(200),    </span><br><span class="line">body TEXT,    </span><br><span class="line">FULLTEXT (title,body) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO articles (title,body) VALUES    </span><br><span class="line">(&apos;MySQL Tutorial&apos;,&apos;DBMS stands for DataBase ...&apos;),    </span><br><span class="line">(&apos;How To Use MySQL Well&apos;,&apos;After you went through a ...&apos;),    </span><br><span class="line">(&apos;Optimizing MySQL&apos;,&apos;In this tutorial we will show ...&apos;),    </span><br><span class="line">(&apos;1001 MySQL Tricks&apos;,&apos;1. Never run mysqld as root. 2. ...&apos;),    </span><br><span class="line">(&apos;MySQL vs. YourSQL&apos;,&apos;In the following database comparison ...&apos;),    </span><br><span class="line">(&apos;MySQL Security&apos;,&apos;When configured properly, MySQL ...&apos;);</span><br></pre></td></tr></table></figure><ul><li>查询有没有’database‘数据</li></ul><p>如果使用如下方式查询，虽然查询出结果，但是没有用到全文索引.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from artices where body like &apos;%database%&apos;;</span><br><span class="line"></span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br></pre></td></tr></table></figure><p>可以使用explain工具看一下，是否使用到索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from articles where body like &apos;database&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE  -- ：简单查询</span><br><span class="line">        table: articles</span><br><span class="line">   partitions: NULL   -- possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</span><br><span class="line">         type: ALL    -- ：全表查询</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL   -- &lt;==key为null表示没有用到索引</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL    -- 显示索引的哪一列被使用了，如果可能的话，是一个常数</span><br><span class="line">         rows: 6       -- ：这个值是innodb预估的一个值(并不是是一个准确值)MYSQL认为必须检查的用来返回请求数据的行数</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><ul><li>全文索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;select * from articles</span><br><span class="line">    -&gt; where match(title,body) against (&apos;database&apos;);</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">| id | title             | body                                     |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">|  1 | MySQL Tutorial    | DBMS stands for DataBase ...             |</span><br><span class="line">|  5 | MySQL vs. YourSQL | In the following database comparison ... |</span><br><span class="line">+----+-------------------+------------------------------------------+</span><br><span class="line">2 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure><p>通过explain来分析这个sql语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;  explain SELECT * FROM articles WHERE MATCH (title,body) AGAINST (&apos;database&apos;)\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: articles</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: fulltext  -- 全文索引</span><br><span class="line">possible_keys: title</span><br><span class="line">          key: title     -- &lt;=key 用到了title</span><br><span class="line">      key_len: 0</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>关于explain 分析后的结果参数内容含义解释如下：<a href="https://www.cnblogs.com/yycc/p/7338894.html" target="_blank" rel="noopener">https://www.cnblogs.com/yycc/p/7338894.html</a></p><h2 id="10-3查询索引"><a href="#10-3查询索引" class="headerlink" title="10.3查询索引"></a>10.3查询索引</h2><ul><li>第一种方法： <code>show key from 表明</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show keys from articles\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: articles  -- :表名</span><br><span class="line">   Non_unique: 0   -- 0表示唯一索引</span><br><span class="line">     Key_name: PRIMARY-- &lt;=主键索引</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: id-- 索引在那里列</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null:</span><br><span class="line">   Index_type: BTREE   ： -- 以二叉树形式的索引</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: articles</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: title</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: title</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: articles</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: title</span><br><span class="line"> Seq_in_index: 2</span><br><span class="line">  Column_name: body</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 6</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><ul><li><p>第二种方式：<code>show index from 表明;</code></p></li><li><p>第三种方式（信息比较简略）：<code>desc 表明：</code></p></li></ul><h2 id="10-4删除索引"><a href="#10-4删除索引" class="headerlink" title="10.4删除索引"></a>10.4删除索引</h2><ul><li>第一种方法-删除主键索引：<code>alter table 表明 drop primary key;</code></li><li>第二种方法-其他索引的删除： <code>alter table 表明 drop index 索引名; 索引名就是show keys from 表名种的key_name字段</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user10 drop index idx_name;</span><br></pre></td></tr></table></figure><ul><li>第三种方法方法：drop index 索引名 on 表名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index name on user10;</span><br></pre></td></tr></table></figure><h2 id="10-5索引创建原则"><a href="#10-5索引创建原则" class="headerlink" title="10.5索引创建原则"></a>10.5索引创建原则</h2><ul><li>比较频繁作为查询条件的字段应该创建索引</li><li>唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件（主要业务的要求）</li><li>更新非常频繁的字段不适合当作创建索引</li><li>不会出现在where子句中的字段不该创建索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>09-表的内外连接</title>
      <link href="/2019/01/03/09-%E8%A1%A8%E7%9A%84%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/01/03/09-%E8%A1%A8%E7%9A%84%E5%86%85%E5%A4%96%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><strong>配合食用效果极佳 </strong></p><p><strong>内连接查询：</strong>往往使用频繁，可以配合多种查询方法食用。</p><p>内连接就是两表的笛卡儿积表的基础上进行筛选</p><p><strong>外连接查询：</strong>首先要确定<strong>基准表</strong>（<strong>基准信息</strong>），即左连接的左表，右连接的右表。然后确定<strong>结合表</strong>，结合表需要的筛选条件。</p><a id="more"></a><h1 id="09-表的内外连接"><a href="#09-表的内外连接" class="headerlink" title="09 表的内外连接"></a>09 表的内外连接</h1><h2 id="9-1内链接"><a href="#9-1内链接" class="headerlink" title="9.1内链接"></a>9.1内链接</h2><p>内连接实际上就是利用where子句对两种表形成的笛卡儿积进行筛选，我们前面学习的查询都是内连接，也是在开发过程中使用的最多的连接查询</p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表1 inner join 表2 on 连接条件 and其他连接条件;</span><br></pre></td></tr></table></figure><blockquote><p>之前学的就是内连接</p></blockquote><p>显示smith的名字和部门名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 之前写法</span><br><span class="line">select ename,dename from emp,dept where emp.deptno=dept.deptno and ename=&apos;smith&apos;;</span><br><span class="line"></span><br><span class="line">-- 标准内连接写法</span><br><span class="line">select ename,dename from emp inner join dept on emp.deptno=dept.depyno and ename=&apos;smith&apos;;</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>inner join就是inner join两个表的笛卡儿积中筛选on 后的条件</p><h2 id="9-2外连接"><a href="#9-2外连接" class="headerlink" title="9.2外连接"></a>9.2外连接</h2><p>外连接分为左连接右连接。（记住一种自己熟悉的即可）</p><h3 id="9-2-1左外连接"><a href="#9-2-1左外连接" class="headerlink" title="9.2.1左外连接"></a>9.2.1左外连接</h3><p><strong>左外连接:</strong>  如果联合查询的时，左侧的表我们完全显示 </p><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段名 from 表名1 left join 表名2 on 连接条件</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>left join就是左表（一定显示）和右表中on后筛选后的表的结合（以左表为基础上添加（符合筛选条件的）右表）</p><h3 id="9-2-2右外连接"><a href="#9-2-2右外连接" class="headerlink" title="9.2.2右外连接"></a>9.2.2右外连接</h3><p><strong>右连接：</strong>如果联合查询，右侧的表完全显示我们就说是右外连接。</p><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 字段 from 表明1 right join 表明2 on 连接条件</span><br></pre></td></tr></table></figure><p><strong>理解：</strong>left join就是右表（一定显示）和左表中on后筛选后的表的结合（以右表为基础上添加（符合筛选条件的）左标）</p><p><strong>小练习：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 键两张表</span><br><span class="line">create table stu (id int, name varchar(30));  -- 学生表 </span><br><span class="line">insert into stu values(1,&apos;jack&apos;),(2,&apos;tom&apos;),(3,&apos;kity&apos;),(4,&apos;nono&apos;); </span><br><span class="line"></span><br><span class="line">create table exam (id int, grade int);  -- 成绩表</span><br><span class="line">insert into exam values(1, 56),(2,76),(11, 8);</span><br></pre></td></tr></table></figure><ul><li><p><strong>查询所有学生的成绩，如果没有这个学生的成绩，也要将学生的个人信息显示出来。</strong></p><p><strong>分析：</strong>关键字:所有学生， 成绩，（没有成绩也要显示出来） （<strong>以学生表为基准表，结合成绩表</strong>）外连接（左右都可以）</p><p><strong>左外连接：</strong></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu left inner exam on stu.id=exam.id;</span><br></pre></td></tr></table></figure><p>​    <strong>右外连接：</strong>（不适合，因为一般都是基准表在结合表的前面显示）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select stu.* from exam right inner stu on stu.id=exam.id;</span><br><span class="line"></span><br><span class="line">-- 改为：（太麻烦）</span><br><span class="line">select stu.id ,stu.name,exam.id,exam.grade from exam right join stu on stu.id=exam.id;</span><br></pre></td></tr></table></figure><ul><li><strong>对stu表和exam表联合查询，把所有的成绩都显示出来，即使这个成绩没有学生与它对应，也要显示出来</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu right join exam on stu.id=exam.id;</span><br></pre></td></tr></table></figure><ul><li><p><strong>列处部门名称和这些部门的员工信息，同时列出没有员工的部门</strong></p><p><strong>分析：</strong>关键字（部门名称，这些部分的员工信息，列出没有员工的部门）（<strong>以部门名称基准表，结合与员工表</strong>）外连接（左右都可以）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 方法一：</span><br><span class="line">select d.dname, e.* from dept d left join emp e on d.deptno=e.deptno; </span><br><span class="line">-- 方法二： </span><br><span class="line">select d.dname, e.* from emp e right join dept d on d.deptno=e.deptno;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><blockquote><p>内连接查询：往往使用频繁，可以配合多种查询方法食用。</p><p>内连接就是两表的笛卡儿积表的基础上进行筛选</p><p>外连接查询：首先要确定<strong>基准表</strong>（<strong>基准信息</strong>），即左连接的左表，右连接的右表。然后确定<strong>结合表</strong>，结合表需要的筛选条件。</p></blockquote><blockquote><p><strong>SQL</strong>查询中各个关键字的执行先后顺序：</p><p>from &gt; on&gt; join &gt; where &gt; group by &gt; with &gt; having &gt; select &gt; distinct &gt; order by &gt; limit</p></blockquote><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>1.<a href="https://leetcode-cn.com/problems/rank-scores/" target="_blank" rel="noopener">178. 分数排名</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</span><br><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Create table If Not Exists Scores (Id int, Score DECIMAL(3,2))；</span><br><span class="line">Truncate table Scores</span><br><span class="line">insert into Scores (Id, Score) values (&apos;1&apos;, &apos;3.5&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;2&apos;, &apos;3.65&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;3&apos;, &apos;4.0&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;4&apos;, &apos;3.85&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;5&apos;, &apos;4.0&apos;)；</span><br><span class="line">insert into Scores (Id, Score) values (&apos;6&apos;, &apos;3.65&apos;)；</span><br></pre></td></tr></table></figure><p><strong>解答</strong>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">a.Score as Score,</span><br><span class="line">count(*) as Rank</span><br><span class="line">from Scores a inner join (select distinct Score from Scores ) b </span><br><span class="line">where a.Score&lt;=b.Score</span><br><span class="line">group by a.id</span><br><span class="line">order by Rank;</span><br></pre></td></tr></table></figure><p>2.<a href="https://leetcode-cn.com/problems/exchange-seats/" target="_blank" rel="noopener">626. 换座位</a></p><p><strong>题目描述：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">小美是一所中学的信息科技老师，她有一张 seat 座位表，平时用来储存学生名字和与他们相对应的座位 id。</span><br><span class="line"></span><br><span class="line">其中纵列的 id 是连续递增的</span><br><span class="line"></span><br><span class="line">小美想改变相邻俩学生的座位。</span><br><span class="line"></span><br><span class="line">你能不能帮她写一个 SQL query 来输出小美想要的结果呢？</span><br><span class="line"></span><br><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Abbot   |</span><br><span class="line">|    2    | Doris   |</span><br><span class="line">|    3    | Emerson |</span><br><span class="line">|    4    | Green   |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">+---------+---------+</span><br><span class="line">|    id   | student |</span><br><span class="line">+---------+---------+</span><br><span class="line">|    1    | Doris   |</span><br><span class="line">|    2    | Abbot   |</span><br><span class="line">|    3    | Green   |</span><br><span class="line">|    4    | Emerson |</span><br><span class="line">|    5    | Jeames  |</span><br><span class="line">+---------+---------+</span><br></pre></td></tr></table></figure><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL练习复合查询</title>
      <link href="/2019/01/03/MySQL%E7%BB%83%E4%B9%A0%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
      <url>/2019/01/03/MySQL%E7%BB%83%E4%B9%A0%E5%A4%8D%E5%90%88%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p><strong>复合查询（重点）</strong></p><ul><li>函数得使用</li></ul><ul><li><p>多表查询</p></li><li><p>自连接</p></li><li><p>子查询</p></li></ul><a id="more"></a><h1 id="07-MySQL-函数"><a href="#07-MySQL-函数" class="headerlink" title="07-MySQL 函数"></a>07-MySQL 函数</h1><h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><blockquote><p>查找字符串’10,A,B’ 中逗号’,’出现的次数cnt。</p></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select length(&apos;10,A,B&apos;)-length(replace(&apos;10,A,B&apos;, &apos;,&apos; ,&apos;&apos;)) as cnt;</span><br></pre></td></tr></table></figure><h1 id="08-MySQL-复合查询"><a href="#08-MySQL-复合查询" class="headerlink" title="08-MySQL 复合查询"></a>08-MySQL 复合查询</h1><h2 id="1-题目描述-1"><a href="#1-题目描述-1" class="headerlink" title="1.题目描述"></a>1.题目描述</h2><blockquote><p>查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, s.salary from employees as e, salaries as s where e.emp_no =s.emp_no and e.hire_date = s.from_date order by e.emp_no desc;</span><br></pre></td></tr></table></figure><p><strong>解决2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, s.salary from employees as e inner join salaries as s on e.emp_no = s.emp_no and e.hire_date = s.from_date order by e.emp_no desc;</span><br></pre></td></tr></table></figure><h2 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2.题目描述"></a>2.题目描述</h2><blockquote><p>针对库中的所有表生成select count(*)对应的SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; create table emp_bonus(</span><br><span class="line">&gt; emp_no int not null,</span><br><span class="line">&gt; recevied datetime not null,</span><br><span class="line">&gt; btype smallint not null);</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_emp` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(&apos;select count(*) from &apos;,t.TABLE_NAME,&apos;;&apos;) AS cnts  from (select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA = database()) t;</span><br></pre></td></tr></table></figure><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &quot;select count(*) from &quot;||name||&quot;;&quot; as cnts  from sqlite_master where type=&apos;table&apos;</span><br></pre></td></tr></table></figure><h2 id="3-题目描述"><a href="#3-题目描述" class="headerlink" title="3.题目描述"></a>3.题目描述</h2><blockquote><p>获取所有非manager的员工emp_no</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no from employees as e left join dept_manager as d on e.emp_no =d.emp_no where d.dept_no is null</span><br></pre></td></tr></table></figure><h2 id="4-题目描述"><a href="#4-题目描述" class="headerlink" title="4.题目描述"></a>4.题目描述</h2><blockquote><p>获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。<br>结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_emp` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解决：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.emp_no, m.emp_no as manager_no from dept_emp as e inner join dept_manager as m on e.dept_no = m.dept_no where e.to_date = &apos;9999-01-01&apos; and m.to_date = &apos;9999-01-01&apos; and e.emp_no != m.emp_no;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
            <tag> MySQL数据库练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL练习</title>
      <link href="/2019/01/02/MySQL%E7%BB%83%E4%B9%A0/"/>
      <url>/2019/01/02/MySQL%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>MySQL基本查询得练习（基础部分）</strong></p><p>MySQL学习得关键多连多练多练！！！</p><a id="more"></a><h1 id="MySQL小练"><a href="#MySQL小练" class="headerlink" title="MySQL小练"></a>MySQL小练</h1><h2 id="06-MySQL基本查询"><a href="#06-MySQL基本查询" class="headerlink" title="06-MySQL基本查询"></a>06-MySQL基本查询</h2><h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><blockquote><p>对于表actor批量插入如下数据<br>`</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE  IF NOT EXISTS actor  (`</span><br><span class="line">&gt; `actor_id  smallint(5)  NOT NULL PRIMARY KEY,`</span><br><span class="line">&gt; `first_name  varchar(45) NOT NULL,`</span><br><span class="line">&gt; `last_name  varchar(45) NOT NULL,`</span><br><span class="line">&gt; `last_update  timestamp NOT NULL DEFAULT (datetime(&apos;now&apos;,&apos;localtime&apos;)))`</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">insert into actor(actor_id,first_name,last_name,last_update) values</span><br><span class="line">(1,&apos;PENELOPE&apos;,&apos;GUINESS&apos;,&apos;2006-02-15 12:34:33 &apos;),</span><br><span class="line">(2,&apos;NICK&apos;,&apos;WAHLBERG&apos;,&apos;2006-02-15 12:34:33&apos;);</span><br></pre></td></tr></table></figure><h3 id="2-题目描述"><a href="#2-题目描述" class="headerlink" title="2. 题目描述"></a>2. 题目描述</h3><blockquote><p>找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct salary from salaries where to_date = &apos;9999-01-01&apos; order by salary desc;</span><br></pre></td></tr></table></figure><h3 id="3-题目描述"><a href="#3-题目描述" class="headerlink" title="3. 题目描述"></a>3. 题目描述</h3><blockquote><p>查找最晚入职员工的所有信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt;  PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt; </span><br><span class="line">&gt; **解答：</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 1;</span><br></pre></td></tr></table></figure><h3 id="4-题目描述"><a href="#4-题目描述" class="headerlink" title="4. 题目描述"></a>4. 题目描述</h3><blockquote><p>查找入职员工时间排名倒数第三的员工所有信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `employees` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `birth_date` date NOT NULL,</span><br><span class="line">&gt; `first_name` varchar(14) NOT NULL,</span><br><span class="line">&gt; `last_name` varchar(16) NOT NULL,</span><br><span class="line">&gt; `gender` char(1) NOT NULL,</span><br><span class="line">&gt; `hire_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees order by hire_date desc limit 2,1;</span><br></pre></td></tr></table></figure><h3 id="5-题目描述"><a href="#5-题目描述" class="headerlink" title="5. 题目描述"></a>5. 题目描述</h3><blockquote><p>查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select emp_no , count(distinct salary) t from salaries group by emp_no having t&gt;15;</span><br></pre></td></tr></table></figure><h3 id="6-题目描述"><a href="#6-题目描述" class="headerlink" title="6. 题目描述"></a>6. 题目描述</h3><blockquote><p>获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE `dept_manager` (</span><br><span class="line">&gt; `dept_no` char(4) NOT NULL,</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`dept_no`));</span><br><span class="line">&gt; CREATE TABLE `salaries` (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `salary` int(11) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date NOT NULL,</span><br><span class="line">&gt; PRIMARY KEY (`emp_no`,`from_date`));</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select dept_no, d.emp_no ,salary from salaries as s ,dept_manager as d </span><br><span class="line">where s.emp_no = d.emp_no </span><br><span class="line">and d.to_date = &apos;9999-01-01&apos; </span><br><span class="line">and s.to_date = &apos;9999-01-01&apos;;</span><br></pre></td></tr></table></figure><h3 id="7-题目描述"><a href="#7-题目描述" class="headerlink" title="7. 题目描述"></a>7. 题目描述</h3><blockquote><p>从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE IF NOT EXISTS &quot;titles&quot; (</span><br><span class="line">&gt; `emp_no` int(11) NOT NULL,</span><br><span class="line">&gt; `title` varchar(50) NOT NULL,</span><br><span class="line">&gt; `from_date` date NOT NULL,</span><br><span class="line">&gt; `to_date` date DEFAULT NULL);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select title ,count(title) t from titles group by title having t&gt;=2;</span><br></pre></td></tr></table></figure><h3 id="8-LeetCode-182-查找重复的电子邮箱"><a href="#8-LeetCode-182-查找重复的电子邮箱" class="headerlink" title="8. LeetCode [182. 查找重复的电子邮箱]"></a>8. LeetCode [182. 查找重复的电子邮箱]</h3><blockquote><p>编写一个 SQL 查询，查找 <code>Person</code> 表中所有重复的电子邮箱。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; Create table If Not Exists Person (</span><br><span class="line">&gt; Id int, </span><br><span class="line">&gt; Email varchar(255)</span><br><span class="line">&gt; );</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select Email from Person group by Email having count(Email)&gt;1;</span><br></pre></td></tr></table></figure><h3 id="9-LeetCode-595-大的国家"><a href="#9-LeetCode-595-大的国家" class="headerlink" title="9. LeetCode [595.大的国家]"></a>9. LeetCode [595.大的国家]</h3><blockquote><p>这里有张 <code>World</code> 表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt; | name            | continent  | area       | population   | gdp           |</span><br><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt; | Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |</span><br><span class="line">&gt; | Albania         | Europe     | 28748      | 2831741      | 12960000      |</span><br><span class="line">&gt; | Algeria         | Africa     | 2381741    | 37100000     | 188681000     |</span><br><span class="line">&gt; | Andorra         | Europe     | 468        | 78115        | 3712000       |</span><br><span class="line">&gt; | Angola          | Africa     | 1246700    | 20609294     | 100990000     |</span><br><span class="line">&gt; +-----------------+------------+------------+--------------+---------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>如果一个国家的面积超过300万平方公里，或者人口超过2500万，那么这个国家就是大国家。</p><p>编写一个SQL查询，输出表中所有大国家的名称、人口和面积。</p><p>例如，根据上表，我们应该输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt; | name         | population  | area         |</span><br><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt; | Afghanistan  | 25500100    | 652230       |</span><br><span class="line">&gt; | Algeria      | 37100000    | 2381741      |</span><br><span class="line">&gt; +--------------+-------------+--------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>World表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; Create table If Not Exists World (</span><br><span class="line">&gt; </span><br><span class="line">&gt; name varchar(255), </span><br><span class="line">&gt; </span><br><span class="line">&gt; continent varchar(255), </span><br><span class="line">&gt; </span><br><span class="line">&gt; area int, </span><br><span class="line">&gt; </span><br><span class="line">&gt; population int,</span><br><span class="line">&gt; </span><br><span class="line">&gt; gdp int</span><br><span class="line">&gt; </span><br><span class="line">&gt; )；</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select name ,population,area from World where area&gt;3000000 or population&gt;25000000;</span><br></pre></td></tr></table></figure><h3 id="10-LeetCode-177-第N高薪水"><a href="#10-LeetCode-177-第N高薪水" class="headerlink" title="10. LeetCode[177.第N高薪水]"></a>10. LeetCode[177.第N高薪水]</h3><blockquote><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第 <em>n</em> 高的薪水（Salary）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; +----+--------+</span><br><span class="line">&gt; | Id | Salary |</span><br><span class="line">&gt; +----+--------+</span><br><span class="line">&gt; | 1  | 100    |</span><br><span class="line">&gt; | 2  | 200    |</span><br><span class="line">&gt; | 3  | 300    |</span><br><span class="line">&gt; +----+--------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>例如上述 <code>Employee</code> 表，<em>n = 2</em> 时，应返回第二高的薪水 <code>200</code>。如果不存在第 <em>n</em> 高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; +------------------------+</span><br><span class="line">&gt; | getNthHighestSalary(2) |</span><br><span class="line">&gt; +------------------------+</span><br><span class="line">&gt; | 200                    |</span><br><span class="line">&gt; +------------------------+</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  declare M Int;</span><br><span class="line">  Set M = N-1;</span><br><span class="line">  RETURN (</span><br><span class="line">      # Write your MySQL query statement below.</span><br><span class="line">      select distinct Salary from Employee  order by Salary desc LIMIT M,1</span><br><span class="line">  );</span><br><span class="line">END</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
            <tag> MySQL数据库练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/05/15/hello-world/"/>
      <url>/2018/05/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p><strong>博客开始2018</strong></p><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
